{"version":3,"sources":["index.js","lib/less-node/index.js","lib/less-node/environment.js","lib/less-node/file-manager.js","lib/less-node/fs.js","lib/less/environment/abstract-file-manager.js","lib/less-node/url-file-manager.js","lib/less/logger.js","lib/less/index.js","lib/less/environment/environment.js","lib/less/data/index.js","lib/less/data/colors.js","lib/less/data/unit-conversions.js","lib/less/tree/index.js","lib/less/tree/node.js","lib/less/tree/color.js","lib/less/tree/atrule.js","lib/less/tree/selector.js","lib/less/tree/element.js","lib/less/tree/paren.js","lib/less/tree/combinator.js","lib/less/less-error.js","lib/less/utils.js","lib/less/constants.js","lib/less/parser/parser.js","lib/less/visitors/index.js","lib/less/visitors/visitor.js","lib/less/visitors/import-visitor.js","lib/less/contexts.js","lib/less/visitors/import-sequencer.js","lib/less/visitors/set-tree-visibility-visitor.js","lib/less/visitors/extend-visitor.js","lib/less/visitors/join-selector-visitor.js","lib/less/visitors/to-css-visitor.js","lib/less/parser/parser-input.js","lib/less/parser/chunker.js","lib/less/functions/function-registry.js","lib/less/tree/atrule-syntax.js","lib/less/tree/ruleset.js","lib/less/tree/declaration.js","lib/less/tree/value.js","lib/less/tree/keyword.js","lib/less/tree/anonymous.js","lib/less/tree/comment.js","lib/less/tree/debug-info.js","lib/less/functions/default.js","lib/less/tree/detached-ruleset.js","lib/less/tree/operation.js","lib/less/tree/dimension.js","lib/less/tree/unit.js","lib/less/tree/variable.js","lib/less/tree/call.js","lib/less/functions/function-caller.js","lib/less/tree/expression.js","lib/less/tree/property.js","lib/less/tree/attribute.js","lib/less/tree/quoted.js","lib/less/tree/url.js","lib/less/tree/import.js","lib/less/tree/media.js","lib/less/tree/nested-at-rule.js","lib/less/tree/javascript.js","lib/less/tree/js-eval-node.js","lib/less/tree/assignment.js","lib/less/tree/condition.js","lib/less/tree/query-in-parens.js","lib/less/tree/container.js","lib/less/tree/unicode-descriptor.js","lib/less/tree/negative.js","lib/less/tree/extend.js","lib/less/tree/variable-call.js","lib/less/tree/namespace-value.js","lib/less/tree/mixin-call.js","lib/less/tree/mixin-definition.js","lib/less/environment/abstract-plugin-loader.js","lib/less/functions/index.js","lib/less/functions/boolean.js","lib/less/functions/color.js","lib/less/functions/color-blending.js","lib/less/functions/data-uri.js","lib/less/functions/list.js","lib/less/functions/math.js","lib/less/functions/math-helper.js","lib/less/functions/number.js","lib/less/functions/string.js","lib/less/functions/svg.js","lib/less/functions/types.js","lib/less/transform-tree.js","lib/less/plugin-manager.js","lib/less/source-map-output.js","lib/less/source-map-builder.js","lib/less/parse-tree.js","lib/less/import-manager.js","lib/less/parse.js","lib/less/render.js","package.json","lib/less-node/lessc-helper.js","lib/less-node/plugin-loader.js","lib/less/default-options.js","lib/less-node/image-size.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;;ACDA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,AHSA,AIZA;AHUA,ACHA,ACHA,AHSA,AIZA;AHUA,ACHA,ACHA,AHSA,AIZA;AHUA,ACHA,ACHA,AHSA,AKfA,ADGA;AHUA,ACHA,ACHA,AHSA,AKfA,ADGA;AHUA,ACHA,ACHA,AHSA,AKfA,ADGA;AHUA,ACHA,ACHA,AHSA,AKfA,ADGA,AENA;ALgBA,ACHA,ACHA,AHSA,AKfA,ADGA,AENA;ALgBA,ACHA,AFMA,AKfA,ADGA,AENA;ALgBA,ACHA,AFMA,AKfA,ADGA,AGTA,ADGA;AJaA,AGTA,ADGA,AGTA,ADGA;AJaA,AGTA,ADGA,AGTA,ADGA;AJaA,AGTA,ADGA,AIZA,ADGA,ADGA;AJaA,AGTA,ADGA,AIZA,ADGA,ADGA;AJaA,AGTA,ADGA,AIZA,ADGA,ADGA;AJaA,AGTA,AIZA,ALeA,AIZA,ADGA,ADGA;AJaA,AGTA,AIZA,ALeA,AIZA,ADGA,ADGA;AJaA,AGTA,AIZA,ALeA,AIZA,ADGA,ADGA;AJaA,AGTA,AKfA,ADGA,ALeA,AIZA,ADGA,ADGA;AJaA,AGTA,AKfA,ADGA,ALeA,AIZA,ADGA,ADGA;AJaA,AGTA,AKfA,ADGA,ALeA,AIZA,ADGA,ADGA;AJaA,AGTA,AKfA,ADGA,AENA,APqBA,AIZA,ADGA,ADGA;AJaA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA;AJaA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA;AJaA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AMlBA;AV+BA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AMlBA;AV+BA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AMlBA;AV+BA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AMlBA,ACHA;AXkCA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AMlBA,ACHA;AXkCA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AMlBA,ACHA;AXkCA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AQxBA,AFMA,ACHA;AXkCA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AQxBA,AFMA,ACHA;AXkCA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AQxBA,AFMA,ACHA;AXkCA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AS3BA,ADGA,AFMA,ACHA;AXkCA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AS3BA,ADGA,AFMA,ACHA;AXkCA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AS3BA,ADGA,AFMA,ACHA;AXkCA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AS3BA,ADGA,AFMA,ACHA,AGTA;Ad2CA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AS3BA,ADGA,AFMA,ACHA,AGTA;Ad2CA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AS3BA,ADGA,AFMA,ACHA,AGTA;Ad2CA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AS3BA,ADGA,AGTA,ALeA,ACHA,AGTA;Ad2CA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AS3BA,ADGA,AGTA,ALeA,ACHA,AGTA;Ad2CA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AS3BA,ADGA,AGTA,ALeA,ACHA,AGTA;Ad2CA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,ADGA,AS3BA,ADGA,AGTA,ALeA,ACHA,AKfA,AFMA;Ad2CA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,AQxBA,ADGA,AGTA,ALeA,ACHA,AKfA,AFMA;Ad2CA,AGTA,AKfA,ACHA,APqBA,AIZA,ADGA,AQxBA,ADGA,AGTA,ALeA,ACHA,AKfA,AFMA;Ad2CA,AGTA,AKfA,ANkBA,AIZA,ADGA,AQxBA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA;Ad2CA,AGTA,AKfA,ANkBA,AIZA,ADGA,AQxBA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA;Ad2CA,AGTA,AKfA,ANkBA,AIZA,ADGA,AQxBA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA;Ad2CA,AGTA,AKfA,ANkBA,AIZA,ADGA,AavCA,ALeA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA;Ad2CA,AGTA,AKfA,ANkBA,AIZA,ADGA,AavCA,ALeA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA;Ad2CA,AGTA,AKfA,ANkBA,AIZA,ADGA,AavCA,ALeA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA;Ad2CA,AGTA,AKfA,ANkBA,AIZA,ADGA,AavCA,ALeA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA;AnB0DA,AGTA,AKfA,ANkBA,AIZA,ADGA,AavCA,ALeA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA;AnB0DA,AGTA,AKfA,ANkBA,AIZA,ADGA,AavCA,ALeA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA;AnB0DA,AGTA,AiBnDA,AZoCA,ANkBA,AIZA,ADGA,AavCA,ALeA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA;AnB0DA,AGTA,AiBnDA,AZoCA,ANkBA,AIZA,ADGA,AavCA,ALeA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA;AnB0DA,AGTA,AiBnDA,AZoCA,ANkBA,AIZA,ADGA,AavCA,ALeA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA;AnB0DA,AGTA,AiBnDA,AZoCA,ANkBA,AIZA,ADGA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA;AnB0DA,AGTA,AiBnDA,AZoCA,ANkBA,AIZA,ADGA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA;AnB0DA,AGTA,AiBnDA,AZoCA,ANkBA,AIZA,ADGA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA;AnB0DA,AGTA,AiBnDA,AZoCA,ANkBA,AIZA,ADGA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA,AGTA;AtBmEA,AoB5DA,AZoCA,ANkBA,AIZA,ADGA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA,AGTA;AtBmEA,AoB5DA,AZoCA,ANkBA,AIZA,ADGA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AGTA,AKfA,AGTA;AtBmEA,AoB5DA,AZoCA,ANkBA,AIZA,ADGA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AGTA,AKfA,AGTA,ACHA;AvBsEA,AoB5DA,AZoCA,ANkBA,AIZA,ADGA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AGTA,AKfA,AGTA,ACHA;AvBsEA,AoB5DA,AZoCA,ANkBA,AIZA,ADGA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AGTA,AKfA,AGTA,ACHA;AvBsEA,AoB5DA,AZoCA,ANkBA,AIZA,ADGA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AGTA,AKfA,AKfA,AFMA,ACHA;AvBsEA,AoB5DA,AZoCA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AGTA,AKfA,AKfA,AFMA,ACHA;AvBsEA,AoB5DA,AZoCA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AGTA,AKfA,AKfA,AFMA,ACHA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AGTA,AKfA,AKfA,AFMA,ACHA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AGTA,AKfA,AKfA,AFMA,ACHA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AGTA,AKfA,AKfA,AFMA,ACHA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AKfA,AFMA,ALeA,ACHA,AGTA,AKfA,AOrBA,AFMA,AFMA,ACHA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AOrBA,AFMA,AFMA,ACHA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AOrBA,AFMA,AFMA,ACHA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AOrBA,AFMA,AFMA,AKfA,AJYA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AOrBA,AFMA,AFMA,AKfA,AJYA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AOrBA,AFMA,AFMA,AKfA,AJYA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AGTA,AJYA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AGTA,AJYA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AGTA,AJYA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AJYA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AJYA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AJYA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AGTA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AavCA,AV8BA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AavCA,AV8BA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,AavCA,AV8BA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,Ac1CA,ADGA,AV8BA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,Ac1CA,ADGA,AV8BA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AGTA,AavCA,Ac1CA,ADGA,AV8BA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,A5BoFA,AavCA,Ac1CA,ADGA,AV8BA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,A5BoFA,AavCA,Ac1CA,ADGA,AV8BA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,A5BoFA,AavCA,Ac1CA,ADGA,AV8BA,ARwBA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,A5BoFA,AavCA,Ac1CA,ADGA,AV8BA,AavCA,ArB+DA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,A5BoFA,AavCA,Ac1CA,ADGA,AV8BA,AavCA,ArB+DA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,A5BoFA,AavCA,Ac1CA,ADGA,AV8BA,AavCA,ArB+DA,ADGA,AGTA,ALeA,ACHA,AGTA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,A5BoFA,AavCA,Ac1CA,ADGA,AV8BA,AavCA,ArB+DA,ADGA,AGTA,ALeA,ACHA,AwBxEA,ArB+DA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,A5BoFA,AavCA,Ac1CA,ADGA,AV8BA,AavCA,ArB+DA,ADGA,AGTA,ALeA,ACHA,AwBxEA,ArB+DA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,A5BoFA,AavCA,Ac1CA,ADGA,AV8BA,AavCA,ArB+DA,ADGA,AGTA,ALeA,ACHA,AwBxEA,ArB+DA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,A5BoFA,AavCA,Ac1CA,ADGA,AV8BA,AavCA,ArB+DA,ADGA,AwBxEA,A1B8EA,ACHA,AwBxEA,ArB+DA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,A5BoFA,AavCA,Ac1CA,ADGA,AV8BA,AavCA,ArB+DA,ADGA,AwBxEA,A1B8EA,ACHA,AwBxEA,ArB+DA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,AavCA,ArB+DA,ADGA,AwBxEA,A1B8EA,ACHA,AwBxEA,ArB+DA,AKfA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,AavCA,ArB+DA,ADGA,AwBxEA,A1B8EA,ACHA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,ARwBA,ADGA,AwBxEA,A1B8EA,ACHA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,ARwBA,ADGA,AwBxEA,A1B8EA,ACHA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,ARwBA,ADGA,AwBxEA,A1B8EA,A4BpFA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,ARwBA,ADGA,AwBxEA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,ARwBA,ADGA,AwBxEA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,AwBxEA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,AwBxEA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,AwBxEA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,AJYA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,AJYA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,AJYA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,AFMA,AGTA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,A+B7FA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AwCxHA,AT2BA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AwCxHA,AT2BA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AwCxHA,AT2BA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AENA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AwCxHA,AT2BA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,ALeA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AwCxHA,AT2BA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,ALeA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AwCxHA,AT2BA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,ALeA,A3BiFA,AwBxEA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AwCxHA,AT2BA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,ALeA,A3BiFA,AiCnGA,AT2BA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,ANkBA,AwCxHA,AT2BA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,ALeA,A3BiFA,AiCnGA,AT2BA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AFMA,AFMA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,AkCtGA,AT2BA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,AhCgGA,AiCnGA,AT2BA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AJYA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,AkCtGA,AT2BA,Af6CA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AJYA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,AkCtGA,AxBwEA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AJYA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,AkCtGA,AxBwEA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AuBrEA,AlBsDA,AS3BA,AJYA,AKfA,ACHA,APqBA;AvBsEA,AyB3EA,AjBmDA,AkCtGA,AxBwEA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AlBsDA,AS3BA,AJYA,AKfA,ACHA,APqBA;AELA,AjBmDA,AkCtGA,AxBwEA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AlBsDA,AS3BA,AJYA,AKfA,ACHA,APqBA;AELA,AjBmDA,AkCtGA,AxBwEA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AlBsDA,AS3BA,AJYA,AKfA,ACHA,APqBA;AELA,AjBmDA,AkCtGA,AxBwEA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AKfA,ACHA,APqBA;AELA,AjBmDA,AkCtGA,AxBwEA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AKfA,ACHA,APqBA;AELA,AjBmDA,AkCtGA,AxBwEA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,ADGA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AKfA,ACHA,APqBA;AELA,AjBmDA,AkCtGA,AxBwEA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,AmCzGA,ApC4GA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AKfA,ACHA,APqBA;AELA,AjBmDA,AkCtGA,AxBwEA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,AmCzGA,ApC4GA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AKfA,ACHA,APqBA;AELA,AjBmDA,AkCtGA,AxBwEA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,AmCzGA,ApC4GA,A4BpFA,ACHA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AkCtGA,AOrBA,A/B6FA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,AmCzGA,ApC4GA,A6BvFA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AkCtGA,AOrBA,A/B6FA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,AmCzGA,ApC4GA,A6BvFA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AkCtGA,AOrBA,A/B6FA,Ac1CA,ADGA,AV8BA,AkBtDA,A1B8EA,AmCzGA,ApC4GA,A6BvFA,ALeA,AOrBA,AENA,AlCsGA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AkCtGA,AOrBA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AmCzGA,ApC4GA,A6BvFA,ALeA,AOrBA,AENA,AKfA,AvCqHA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AkCtGA,AOrBA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AmCzGA,ApC4GA,A6BvFA,ALeA,AOrBA,AENA,AKfA,AvCqHA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AkCtGA,AOrBA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AmCzGA,ApC4GA,A6BvFA,ALeA,AOrBA,AENA,AKfA,AvCqHA,AiCnGA,AT2BA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AkCtGA,AOrBA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AmCzGA,ApC4GA,A6BvFA,ALeA,AOrBA,AENA,AKfA,AvCqHA,AiCnGA,AOrBA,AhBgDA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AmCzGA,ApC4GA,A6BvFA,ALeA,AOrBA,AENA,AKfA,AvCqHA,AiCnGA,AOrBA,AhBgDA,ArB+DA,AgChGA,AT2BA,AU9BA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AmCzGA,ApC4GA,A6BvFA,ALeA,AOrBA,AENA,AKfA,AvCqHA,AiCnGA,AOrBA,AhBgDA,ArB+DA,AgChGA,ACHA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,A6BvFA,ALeA,AS3BA,AKfA,AvCqHA,AiCnGA,AOrBA,AhBgDA,ArB+DA,AgChGA,ACHA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,A6BvFA,ALeA,AS3BA,AKfA,AvCqHA,AiCnGA,AOrBA,AhBgDA,ArB+DA,AgChGA,ACHA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,A6BvFA,ALeA,AS3BA,AKfA,AvCqHA,AiCnGA,AOrBA,AhBgDA,ArB+DA,AgChGA,ACHA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AvCqHA,AiCnGA,AOrBA,AENA,AlBsDA,ArB+DA,AgChGA,ACHA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AvCqHA,AiCnGA,AOrBA,AENA,AlBsDA,ArB+DA,AgChGA,ACHA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AvCqHA,AiCnGA,AOrBA,AENA,AlBsDA,ArB+DA,AgChGA,ACHA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AvCqHA,AiCnGA,AOrBA,AENA,AlBsDA,ArB+DA,AgChGA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AvCqHA,AiCnGA,AOrBA,AENA,AlBsDA,ArB+DA,AgChGA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AvCqHA,AiCnGA,AOrBA,AENA,AlBsDA,ArB+DA,AgChGA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,A5CoIA,AiCnGA,AOrBA,AENA,AlBsDA,ArB+DA,AgChGA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,A5CoIA,AiCnGA,AOrBA,AENA,AlBsDA,ArB+DA,AgChGA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,A5CoIA,AiCnGA,AOrBA,AENA,AlBsDA,ArB+DA,AgChGA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,ACHA,A7CuIA,AiCnGA,AOrBA,AENA,AlBsDA,ArB+DA,AgChGA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,ACHA,A7CuIA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,ACHA,A7CuIA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,ACHA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,ACHA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,ARwBA,AuCrHA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,ACHA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,A+B7FA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,AGTA,AFMA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,A+B7FA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,AGTA,AFMA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AjBmDA,AyC3HA,A/B6FA,Ac1CA,ADGA,AV8BA,A+B7FA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,AGTA,AFMA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,A+B7FA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,A+B7FA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,A+B7FA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,ARwBA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,ARwBA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,ARwBA,AJYA,ApC4GA,AwBxEA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,ARwBA,AJYA,ApC4GA,AiDnJA,AzB2EA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,ARwBA,AJYA,ApC4GA,AiDnJA,AzB2EA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,ARwBA,AJYA,ApC4GA,AiDnJA,AzB2EA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AiCnGA,AOrBA,AENA,AlBsDA,AWjCA,AQxBA,APqBA,A5BoFA,AS3BA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,ARwBA,AJYA,ApC4GA,AiDnJA,AzB2EA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AiCnGA,AOrBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,ARwBA,AJYA,ApC4GA,AiDnJA,AzB2EA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AiCnGA,AOrBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AzB2EA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,ACHA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,AS3BA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,A/B6FA,Ac1CA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,AS3BA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,AjBmDA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AKfA,AGTA,ACHA,AHSA,AS3BA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,AjBmDA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AgBhDA,AXiCA,AGTA,ACHA,AHSA,AS3BA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,AjBmDA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AgBhDA,AXiCA,AGTA,ACHA,AHSA,AS3BA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AwBxEA,AjBmDA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AgBhDA,AXiCA,AGTA,ACHA,AHSA,AS3BA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,APqBA,AnByDA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,A3BiFA,AS3BA,AKfA,AgBhDA,AXiCA,AGTA,ACHA,AHSA,AS3BA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,AavCA,ApB4DA,AnByDA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AGTA,ACHA,AHSA,AS3BA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,AavCA,ApB4DA,AnByDA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AGTA,ACHA,AHSA,AS3BA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,A6BvFA,AlBsDA,AQxBA,AavCA,ApB4DA,AnByDA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AGTA,ACHA,AHSA,AYpCA,AHSA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AGTA,ACHA,AHSA,AYpCA,AHSA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AGTA,ACHA,AHSA,AYpCA,AHSA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AGTA,ACHA,AHSA,AavCA,ADGA,AHSA,ARwBA,A9C0IA,AwCxHA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AIZA,AHSA,AavCA,ADGA,AHSA,ARwBA,ANkBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AIZA,AHSA,AavCA,ADGA,AHSA,ARwBA,ANkBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,AuCrHA,AZoCA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AIZA,AHSA,AavCA,ACHA,AFMA,AHSA,ARwBA,ANkBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AIZA,AHSA,AavCA,ACHA,AFMA,AHSA,ARwBA,ANkBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,AOrBA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AIZA,AHSA,AavCA,ACHA,AFMA,AHSA,ARwBA,ANkBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,A8C1IA,AvCqHA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AIZA,AHSA,AavCA,ACHA,AFMA,AHSA,ARwBA,ANkBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,A8C1IA,AvCqHA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AIZA,AHSA,AavCA,ACHA,AFMA,AHSA,ARwBA,ANkBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,A8C1IA,AvCqHA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AIZA,AHSA,AavCA,ACHA,AFMA,AHSA,ARwBA,ANkBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,A8C1IA,ACHA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AHSA,ARwBA,ANkBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,A8C1IA,ACHA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AHSA,ARwBA,ANkBA,AWjCA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,A8C1IA,ACHA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AKfA,AgBhDA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AHSA,ARwBA,AKfA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA,APqBA;AELA,A8C1IA,AENA,ADGA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AKfA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA;ALgBA,A8C1IA,AENA,ADGA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AKfA,AT2BA,AlBsDA,AWjCA,AQxBA,AavCA,AvCqHA,AJYA,AMlBA;ALgBA,A8C1IA,AENA,ADGA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AKfA,AT2BA,AlBsDA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;ALgBA,A8C1IA,AENA,ACHA,AFMA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AiDnJA,AENA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AKfA,AT2BA,AlBsDA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;ALgBA,A8C1IA,AENA,ACHA,AFMA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AKfA,AT2BA,AlBsDA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,ACHA,AFMA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AKfA,A3BiFA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AFMA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AKfA,A3BiFA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AFMA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AKfA,A3BiFA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AFMA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AxCwHA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,A7CuIA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,A7CuIA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,A7CuIA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,ACHA,A9C0IA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,ACHA,A9C0IA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,ACHA,A9C0IA,ADGA,AV8BA,A2BjFA,ApC4GA,AmDzJA,AlBsDA,AqB/DA,AXiCA,AIZA,AU9BA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,A9C0IA,ADGA,AV8BA,A2BjFA,ApC4GA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,A9C0IA,ADGA,AV8BA,A2BjFA,ApC4GA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,A9C0IA,ADGA,AV8BA,A2BjFA,ApC4GA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,AENA,AhDgJA,ADGA,AV8BA,A2BjFA,ApC4GA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,AENA,AhDgJA,ADGA,AV8BA,A2BjFA,ApC4GA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,AENA,AhDgJA,ADGA,AV8BA,A2BjFA,ApC4GA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,AENA,ACHA,AjDmJA,ADGA,AV8BA,A2BjFA,ApC4GA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AqB/DA,AvCqHA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,AENA,ACHA,AlDsJA,AV8BA,A2BjFA,ApC4GA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,AENA,ACHA,AlDsJA,AV8BA,A2BjFA,ApC4GA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,AENA,ACHA,ACHA,AnDyJA,AV8BA,A2BjFA,ApC4GA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AJYA,AMlBA;AyC1HA,AENA,AENA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,AENA,ACHA,ACHA,AnDyJA,AV8BA,A2BjFA,ApC4GA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AJYA,AMlBA;AyC1HA,AIZA,ADGA,AENA,AJYA,AKfA,AENA,ADGA,AENA,ACHA,ACHA,AnDyJA,AV8BA,AT2BA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AJYA,AMlBA;AyC1HA,AIZA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AT2BA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AJYA,AMlBA;AyC1HA,AIZA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AT2BA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AJYA,AMlBA;AyC1HA,AIZA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AT2BA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AJYA,AMlBA;AyC1HA,AIZA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,A+D7LA,AxEwNA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,A+D7LA,AxEwNA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,A+D7LA,AxEwNA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AgEhMA,ADGA,AxEwNA,AiCnGA,AqB/DA,AXiCA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AgEhMA,ADGA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AgEhMA,ADGA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AgEhMA,ACHA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AgEhMA,ACHA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,AWjCA,AlBsDA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AgEhMA,ACHA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AXiCA,AtBkEA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ApD4JA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AKfA,AzD2KA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AKfA,AzD2KA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AKfA,AzD2KA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AzD2KA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AzD2KA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AzD2KA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AxEwNA,AiCnGA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA;AyC1HA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA,A8D1LA;ArBgEA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA,A8D1LA;ArBgEA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AFMA,AjCmGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,ACHA,AvBqEA,AIZA,ADGA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,ACHA,AvBqEA,AIZA,ADGA,AENA,ACHA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,ACHA,AvBqEA,AIZA,ADGA,AENA,ACHA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AENA,ACHA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AENA,ACHA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AENA,ACHA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AENA,ACHA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AENA,ACHA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AENA,ACHA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AENA,ACHA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AENA,ACHA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,AvCqHA,AU9BA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AIZA,ADGA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AMlBA,AJYA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,ACHA,AMlBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,AOrBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,AOrBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,AOrBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,AOrBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,AOrBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,AOrBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,AOrBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,AOrBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AENA,AOrBA,ADGA,AENA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AS3BA,ACHA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AS3BA,ACHA,A3DiLA,AV8BA,AgEhMA,AENA,ADGA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AS3BA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,ACHA,ACHA,AxBwEA,AGTA,AGTA,AGTA,AS3BA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AFMA,A7BuFA,Ac1CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,AENA,AxBwEA,AGTA,AGTA,AGTA,AS3BA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AFMA,Af6CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AIXA,AHSA,AENA,AxBwEA,AGTA,AGTA,AGTA,AS3BA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AFMA,Af6CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AENA,AxBwEA,AGTA,AGTA,AGTA,AS3BA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AFMA,Af6CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AENA,AxBwEA,AGTA,AGTA,AGTA,AS3BA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AFMA,Af6CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AENA,AxBwEA,AGTA,AGTA,AGTA,AS3BA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AFMA,Af6CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AENA,AxBwEA,AGTA,AGTA,AGTA,AS3BA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AFMA,Af6CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AENA,AxBwEA,AGTA,AGTA,AGTA,AS3BA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AFMA,Af6CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AENA,AxBwEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AFMA,Af6CA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AENA,AxBwEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,ACHA,A3DiLA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ACFA,AtBkEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ArBgEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;ArBgEA,AGTA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,AGTA,AYpCA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,ACHA,AjBmDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,AhBgDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,AhBgDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,AhBgDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,AhBgDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,AhBgDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,AhBgDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,AhBgDA,ACHA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,Af6CA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,Af6CA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,Af6CA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,Af6CA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,Af6CA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,Af6CA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,Af6CA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,Af6CA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AgEhMA,Af6CA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AiDnJA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AiDnJA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AiDnJA,AnCyGA,APqBA,AENA,A8D1LA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AiDnJA,AnCyGA,APqBA,AgEhMA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AiDnJA,AnCyGA,APqBA,AgEhMA;AlBuDA,Ae7CA,A1D8KA,AV8BA,AiDnJA,AnCyGA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,AiDnJA,AnCyGA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,AiDnJA,AnCyGA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,AiDnJA,AnCyGA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,AiDnJA,AnCyGA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,AiDnJA,AnCyGA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,Ae7CA,A1D8KA,AV8BA,Ac1CA,APqBA;A8CzIA,A3CiIA,AV8BA,Ac1CA,APqBA;A8CzIA,A3CiIA,AV8BA,Ac1CA,APqBA;A8CzIA,A3CiIA,AV8BA,Ac1CA,APqBA;A8CzIA,A3CiIA,AV8BA,Ac1CA,APqBA;A8CzIA,A3CiIA,AV8BA,Ac1CA,APqBA;A8CzIA,A3CiIA,AV8BA,Ac1CA,APqBA;A8CzIA,A3CiIA,AV8BA,Ac1CA,APqBA;A8CzIA,A3CiIA,AV8BA,Ac1CA,APqBA;A8CzIA,A3CiIA,AV8BA,Ac1CA,APqBA;A8CzIA,A3CiIA,AV8BA,Ac1CA,APqBA;A8CzIA,A3CiIA,AV8BA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA,APqBA;A8CzIA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;AuCpHA,ArD+JA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./lib/less-node').default;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar environment_1 = tslib_1.__importDefault(require(\"./environment\"));\nvar file_manager_1 = tslib_1.__importDefault(require(\"./file-manager\"));\nvar url_file_manager_1 = tslib_1.__importDefault(require(\"./url-file-manager\"));\nvar less_1 = tslib_1.__importDefault(require(\"../less\"));\nvar less = less_1.default(environment_1.default, [new file_manager_1.default(), new url_file_manager_1.default()]);\nvar lessc_helper_1 = tslib_1.__importDefault(require(\"./lessc-helper\"));\n// allow people to create less with their own environment\nless.createFromEnvironment = less_1.default;\nless.lesscHelper = lessc_helper_1.default;\nless.PluginLoader = require('./plugin-loader').default;\nless.fs = require('./fs').default;\nless.FileManager = file_manager_1.default;\nless.UrlFileManager = url_file_manager_1.default;\n// Set up options\nless.options = require('../less/default-options').default();\n// provide image-size functionality\nrequire('./image-size').default(less.environment);\nexports.default = less;\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = {\n    encodeBase64: function encodeBase64(str) {\n        // Avoid Buffer constructor on newer versions of Node.js.\n        var buffer = (Buffer.from ? Buffer.from(str) : (new Buffer(str)));\n        return buffer.toString('base64');\n    },\n    mimeLookup: function (filename) {\n        return require('mime').lookup(filename);\n    },\n    charsetLookup: function (mime) {\n        return require('mime').charsets.lookup(mime);\n    },\n    getSourceMapGenerator: function getSourceMapGenerator() {\n        return require('source-map').SourceMapGenerator;\n    }\n};\n//# sourceMappingURL=environment.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar path_1 = tslib_1.__importDefault(require(\"path\"));\nvar fs_1 = tslib_1.__importDefault(require(\"./fs\"));\nvar abstract_file_manager_js_1 = tslib_1.__importDefault(require(\"../less/environment/abstract-file-manager.js\"));\nvar FileManager = function () { };\nFileManager.prototype = Object.assign(new abstract_file_manager_js_1.default(), {\n    supports: function () {\n        return true;\n    },\n    supportsSync: function () {\n        return true;\n    },\n    loadFile: function (filename, currentDirectory, options, environment, callback) {\n        var fullFilename;\n        var isAbsoluteFilename = this.isPathAbsolute(filename);\n        var filenamesTried = [];\n        var self = this;\n        var prefix = filename.slice(0, 1);\n        var explicit = prefix === '.' || prefix === '/';\n        var result = null;\n        var isNodeModule = false;\n        var npmPrefix = 'npm://';\n        options = options || {};\n        var paths = isAbsoluteFilename ? [''] : [currentDirectory];\n        if (options.paths) {\n            paths.push.apply(paths, options.paths);\n        }\n        if (!isAbsoluteFilename && paths.indexOf('.') === -1) {\n            paths.push('.');\n        }\n        var prefixes = options.prefixes || [''];\n        var fileParts = this.extractUrlParts(filename);\n        if (options.syncImport) {\n            getFileData(returnData, returnData);\n            if (callback) {\n                callback(result.error, result);\n            }\n            else {\n                return result;\n            }\n        }\n        else {\n            // promise is guaranteed to be asyncronous\n            // which helps as it allows the file handle\n            // to be closed before it continues with the next file\n            return new Promise(getFileData);\n        }\n        function returnData(data) {\n            if (!data.filename) {\n                result = { error: data };\n            }\n            else {\n                result = data;\n            }\n        }\n        function getFileData(fulfill, reject) {\n            (function tryPathIndex(i) {\n                function tryWithExtension() {\n                    var extFilename = options.ext ? self.tryAppendExtension(fullFilename, options.ext) : fullFilename;\n                    if (extFilename !== fullFilename && !explicit && paths[i] === '.') {\n                        try {\n                            fullFilename = require.resolve(extFilename);\n                            isNodeModule = true;\n                        }\n                        catch (e) {\n                            filenamesTried.push(npmPrefix + extFilename);\n                            fullFilename = extFilename;\n                        }\n                    }\n                    else {\n                        fullFilename = extFilename;\n                    }\n                }\n                if (i < paths.length) {\n                    (function tryPrefix(j) {\n                        if (j < prefixes.length) {\n                            isNodeModule = false;\n                            fullFilename = fileParts.rawPath + prefixes[j] + fileParts.filename;\n                            if (paths[i]) {\n                                fullFilename = path_1.default.join(paths[i], fullFilename);\n                            }\n                            if (!explicit && paths[i] === '.') {\n                                try {\n                                    fullFilename = require.resolve(fullFilename);\n                                    isNodeModule = true;\n                                }\n                                catch (e) {\n                                    filenamesTried.push(npmPrefix + fullFilename);\n                                    tryWithExtension();\n                                }\n                            }\n                            else {\n                                tryWithExtension();\n                            }\n                            var readFileArgs = [fullFilename];\n                            if (!options.rawBuffer) {\n                                readFileArgs.push('utf-8');\n                            }\n                            if (options.syncImport) {\n                                try {\n                                    var data = fs_1.default.readFileSync.apply(this, readFileArgs);\n                                    fulfill({ contents: data, filename: fullFilename });\n                                }\n                                catch (e) {\n                                    filenamesTried.push(isNodeModule ? npmPrefix + fullFilename : fullFilename);\n                                    return tryPrefix(j + 1);\n                                }\n                            }\n                            else {\n                                readFileArgs.push(function (e, data) {\n                                    if (e) {\n                                        filenamesTried.push(isNodeModule ? npmPrefix + fullFilename : fullFilename);\n                                        return tryPrefix(j + 1);\n                                    }\n                                    fulfill({ contents: data, filename: fullFilename });\n                                });\n                                fs_1.default.readFile.apply(this, readFileArgs);\n                            }\n                        }\n                        else {\n                            tryPathIndex(i + 1);\n                        }\n                    })(0);\n                }\n                else {\n                    reject({ type: 'File', message: \"'\" + filename + \"' wasn't found. Tried - \" + filenamesTried.join(',') });\n                }\n            }(0));\n        }\n    },\n    loadFileSync: function (filename, currentDirectory, options, environment) {\n        options.syncImport = true;\n        return this.loadFile(filename, currentDirectory, options, environment);\n    }\n});\nexports.default = FileManager;\n//# sourceMappingURL=file-manager.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs;\ntry {\n    fs = require('graceful-fs');\n}\ncatch (e) {\n    fs = require('fs');\n}\nexports.default = fs;\n//# sourceMappingURL=fs.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractFileManager = /** @class */ (function () {\n    function AbstractFileManager() {\n    }\n    AbstractFileManager.prototype.getPath = function (filename) {\n        var j = filename.lastIndexOf('?');\n        if (j > 0) {\n            filename = filename.slice(0, j);\n        }\n        j = filename.lastIndexOf('/');\n        if (j < 0) {\n            j = filename.lastIndexOf('\\\\');\n        }\n        if (j < 0) {\n            return '';\n        }\n        return filename.slice(0, j + 1);\n    };\n    AbstractFileManager.prototype.tryAppendExtension = function (path, ext) {\n        return /(\\.[a-z]*$)|([?;].*)$/.test(path) ? path : path + ext;\n    };\n    AbstractFileManager.prototype.tryAppendLessExtension = function (path) {\n        return this.tryAppendExtension(path, '.less');\n    };\n    AbstractFileManager.prototype.supportsSync = function () {\n        return false;\n    };\n    AbstractFileManager.prototype.alwaysMakePathsAbsolute = function () {\n        return false;\n    };\n    AbstractFileManager.prototype.isPathAbsolute = function (filename) {\n        return (/^(?:[a-z-]+:|\\/|\\\\|#)/i).test(filename);\n    };\n    // TODO: pull out / replace?\n    AbstractFileManager.prototype.join = function (basePath, laterPath) {\n        if (!basePath) {\n            return laterPath;\n        }\n        return basePath + laterPath;\n    };\n    AbstractFileManager.prototype.pathDiff = function (url, baseUrl) {\n        // diff between two paths to create a relative path\n        var urlParts = this.extractUrlParts(url);\n        var baseUrlParts = this.extractUrlParts(baseUrl);\n        var i;\n        var max;\n        var urlDirectories;\n        var baseUrlDirectories;\n        var diff = '';\n        if (urlParts.hostPart !== baseUrlParts.hostPart) {\n            return '';\n        }\n        max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);\n        for (i = 0; i < max; i++) {\n            if (baseUrlParts.directories[i] !== urlParts.directories[i]) {\n                break;\n            }\n        }\n        baseUrlDirectories = baseUrlParts.directories.slice(i);\n        urlDirectories = urlParts.directories.slice(i);\n        for (i = 0; i < baseUrlDirectories.length - 1; i++) {\n            diff += '../';\n        }\n        for (i = 0; i < urlDirectories.length - 1; i++) {\n            diff += urlDirectories[i] + \"/\";\n        }\n        return diff;\n    };\n    /**\n     * Helper function, not part of API.\n     * This should be replaceable by newer Node / Browser APIs\n     *\n     * @param {string} url\n     * @param {string} baseUrl\n     */\n    AbstractFileManager.prototype.extractUrlParts = function (url, baseUrl) {\n        // urlParts[1] = protocol://hostname/ OR /\n        // urlParts[2] = / if path relative to host base\n        // urlParts[3] = directories\n        // urlParts[4] = filename\n        // urlParts[5] = parameters\n        var urlPartsRegex = /^((?:[a-z-]+:)?\\/{2}(?:[^/?#]*\\/)|([/\\\\]))?((?:[^/\\\\?#]*[/\\\\])*)([^/\\\\?#]*)([#?].*)?$/i;\n        var urlParts = url.match(urlPartsRegex);\n        var returner = {};\n        var rawDirectories = [];\n        var directories = [];\n        var i;\n        var baseUrlParts;\n        if (!urlParts) {\n            throw new Error(\"Could not parse sheet href - '\" + url + \"'\");\n        }\n        // Stylesheets in IE don't always return the full path\n        if (baseUrl && (!urlParts[1] || urlParts[2])) {\n            baseUrlParts = baseUrl.match(urlPartsRegex);\n            if (!baseUrlParts) {\n                throw new Error(\"Could not parse page url - '\" + baseUrl + \"'\");\n            }\n            urlParts[1] = urlParts[1] || baseUrlParts[1] || '';\n            if (!urlParts[2]) {\n                urlParts[3] = baseUrlParts[3] + urlParts[3];\n            }\n        }\n        if (urlParts[3]) {\n            rawDirectories = urlParts[3].replace(/\\\\/g, '/').split('/');\n            // collapse '..' and skip '.'\n            for (i = 0; i < rawDirectories.length; i++) {\n                if (rawDirectories[i] === '..') {\n                    directories.pop();\n                }\n                else if (rawDirectories[i] !== '.') {\n                    directories.push(rawDirectories[i]);\n                }\n            }\n        }\n        returner.hostPart = urlParts[1];\n        returner.directories = directories;\n        returner.rawPath = (urlParts[1] || '') + rawDirectories.join('/');\n        returner.path = (urlParts[1] || '') + directories.join('/');\n        returner.filename = urlParts[4];\n        returner.fileUrl = returner.path + (urlParts[4] || '');\n        returner.url = returner.fileUrl + (urlParts[5] || '');\n        return returner;\n    };\n    return AbstractFileManager;\n}());\nexports.default = AbstractFileManager;\n//# sourceMappingURL=abstract-file-manager.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/* eslint-disable no-unused-vars */\n/**\n * @todo - remove top eslint rule when FileManagers have JSDoc type\n * and are TS-type-checked\n */\nvar isUrlRe = /^(?:https?:)?\\/\\//i;\nvar url_1 = tslib_1.__importDefault(require(\"url\"));\nvar request;\nvar abstract_file_manager_js_1 = tslib_1.__importDefault(require(\"../less/environment/abstract-file-manager.js\"));\nvar logger_1 = tslib_1.__importDefault(require(\"../less/logger\"));\nvar UrlFileManager = function () { };\nUrlFileManager.prototype = Object.assign(new abstract_file_manager_js_1.default(), {\n    supports: function (filename, currentDirectory, options, environment) {\n        return isUrlRe.test(filename) || isUrlRe.test(currentDirectory);\n    },\n    loadFile: function (filename, currentDirectory, options, environment) {\n        return new Promise(function (fulfill, reject) {\n            if (request === undefined) {\n                try {\n                    request = require('needle');\n                }\n                catch (e) {\n                    request = null;\n                }\n            }\n            if (!request) {\n                reject({ type: 'File', message: 'optional dependency \\'needle\\' required to import over http(s)\\n' });\n                return;\n            }\n            var urlStr = isUrlRe.test(filename) ? filename : url_1.default.resolve(currentDirectory, filename);\n            /** native-request currently has a bug */\n            var hackUrlStr = urlStr.indexOf('?') === -1 ? urlStr + '?' : urlStr;\n            request.get(hackUrlStr, { follow_max: 5 }, function (err, resp, body) {\n                if (err || resp && resp.statusCode >= 400) {\n                    var message = resp && resp.statusCode === 404\n                        ? \"resource '\" + urlStr + \"' was not found\\n\"\n                        : \"resource '\" + urlStr + \"' gave this Error:\\n  \" + (err || resp.statusMessage || resp.statusCode) + \"\\n\";\n                    reject({ type: 'File', message: message });\n                    return;\n                }\n                if (resp.statusCode >= 300) {\n                    reject({ type: 'File', message: \"resource '\" + urlStr + \"' caused too many redirects\" });\n                    return;\n                }\n                body = body.toString('utf8');\n                if (!body) {\n                    logger_1.default.warn(\"Warning: Empty body (HTTP \" + resp.statusCode + \") returned by \\\"\" + urlStr + \"\\\"\");\n                }\n                fulfill({ contents: body || '', filename: urlStr });\n            });\n        });\n    }\n});\nexports.default = UrlFileManager;\n//# sourceMappingURL=url-file-manager.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = {\n    error: function (msg) {\n        this._fireEvent('error', msg);\n    },\n    warn: function (msg) {\n        this._fireEvent('warn', msg);\n    },\n    info: function (msg) {\n        this._fireEvent('info', msg);\n    },\n    debug: function (msg) {\n        this._fireEvent('debug', msg);\n    },\n    addListener: function (listener) {\n        this._listeners.push(listener);\n    },\n    removeListener: function (listener) {\n        for (var i = 0; i < this._listeners.length; i++) {\n            if (this._listeners[i] === listener) {\n                this._listeners.splice(i, 1);\n                return;\n            }\n        }\n    },\n    _fireEvent: function (type, msg) {\n        for (var i = 0; i < this._listeners.length; i++) {\n            var logFunction = this._listeners[i][type];\n            if (logFunction) {\n                logFunction(msg);\n            }\n        }\n    },\n    _listeners: []\n};\n//# sourceMappingURL=logger.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar environment_1 = tslib_1.__importDefault(require(\"./environment/environment\"));\nvar data_1 = tslib_1.__importDefault(require(\"./data\"));\nvar tree_1 = tslib_1.__importDefault(require(\"./tree\"));\nvar abstract_file_manager_1 = tslib_1.__importDefault(require(\"./environment/abstract-file-manager\"));\nvar abstract_plugin_loader_1 = tslib_1.__importDefault(require(\"./environment/abstract-plugin-loader\"));\nvar visitors_1 = tslib_1.__importDefault(require(\"./visitors\"));\nvar parser_1 = tslib_1.__importDefault(require(\"./parser/parser\"));\nvar functions_1 = tslib_1.__importDefault(require(\"./functions\"));\nvar contexts_1 = tslib_1.__importDefault(require(\"./contexts\"));\nvar less_error_1 = tslib_1.__importDefault(require(\"./less-error\"));\nvar transform_tree_1 = tslib_1.__importDefault(require(\"./transform-tree\"));\nvar utils = tslib_1.__importStar(require(\"./utils\"));\nvar plugin_manager_1 = tslib_1.__importDefault(require(\"./plugin-manager\"));\nvar logger_1 = tslib_1.__importDefault(require(\"./logger\"));\nvar source_map_output_1 = tslib_1.__importDefault(require(\"./source-map-output\"));\nvar source_map_builder_1 = tslib_1.__importDefault(require(\"./source-map-builder\"));\nvar parse_tree_1 = tslib_1.__importDefault(require(\"./parse-tree\"));\nvar import_manager_1 = tslib_1.__importDefault(require(\"./import-manager\"));\nvar parse_1 = tslib_1.__importDefault(require(\"./parse\"));\nvar render_1 = tslib_1.__importDefault(require(\"./render\"));\nvar package_json_1 = require(\"../../package.json\");\nvar parse_node_version_1 = tslib_1.__importDefault(require(\"parse-node-version\"));\nfunction default_1(environment, fileManagers) {\n    var sourceMapOutput, sourceMapBuilder, parseTree, importManager;\n    environment = new environment_1.default(environment, fileManagers);\n    sourceMapOutput = source_map_output_1.default(environment);\n    sourceMapBuilder = source_map_builder_1.default(sourceMapOutput, environment);\n    parseTree = parse_tree_1.default(sourceMapBuilder);\n    importManager = import_manager_1.default(environment);\n    var render = render_1.default(environment, parseTree, importManager);\n    var parse = parse_1.default(environment, parseTree, importManager);\n    var v = parse_node_version_1.default(\"v\" + package_json_1.version);\n    var initial = {\n        version: [v.major, v.minor, v.patch],\n        data: data_1.default,\n        tree: tree_1.default,\n        Environment: environment_1.default,\n        AbstractFileManager: abstract_file_manager_1.default,\n        AbstractPluginLoader: abstract_plugin_loader_1.default,\n        environment: environment,\n        visitors: visitors_1.default,\n        Parser: parser_1.default,\n        functions: functions_1.default(environment),\n        contexts: contexts_1.default,\n        SourceMapOutput: sourceMapOutput,\n        SourceMapBuilder: sourceMapBuilder,\n        ParseTree: parseTree,\n        ImportManager: importManager,\n        render: render,\n        parse: parse,\n        LessError: less_error_1.default,\n        transformTree: transform_tree_1.default,\n        utils: utils,\n        PluginManager: plugin_manager_1.default,\n        logger: logger_1.default\n    };\n    // Create a public API\n    var ctor = function (t) {\n        return function () {\n            var obj = Object.create(t.prototype);\n            t.apply(obj, Array.prototype.slice.call(arguments, 0));\n            return obj;\n        };\n    };\n    var t;\n    var api = Object.create(initial);\n    for (var n in initial.tree) {\n        /* eslint guard-for-in: 0 */\n        t = initial.tree[n];\n        if (typeof t === 'function') {\n            api[n.toLowerCase()] = ctor(t);\n        }\n        else {\n            api[n] = Object.create(null);\n            for (var o in t) {\n                /* eslint guard-for-in: 0 */\n                api[n][o.toLowerCase()] = ctor(t[o]);\n            }\n        }\n    }\n    /**\n     * Some of the functions assume a `this` context of the API object,\n     * which causes it to fail when wrapped for ES6 imports.\n     *\n     * An assumed `this` should be removed in the future.\n     */\n    initial.parse = initial.parse.bind(api);\n    initial.render = initial.render.bind(api);\n    return api;\n}\nexports.default = default_1;\n//# sourceMappingURL=index.js.map","\n/**\n * @todo Document why this abstraction exists, and the relationship between\n *       environment, file managers, and plugin manager\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar logger_1 = tslib_1.__importDefault(require(\"../logger\"));\nvar Environment = /** @class */ (function () {\n    function Environment(externalEnvironment, fileManagers) {\n        this.fileManagers = fileManagers || [];\n        externalEnvironment = externalEnvironment || {};\n        var optionalFunctions = ['encodeBase64', 'mimeLookup', 'charsetLookup', 'getSourceMapGenerator'];\n        var requiredFunctions = [];\n        var functions = requiredFunctions.concat(optionalFunctions);\n        for (var i = 0; i < functions.length; i++) {\n            var propName = functions[i];\n            var environmentFunc = externalEnvironment[propName];\n            if (environmentFunc) {\n                this[propName] = environmentFunc.bind(externalEnvironment);\n            }\n            else if (i < requiredFunctions.length) {\n                this.warn(\"missing required function in environment - \" + propName);\n            }\n        }\n    }\n    Environment.prototype.getFileManager = function (filename, currentDirectory, options, environment, isSync) {\n        if (!filename) {\n            logger_1.default.warn('getFileManager called with no filename.. Please report this issue. continuing.');\n        }\n        if (currentDirectory === undefined) {\n            logger_1.default.warn('getFileManager called with null directory.. Please report this issue. continuing.');\n        }\n        var fileManagers = this.fileManagers;\n        if (options.pluginManager) {\n            fileManagers = [].concat(fileManagers).concat(options.pluginManager.getFileManagers());\n        }\n        for (var i = fileManagers.length - 1; i >= 0; i--) {\n            var fileManager = fileManagers[i];\n            if (fileManager[isSync ? 'supportsSync' : 'supports'](filename, currentDirectory, options, environment)) {\n                return fileManager;\n            }\n        }\n        return null;\n    };\n    Environment.prototype.addFileManager = function (fileManager) {\n        this.fileManagers.push(fileManager);\n    };\n    Environment.prototype.clearFileManagers = function () {\n        this.fileManagers = [];\n    };\n    return Environment;\n}());\nexports.default = Environment;\n//# sourceMappingURL=environment.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar colors_1 = tslib_1.__importDefault(require(\"./colors\"));\nvar unit_conversions_1 = tslib_1.__importDefault(require(\"./unit-conversions\"));\nexports.default = { colors: colors_1.default, unitConversions: unit_conversions_1.default };\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = {\n    'aliceblue': '#f0f8ff',\n    'antiquewhite': '#faebd7',\n    'aqua': '#00ffff',\n    'aquamarine': '#7fffd4',\n    'azure': '#f0ffff',\n    'beige': '#f5f5dc',\n    'bisque': '#ffe4c4',\n    'black': '#000000',\n    'blanchedalmond': '#ffebcd',\n    'blue': '#0000ff',\n    'blueviolet': '#8a2be2',\n    'brown': '#a52a2a',\n    'burlywood': '#deb887',\n    'cadetblue': '#5f9ea0',\n    'chartreuse': '#7fff00',\n    'chocolate': '#d2691e',\n    'coral': '#ff7f50',\n    'cornflowerblue': '#6495ed',\n    'cornsilk': '#fff8dc',\n    'crimson': '#dc143c',\n    'cyan': '#00ffff',\n    'darkblue': '#00008b',\n    'darkcyan': '#008b8b',\n    'darkgoldenrod': '#b8860b',\n    'darkgray': '#a9a9a9',\n    'darkgrey': '#a9a9a9',\n    'darkgreen': '#006400',\n    'darkkhaki': '#bdb76b',\n    'darkmagenta': '#8b008b',\n    'darkolivegreen': '#556b2f',\n    'darkorange': '#ff8c00',\n    'darkorchid': '#9932cc',\n    'darkred': '#8b0000',\n    'darksalmon': '#e9967a',\n    'darkseagreen': '#8fbc8f',\n    'darkslateblue': '#483d8b',\n    'darkslategray': '#2f4f4f',\n    'darkslategrey': '#2f4f4f',\n    'darkturquoise': '#00ced1',\n    'darkviolet': '#9400d3',\n    'deeppink': '#ff1493',\n    'deepskyblue': '#00bfff',\n    'dimgray': '#696969',\n    'dimgrey': '#696969',\n    'dodgerblue': '#1e90ff',\n    'firebrick': '#b22222',\n    'floralwhite': '#fffaf0',\n    'forestgreen': '#228b22',\n    'fuchsia': '#ff00ff',\n    'gainsboro': '#dcdcdc',\n    'ghostwhite': '#f8f8ff',\n    'gold': '#ffd700',\n    'goldenrod': '#daa520',\n    'gray': '#808080',\n    'grey': '#808080',\n    'green': '#008000',\n    'greenyellow': '#adff2f',\n    'honeydew': '#f0fff0',\n    'hotpink': '#ff69b4',\n    'indianred': '#cd5c5c',\n    'indigo': '#4b0082',\n    'ivory': '#fffff0',\n    'khaki': '#f0e68c',\n    'lavender': '#e6e6fa',\n    'lavenderblush': '#fff0f5',\n    'lawngreen': '#7cfc00',\n    'lemonchiffon': '#fffacd',\n    'lightblue': '#add8e6',\n    'lightcoral': '#f08080',\n    'lightcyan': '#e0ffff',\n    'lightgoldenrodyellow': '#fafad2',\n    'lightgray': '#d3d3d3',\n    'lightgrey': '#d3d3d3',\n    'lightgreen': '#90ee90',\n    'lightpink': '#ffb6c1',\n    'lightsalmon': '#ffa07a',\n    'lightseagreen': '#20b2aa',\n    'lightskyblue': '#87cefa',\n    'lightslategray': '#778899',\n    'lightslategrey': '#778899',\n    'lightsteelblue': '#b0c4de',\n    'lightyellow': '#ffffe0',\n    'lime': '#00ff00',\n    'limegreen': '#32cd32',\n    'linen': '#faf0e6',\n    'magenta': '#ff00ff',\n    'maroon': '#800000',\n    'mediumaquamarine': '#66cdaa',\n    'mediumblue': '#0000cd',\n    'mediumorchid': '#ba55d3',\n    'mediumpurple': '#9370d8',\n    'mediumseagreen': '#3cb371',\n    'mediumslateblue': '#7b68ee',\n    'mediumspringgreen': '#00fa9a',\n    'mediumturquoise': '#48d1cc',\n    'mediumvioletred': '#c71585',\n    'midnightblue': '#191970',\n    'mintcream': '#f5fffa',\n    'mistyrose': '#ffe4e1',\n    'moccasin': '#ffe4b5',\n    'navajowhite': '#ffdead',\n    'navy': '#000080',\n    'oldlace': '#fdf5e6',\n    'olive': '#808000',\n    'olivedrab': '#6b8e23',\n    'orange': '#ffa500',\n    'orangered': '#ff4500',\n    'orchid': '#da70d6',\n    'palegoldenrod': '#eee8aa',\n    'palegreen': '#98fb98',\n    'paleturquoise': '#afeeee',\n    'palevioletred': '#d87093',\n    'papayawhip': '#ffefd5',\n    'peachpuff': '#ffdab9',\n    'peru': '#cd853f',\n    'pink': '#ffc0cb',\n    'plum': '#dda0dd',\n    'powderblue': '#b0e0e6',\n    'purple': '#800080',\n    'rebeccapurple': '#663399',\n    'red': '#ff0000',\n    'rosybrown': '#bc8f8f',\n    'royalblue': '#4169e1',\n    'saddlebrown': '#8b4513',\n    'salmon': '#fa8072',\n    'sandybrown': '#f4a460',\n    'seagreen': '#2e8b57',\n    'seashell': '#fff5ee',\n    'sienna': '#a0522d',\n    'silver': '#c0c0c0',\n    'skyblue': '#87ceeb',\n    'slateblue': '#6a5acd',\n    'slategray': '#708090',\n    'slategrey': '#708090',\n    'snow': '#fffafa',\n    'springgreen': '#00ff7f',\n    'steelblue': '#4682b4',\n    'tan': '#d2b48c',\n    'teal': '#008080',\n    'thistle': '#d8bfd8',\n    'tomato': '#ff6347',\n    'turquoise': '#40e0d0',\n    'violet': '#ee82ee',\n    'wheat': '#f5deb3',\n    'white': '#ffffff',\n    'whitesmoke': '#f5f5f5',\n    'yellow': '#ffff00',\n    'yellowgreen': '#9acd32'\n};\n//# sourceMappingURL=colors.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = {\n    length: {\n        'm': 1,\n        'cm': 0.01,\n        'mm': 0.001,\n        'in': 0.0254,\n        'px': 0.0254 / 96,\n        'pt': 0.0254 / 72,\n        'pc': 0.0254 / 72 * 12\n    },\n    duration: {\n        's': 1,\n        'ms': 0.001\n    },\n    angle: {\n        'rad': 1 / (2 * Math.PI),\n        'deg': 1 / 360,\n        'grad': 1 / 400,\n        'turn': 1\n    }\n};\n//# sourceMappingURL=unit-conversions.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar color_1 = tslib_1.__importDefault(require(\"./color\"));\nvar atrule_1 = tslib_1.__importDefault(require(\"./atrule\"));\nvar detached_ruleset_1 = tslib_1.__importDefault(require(\"./detached-ruleset\"));\nvar operation_1 = tslib_1.__importDefault(require(\"./operation\"));\nvar dimension_1 = tslib_1.__importDefault(require(\"./dimension\"));\nvar unit_1 = tslib_1.__importDefault(require(\"./unit\"));\nvar keyword_1 = tslib_1.__importDefault(require(\"./keyword\"));\nvar variable_1 = tslib_1.__importDefault(require(\"./variable\"));\nvar property_1 = tslib_1.__importDefault(require(\"./property\"));\nvar ruleset_1 = tslib_1.__importDefault(require(\"./ruleset\"));\nvar element_1 = tslib_1.__importDefault(require(\"./element\"));\nvar attribute_1 = tslib_1.__importDefault(require(\"./attribute\"));\nvar combinator_1 = tslib_1.__importDefault(require(\"./combinator\"));\nvar selector_1 = tslib_1.__importDefault(require(\"./selector\"));\nvar quoted_1 = tslib_1.__importDefault(require(\"./quoted\"));\nvar expression_1 = tslib_1.__importDefault(require(\"./expression\"));\nvar declaration_1 = tslib_1.__importDefault(require(\"./declaration\"));\nvar call_1 = tslib_1.__importDefault(require(\"./call\"));\nvar url_1 = tslib_1.__importDefault(require(\"./url\"));\nvar import_1 = tslib_1.__importDefault(require(\"./import\"));\nvar comment_1 = tslib_1.__importDefault(require(\"./comment\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"./anonymous\"));\nvar value_1 = tslib_1.__importDefault(require(\"./value\"));\nvar javascript_1 = tslib_1.__importDefault(require(\"./javascript\"));\nvar assignment_1 = tslib_1.__importDefault(require(\"./assignment\"));\nvar condition_1 = tslib_1.__importDefault(require(\"./condition\"));\nvar query_in_parens_1 = tslib_1.__importDefault(require(\"./query-in-parens\"));\nvar paren_1 = tslib_1.__importDefault(require(\"./paren\"));\nvar media_1 = tslib_1.__importDefault(require(\"./media\"));\nvar container_1 = tslib_1.__importDefault(require(\"./container\"));\nvar unicode_descriptor_1 = tslib_1.__importDefault(require(\"./unicode-descriptor\"));\nvar negative_1 = tslib_1.__importDefault(require(\"./negative\"));\nvar extend_1 = tslib_1.__importDefault(require(\"./extend\"));\nvar variable_call_1 = tslib_1.__importDefault(require(\"./variable-call\"));\nvar namespace_value_1 = tslib_1.__importDefault(require(\"./namespace-value\"));\n// mixins\nvar mixin_call_1 = tslib_1.__importDefault(require(\"./mixin-call\"));\nvar mixin_definition_1 = tslib_1.__importDefault(require(\"./mixin-definition\"));\nexports.default = {\n    Node: node_1.default,\n    Color: color_1.default,\n    AtRule: atrule_1.default,\n    DetachedRuleset: detached_ruleset_1.default,\n    Operation: operation_1.default,\n    Dimension: dimension_1.default,\n    Unit: unit_1.default,\n    Keyword: keyword_1.default,\n    Variable: variable_1.default,\n    Property: property_1.default,\n    Ruleset: ruleset_1.default,\n    Element: element_1.default,\n    Attribute: attribute_1.default,\n    Combinator: combinator_1.default,\n    Selector: selector_1.default,\n    Quoted: quoted_1.default,\n    Expression: expression_1.default,\n    Declaration: declaration_1.default,\n    Call: call_1.default,\n    URL: url_1.default,\n    Import: import_1.default,\n    Comment: comment_1.default,\n    Anonymous: anonymous_1.default,\n    Value: value_1.default,\n    JavaScript: javascript_1.default,\n    Assignment: assignment_1.default,\n    Condition: condition_1.default,\n    Paren: paren_1.default,\n    Media: media_1.default,\n    Container: container_1.default,\n    QueryInParens: query_in_parens_1.default,\n    UnicodeDescriptor: unicode_descriptor_1.default,\n    Negative: negative_1.default,\n    Extend: extend_1.default,\n    VariableCall: variable_call_1.default,\n    NamespaceValue: namespace_value_1.default,\n    mixin: {\n        Call: mixin_call_1.default,\n        Definition: mixin_definition_1.default\n    }\n};\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * The reason why Node is a class and other nodes simply do not extend\n * from Node (since we're transpiling) is due to this issue:\n *\n * @see https://github.com/less/less.js/issues/3434\n */\nvar Node = /** @class */ (function () {\n    function Node() {\n        this.parent = null;\n        this.visibilityBlocks = undefined;\n        this.nodeVisible = undefined;\n        this.rootNode = null;\n        this.parsed = null;\n    }\n    Object.defineProperty(Node.prototype, \"currentFileInfo\", {\n        get: function () {\n            return this.fileInfo();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"index\", {\n        get: function () {\n            return this.getIndex();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Node.prototype.setParent = function (nodes, parent) {\n        function set(node) {\n            if (node && node instanceof Node) {\n                node.parent = parent;\n            }\n        }\n        if (Array.isArray(nodes)) {\n            nodes.forEach(set);\n        }\n        else {\n            set(nodes);\n        }\n    };\n    Node.prototype.getIndex = function () {\n        return this._index || (this.parent && this.parent.getIndex()) || 0;\n    };\n    Node.prototype.fileInfo = function () {\n        return this._fileInfo || (this.parent && this.parent.fileInfo()) || {};\n    };\n    Node.prototype.isRulesetLike = function () { return false; };\n    Node.prototype.toCSS = function (context) {\n        var strs = [];\n        this.genCSS(context, {\n            // remove when genCSS has JSDoc types\n            // eslint-disable-next-line no-unused-vars\n            add: function (chunk, fileInfo, index) {\n                strs.push(chunk);\n            },\n            isEmpty: function () {\n                return strs.length === 0;\n            }\n        });\n        return strs.join('');\n    };\n    Node.prototype.genCSS = function (context, output) {\n        output.add(this.value);\n    };\n    Node.prototype.accept = function (visitor) {\n        this.value = visitor.visit(this.value);\n    };\n    Node.prototype.eval = function () { return this; };\n    Node.prototype._operate = function (context, op, a, b) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n            case '/': return a / b;\n        }\n    };\n    Node.prototype.fround = function (context, value) {\n        var precision = context && context.numPrecision;\n        // add \"epsilon\" to ensure numbers like 1.000000005 (represented as 1.000000004999...) are properly rounded:\n        return (precision) ? Number((value + 2e-16).toFixed(precision)) : value;\n    };\n    Node.compare = function (a, b) {\n        /* returns:\n         -1: a < b\n         0: a = b\n         1: a > b\n         and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */\n        if ((a.compare) &&\n            // for \"symmetric results\" force toCSS-based comparison\n            // of Quoted or Anonymous if either value is one of those\n            !(b.type === 'Quoted' || b.type === 'Anonymous')) {\n            return a.compare(b);\n        }\n        else if (b.compare) {\n            return -b.compare(a);\n        }\n        else if (a.type !== b.type) {\n            return undefined;\n        }\n        a = a.value;\n        b = b.value;\n        if (!Array.isArray(a)) {\n            return a === b ? 0 : undefined;\n        }\n        if (a.length !== b.length) {\n            return undefined;\n        }\n        for (var i = 0; i < a.length; i++) {\n            if (Node.compare(a[i], b[i]) !== 0) {\n                return undefined;\n            }\n        }\n        return 0;\n    };\n    Node.numericCompare = function (a, b) {\n        return a < b ? -1\n            : a === b ? 0\n                : a > b ? 1 : undefined;\n    };\n    // Returns true if this node represents root of ast imported by reference\n    Node.prototype.blocksVisibility = function () {\n        if (this.visibilityBlocks === undefined) {\n            this.visibilityBlocks = 0;\n        }\n        return this.visibilityBlocks !== 0;\n    };\n    Node.prototype.addVisibilityBlock = function () {\n        if (this.visibilityBlocks === undefined) {\n            this.visibilityBlocks = 0;\n        }\n        this.visibilityBlocks = this.visibilityBlocks + 1;\n    };\n    Node.prototype.removeVisibilityBlock = function () {\n        if (this.visibilityBlocks === undefined) {\n            this.visibilityBlocks = 0;\n        }\n        this.visibilityBlocks = this.visibilityBlocks - 1;\n    };\n    // Turns on node visibility - if called node will be shown in output regardless\n    // of whether it comes from import by reference or not\n    Node.prototype.ensureVisibility = function () {\n        this.nodeVisible = true;\n    };\n    // Turns off node visibility - if called node will NOT be shown in output regardless\n    // of whether it comes from import by reference or not\n    Node.prototype.ensureInvisibility = function () {\n        this.nodeVisible = false;\n    };\n    // return values:\n    // false - the node must not be visible\n    // true - the node must be visible\n    // undefined or null - the node has the same visibility as its parent\n    Node.prototype.isVisible = function () {\n        return this.nodeVisible;\n    };\n    Node.prototype.visibilityInfo = function () {\n        return {\n            visibilityBlocks: this.visibilityBlocks,\n            nodeVisible: this.nodeVisible\n        };\n    };\n    Node.prototype.copyVisibilityInfo = function (info) {\n        if (!info) {\n            return;\n        }\n        this.visibilityBlocks = info.visibilityBlocks;\n        this.nodeVisible = info.nodeVisible;\n    };\n    return Node;\n}());\nexports.default = Node;\n//# sourceMappingURL=node.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar colors_1 = tslib_1.__importDefault(require(\"../data/colors\"));\n//\n// RGB Colors - #ff0014, #eee\n//\nvar Color = function (rgb, a, originalForm) {\n    var self = this;\n    //\n    // The end goal here, is to parse the arguments\n    // into an integer triplet, such as `128, 255, 0`\n    //\n    // This facilitates operations and conversions.\n    //\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb;\n    }\n    else if (rgb.length >= 6) {\n        this.rgb = [];\n        rgb.match(/.{2}/g).map(function (c, i) {\n            if (i < 3) {\n                self.rgb.push(parseInt(c, 16));\n            }\n            else {\n                self.alpha = (parseInt(c, 16)) / 255;\n            }\n        });\n    }\n    else {\n        this.rgb = [];\n        rgb.split('').map(function (c, i) {\n            if (i < 3) {\n                self.rgb.push(parseInt(c + c, 16));\n            }\n            else {\n                self.alpha = (parseInt(c + c, 16)) / 255;\n            }\n        });\n    }\n    this.alpha = this.alpha || (typeof a === 'number' ? a : 1);\n    if (typeof originalForm !== 'undefined') {\n        this.value = originalForm;\n    }\n};\nColor.prototype = Object.assign(new node_1.default(), {\n    type: 'Color',\n    luma: function () {\n        var r = this.rgb[0] / 255, g = this.rgb[1] / 255, b = this.rgb[2] / 255;\n        r = (r <= 0.03928) ? r / 12.92 : Math.pow(((r + 0.055) / 1.055), 2.4);\n        g = (g <= 0.03928) ? g / 12.92 : Math.pow(((g + 0.055) / 1.055), 2.4);\n        b = (b <= 0.03928) ? b / 12.92 : Math.pow(((b + 0.055) / 1.055), 2.4);\n        return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    },\n    genCSS: function (context, output) {\n        output.add(this.toCSS(context));\n    },\n    toCSS: function (context, doNotCompress) {\n        var compress = context && context.compress && !doNotCompress;\n        var color;\n        var alpha;\n        var colorFunction;\n        var args = [];\n        // `value` is set if this color was originally\n        // converted from a named color string so we need\n        // to respect this and try to output named color too.\n        alpha = this.fround(context, this.alpha);\n        if (this.value) {\n            if (this.value.indexOf('rgb') === 0) {\n                if (alpha < 1) {\n                    colorFunction = 'rgba';\n                }\n            }\n            else if (this.value.indexOf('hsl') === 0) {\n                if (alpha < 1) {\n                    colorFunction = 'hsla';\n                }\n                else {\n                    colorFunction = 'hsl';\n                }\n            }\n            else {\n                return this.value;\n            }\n        }\n        else {\n            if (alpha < 1) {\n                colorFunction = 'rgba';\n            }\n        }\n        switch (colorFunction) {\n            case 'rgba':\n                args = this.rgb.map(function (c) {\n                    return clamp(Math.round(c), 255);\n                }).concat(clamp(alpha, 1));\n                break;\n            case 'hsla':\n                args.push(clamp(alpha, 1));\n            // eslint-disable-next-line no-fallthrough\n            case 'hsl':\n                color = this.toHSL();\n                args = [\n                    this.fround(context, color.h),\n                    this.fround(context, color.s * 100) + \"%\",\n                    this.fround(context, color.l * 100) + \"%\"\n                ].concat(args);\n        }\n        if (colorFunction) {\n            // Values are capped between `0` and `255`, rounded and zero-padded.\n            return colorFunction + \"(\" + args.join(\",\" + (compress ? '' : ' ')) + \")\";\n        }\n        color = this.toRGB();\n        if (compress) {\n            var splitcolor = color.split('');\n            // Convert color to short format\n            if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {\n                color = \"#\" + splitcolor[1] + splitcolor[3] + splitcolor[5];\n            }\n        }\n        return color;\n    },\n    //\n    // Operations have to be done per-channel, if not,\n    // channels will spill onto each other. Once we have\n    // our result, in the form of an integer triplet,\n    // we create a new Color node to hold the result.\n    //\n    operate: function (context, op, other) {\n        var rgb = new Array(3);\n        var alpha = this.alpha * (1 - other.alpha) + other.alpha;\n        for (var c = 0; c < 3; c++) {\n            rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c]);\n        }\n        return new Color(rgb, alpha);\n    },\n    toRGB: function () {\n        return toHex(this.rgb);\n    },\n    toHSL: function () {\n        var r = this.rgb[0] / 255, g = this.rgb[1] / 255, b = this.rgb[2] / 255, a = this.alpha;\n        var max = Math.max(r, g, b), min = Math.min(r, g, b);\n        var h;\n        var s;\n        var l = (max + min) / 2;\n        var d = max - min;\n        if (max === min) {\n            h = s = 0;\n        }\n        else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    },\n    // Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n    toHSV: function () {\n        var r = this.rgb[0] / 255, g = this.rgb[1] / 255, b = this.rgb[2] / 255, a = this.alpha;\n        var max = Math.max(r, g, b), min = Math.min(r, g, b);\n        var h;\n        var s;\n        var v = max;\n        var d = max - min;\n        if (max === 0) {\n            s = 0;\n        }\n        else {\n            s = d / max;\n        }\n        if (max === min) {\n            h = 0;\n        }\n        else {\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, v: v, a: a };\n    },\n    toARGB: function () {\n        return toHex([this.alpha * 255].concat(this.rgb));\n    },\n    compare: function (x) {\n        return (x.rgb &&\n            x.rgb[0] === this.rgb[0] &&\n            x.rgb[1] === this.rgb[1] &&\n            x.rgb[2] === this.rgb[2] &&\n            x.alpha === this.alpha) ? 0 : undefined;\n    }\n});\nColor.fromKeyword = function (keyword) {\n    var c;\n    var key = keyword.toLowerCase();\n    // eslint-disable-next-line no-prototype-builtins\n    if (colors_1.default.hasOwnProperty(key)) {\n        c = new Color(colors_1.default[key].slice(1));\n    }\n    else if (key === 'transparent') {\n        c = new Color([0, 0, 0], 0);\n    }\n    if (c) {\n        c.value = keyword;\n        return c;\n    }\n};\nfunction clamp(v, max) {\n    return Math.min(Math.max(v, 0), max);\n}\nfunction toHex(v) {\n    return \"#\" + v.map(function (c) {\n        c = clamp(Math.round(c), 255);\n        return (c < 16 ? '0' : '') + c.toString(16);\n    }).join('');\n}\nexports.default = Color;\n//# sourceMappingURL=color.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar selector_1 = tslib_1.__importDefault(require(\"./selector\"));\nvar ruleset_1 = tslib_1.__importDefault(require(\"./ruleset\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"./anonymous\"));\nvar AtRule = function (name, value, rules, index, currentFileInfo, debugInfo, isRooted, visibilityInfo) {\n    var i;\n    this.name = name;\n    this.value = (value instanceof node_1.default) ? value : (value ? new anonymous_1.default(value) : value);\n    if (rules) {\n        if (Array.isArray(rules)) {\n            this.rules = rules;\n        }\n        else {\n            this.rules = [rules];\n            this.rules[0].selectors = (new selector_1.default([], null, null, index, currentFileInfo)).createEmptySelectors();\n        }\n        for (i = 0; i < this.rules.length; i++) {\n            this.rules[i].allowImports = true;\n        }\n        this.setParent(this.rules, this);\n    }\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.debugInfo = debugInfo;\n    this.isRooted = isRooted || false;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n};\nAtRule.prototype = Object.assign(new node_1.default(), {\n    type: 'AtRule',\n    accept: function (visitor) {\n        var value = this.value, rules = this.rules;\n        if (rules) {\n            this.rules = visitor.visitArray(rules);\n        }\n        if (value) {\n            this.value = visitor.visit(value);\n        }\n    },\n    isRulesetLike: function () {\n        return this.rules || !this.isCharset();\n    },\n    isCharset: function () {\n        return '@charset' === this.name;\n    },\n    genCSS: function (context, output) {\n        var value = this.value, rules = this.rules;\n        output.add(this.name, this.fileInfo(), this.getIndex());\n        if (value) {\n            output.add(' ');\n            value.genCSS(context, output);\n        }\n        if (rules) {\n            this.outputRuleset(context, output, rules);\n        }\n        else {\n            output.add(';');\n        }\n    },\n    eval: function (context) {\n        var mediaPathBackup, mediaBlocksBackup, value = this.value, rules = this.rules;\n        // media stored inside other atrule should not bubble over it\n        // backpup media bubbling information\n        mediaPathBackup = context.mediaPath;\n        mediaBlocksBackup = context.mediaBlocks;\n        // deleted media bubbling information\n        context.mediaPath = [];\n        context.mediaBlocks = [];\n        if (value) {\n            value = value.eval(context);\n        }\n        if (rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            rules = [rules[0].eval(context)];\n            rules[0].root = true;\n        }\n        // restore media bubbling information\n        context.mediaPath = mediaPathBackup;\n        context.mediaBlocks = mediaBlocksBackup;\n        return new AtRule(this.name, value, rules, this.getIndex(), this.fileInfo(), this.debugInfo, this.isRooted, this.visibilityInfo());\n    },\n    variable: function (name) {\n        if (this.rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            return ruleset_1.default.prototype.variable.call(this.rules[0], name);\n        }\n    },\n    find: function () {\n        if (this.rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            return ruleset_1.default.prototype.find.apply(this.rules[0], arguments);\n        }\n    },\n    rulesets: function () {\n        if (this.rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            return ruleset_1.default.prototype.rulesets.apply(this.rules[0]);\n        }\n    },\n    outputRuleset: function (context, output, rules) {\n        var ruleCnt = rules.length;\n        var i;\n        context.tabLevel = (context.tabLevel | 0) + 1;\n        // Compressed\n        if (context.compress) {\n            output.add('{');\n            for (i = 0; i < ruleCnt; i++) {\n                rules[i].genCSS(context, output);\n            }\n            output.add('}');\n            context.tabLevel--;\n            return;\n        }\n        // Non-compressed\n        var tabSetStr = \"\\n\" + Array(context.tabLevel).join('  '), tabRuleStr = tabSetStr + \"  \";\n        if (!ruleCnt) {\n            output.add(\" {\" + tabSetStr + \"}\");\n        }\n        else {\n            output.add(\" {\" + tabRuleStr);\n            rules[0].genCSS(context, output);\n            for (i = 1; i < ruleCnt; i++) {\n                output.add(tabRuleStr);\n                rules[i].genCSS(context, output);\n            }\n            output.add(tabSetStr + \"}\");\n        }\n        context.tabLevel--;\n    }\n});\nexports.default = AtRule;\n//# sourceMappingURL=atrule.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar element_1 = tslib_1.__importDefault(require(\"./element\"));\nvar less_error_1 = tslib_1.__importDefault(require(\"../less-error\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\nvar parser_1 = tslib_1.__importDefault(require(\"../parser/parser\"));\nvar Selector = function (elements, extendList, condition, index, currentFileInfo, visibilityInfo) {\n    this.extendList = extendList;\n    this.condition = condition;\n    this.evaldCondition = !condition;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.elements = this.getElements(elements);\n    this.mixinElements_ = undefined;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.setParent(this.elements, this);\n};\nSelector.prototype = Object.assign(new node_1.default(), {\n    type: 'Selector',\n    accept: function (visitor) {\n        if (this.elements) {\n            this.elements = visitor.visitArray(this.elements);\n        }\n        if (this.extendList) {\n            this.extendList = visitor.visitArray(this.extendList);\n        }\n        if (this.condition) {\n            this.condition = visitor.visit(this.condition);\n        }\n    },\n    createDerived: function (elements, extendList, evaldCondition) {\n        elements = this.getElements(elements);\n        var newSelector = new Selector(elements, extendList || this.extendList, null, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n        newSelector.evaldCondition = (!utils.isNullOrUndefined(evaldCondition)) ? evaldCondition : this.evaldCondition;\n        newSelector.mediaEmpty = this.mediaEmpty;\n        return newSelector;\n    },\n    getElements: function (els) {\n        if (!els) {\n            return [new element_1.default('', '&', false, this._index, this._fileInfo)];\n        }\n        if (typeof els === 'string') {\n            new parser_1.default(this.parse.context, this.parse.importManager, this._fileInfo, this._index).parseNode(els, ['selector'], function (err, result) {\n                if (err) {\n                    throw new less_error_1.default({\n                        index: err.index,\n                        message: err.message\n                    }, this.parse.imports, this._fileInfo.filename);\n                }\n                els = result[0].elements;\n            });\n        }\n        return els;\n    },\n    createEmptySelectors: function () {\n        var el = new element_1.default('', '&', false, this._index, this._fileInfo), sels = [new Selector([el], null, null, this._index, this._fileInfo)];\n        sels[0].mediaEmpty = true;\n        return sels;\n    },\n    match: function (other) {\n        var elements = this.elements;\n        var len = elements.length;\n        var olen;\n        var i;\n        other = other.mixinElements();\n        olen = other.length;\n        if (olen === 0 || len < olen) {\n            return 0;\n        }\n        else {\n            for (i = 0; i < olen; i++) {\n                if (elements[i].value !== other[i]) {\n                    return 0;\n                }\n            }\n        }\n        return olen; // return number of matched elements\n    },\n    mixinElements: function () {\n        if (this.mixinElements_) {\n            return this.mixinElements_;\n        }\n        var elements = this.elements.map(function (v) {\n            return v.combinator.value + (v.value.value || v.value);\n        }).join('').match(/[,&#*.\\w-]([\\w-]|(\\\\.))*/g);\n        if (elements) {\n            if (elements[0] === '&') {\n                elements.shift();\n            }\n        }\n        else {\n            elements = [];\n        }\n        return (this.mixinElements_ = elements);\n    },\n    isJustParentSelector: function () {\n        return !this.mediaEmpty &&\n            this.elements.length === 1 &&\n            this.elements[0].value === '&' &&\n            (this.elements[0].combinator.value === ' ' || this.elements[0].combinator.value === '');\n    },\n    eval: function (context) {\n        var evaldCondition = this.condition && this.condition.eval(context);\n        var elements = this.elements;\n        var extendList = this.extendList;\n        elements = elements && elements.map(function (e) { return e.eval(context); });\n        extendList = extendList && extendList.map(function (extend) { return extend.eval(context); });\n        return this.createDerived(elements, extendList, evaldCondition);\n    },\n    genCSS: function (context, output) {\n        var i, element;\n        if ((!context || !context.firstSelector) && this.elements[0].combinator.value === '') {\n            output.add(' ', this.fileInfo(), this.getIndex());\n        }\n        for (i = 0; i < this.elements.length; i++) {\n            element = this.elements[i];\n            element.genCSS(context, output);\n        }\n    },\n    getIsOutput: function () {\n        return this.evaldCondition;\n    }\n});\nexports.default = Selector;\n//# sourceMappingURL=selector.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar paren_1 = tslib_1.__importDefault(require(\"./paren\"));\nvar combinator_1 = tslib_1.__importDefault(require(\"./combinator\"));\nvar Element = function (combinator, value, isVariable, index, currentFileInfo, visibilityInfo) {\n    this.combinator = combinator instanceof combinator_1.default ?\n        combinator : new combinator_1.default(combinator);\n    if (typeof value === 'string') {\n        this.value = value.trim();\n    }\n    else if (value) {\n        this.value = value;\n    }\n    else {\n        this.value = '';\n    }\n    this.isVariable = isVariable;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.setParent(this.combinator, this);\n};\nElement.prototype = Object.assign(new node_1.default(), {\n    type: 'Element',\n    accept: function (visitor) {\n        var value = this.value;\n        this.combinator = visitor.visit(this.combinator);\n        if (typeof value === 'object') {\n            this.value = visitor.visit(value);\n        }\n    },\n    eval: function (context) {\n        return new Element(this.combinator, this.value.eval ? this.value.eval(context) : this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n    },\n    clone: function () {\n        return new Element(this.combinator, this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n    },\n    genCSS: function (context, output) {\n        output.add(this.toCSS(context), this.fileInfo(), this.getIndex());\n    },\n    toCSS: function (context) {\n        context = context || {};\n        var value = this.value;\n        var firstSelector = context.firstSelector;\n        if (value instanceof paren_1.default) {\n            // selector in parens should not be affected by outer selector\n            // flags (breaks only interpolated selectors - see #1973)\n            context.firstSelector = true;\n        }\n        value = value.toCSS ? value.toCSS(context) : value;\n        context.firstSelector = firstSelector;\n        if (value === '' && this.combinator.value.charAt(0) === '&') {\n            return '';\n        }\n        else {\n            return this.combinator.toCSS(context) + value;\n        }\n    }\n});\nexports.default = Element;\n//# sourceMappingURL=element.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar Paren = function (node) {\n    this.value = node;\n};\nParen.prototype = Object.assign(new node_1.default(), {\n    type: 'Paren',\n    genCSS: function (context, output) {\n        output.add('(');\n        this.value.genCSS(context, output);\n        output.add(')');\n    },\n    eval: function (context) {\n        return new Paren(this.value.eval(context));\n    }\n});\nexports.default = Paren;\n//# sourceMappingURL=paren.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar _noSpaceCombinators = {\n    '': true,\n    ' ': true,\n    '|': true\n};\nvar Combinator = function (value) {\n    if (value === ' ') {\n        this.value = ' ';\n        this.emptyOrWhitespace = true;\n    }\n    else {\n        this.value = value ? value.trim() : '';\n        this.emptyOrWhitespace = this.value === '';\n    }\n};\nCombinator.prototype = Object.assign(new node_1.default(), {\n    type: 'Combinator',\n    genCSS: function (context, output) {\n        var spaceOrEmpty = (context.compress || _noSpaceCombinators[this.value]) ? '' : ' ';\n        output.add(spaceOrEmpty + this.value + spaceOrEmpty);\n    }\n});\nexports.default = Combinator;\n//# sourceMappingURL=combinator.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils = tslib_1.__importStar(require(\"./utils\"));\nvar anonymousFunc = /(<anonymous>|Function):(\\d+):(\\d+)/;\n/**\n * This is a centralized class of any error that could be thrown internally (mostly by the parser).\n * Besides standard .message it keeps some additional data like a path to the file where the error\n * occurred along with line and column numbers.\n *\n * @class\n * @extends Error\n * @type {module.LessError}\n *\n * @prop {string} type\n * @prop {string} filename\n * @prop {number} index\n * @prop {number} line\n * @prop {number} column\n * @prop {number} callLine\n * @prop {number} callExtract\n * @prop {string[]} extract\n *\n * @param {Object} e              - An error object to wrap around or just a descriptive object\n * @param {Object} fileContentMap - An object with file contents in 'contents' property (like importManager) @todo - move to fileManager?\n * @param {string} [currentFilename]\n */\nvar LessError = function (e, fileContentMap, currentFilename) {\n    Error.call(this);\n    var filename = e.filename || currentFilename;\n    this.message = e.message;\n    this.stack = e.stack;\n    if (fileContentMap && filename) {\n        var input = fileContentMap.contents[filename];\n        var loc = utils.getLocation(e.index, input);\n        var line = loc.line;\n        var col = loc.column;\n        var callLine = e.call && utils.getLocation(e.call, input).line;\n        var lines = input ? input.split('\\n') : '';\n        this.type = e.type || 'Syntax';\n        this.filename = filename;\n        this.index = e.index;\n        this.line = typeof line === 'number' ? line + 1 : null;\n        this.column = col;\n        if (!this.line && this.stack) {\n            var found = this.stack.match(anonymousFunc);\n            /**\n             * We have to figure out how this environment stringifies anonymous functions\n             * so we can correctly map plugin errors.\n             *\n             * Note, in Node 8, the output of anonymous funcs varied based on parameters\n             * being present or not, so we inject dummy params.\n             */\n            var func = new Function('a', 'throw new Error()');\n            var lineAdjust = 0;\n            try {\n                func();\n            }\n            catch (e) {\n                var match = e.stack.match(anonymousFunc);\n                lineAdjust = 1 - parseInt(match[2]);\n            }\n            if (found) {\n                if (found[2]) {\n                    this.line = parseInt(found[2]) + lineAdjust;\n                }\n                if (found[3]) {\n                    this.column = parseInt(found[3]);\n                }\n            }\n        }\n        this.callLine = callLine + 1;\n        this.callExtract = lines[callLine];\n        this.extract = [\n            lines[this.line - 2],\n            lines[this.line - 1],\n            lines[this.line]\n        ];\n    }\n};\nif (typeof Object.create === 'undefined') {\n    var F = function () { };\n    F.prototype = Error.prototype;\n    LessError.prototype = new F();\n}\nelse {\n    LessError.prototype = Object.create(Error.prototype);\n}\nLessError.prototype.constructor = LessError;\n/**\n * An overridden version of the default Object.prototype.toString\n * which uses additional information to create a helpful message.\n *\n * @param {Object} options\n * @returns {string}\n */\nLessError.prototype.toString = function (options) {\n    options = options || {};\n    var message = '';\n    var extract = this.extract || [];\n    var error = [];\n    var stylize = function (str) { return str; };\n    if (options.stylize) {\n        var type = typeof options.stylize;\n        if (type !== 'function') {\n            throw Error(\"options.stylize should be a function, got a \" + type + \"!\");\n        }\n        stylize = options.stylize;\n    }\n    if (this.line !== null) {\n        if (typeof extract[0] === 'string') {\n            error.push(stylize(this.line - 1 + \" \" + extract[0], 'grey'));\n        }\n        if (typeof extract[1] === 'string') {\n            var errorTxt = this.line + \" \";\n            if (extract[1]) {\n                errorTxt += extract[1].slice(0, this.column) +\n                    stylize(stylize(stylize(extract[1].substr(this.column, 1), 'bold') +\n                        extract[1].slice(this.column + 1), 'red'), 'inverse');\n            }\n            error.push(errorTxt);\n        }\n        if (typeof extract[2] === 'string') {\n            error.push(stylize(this.line + 1 + \" \" + extract[2], 'grey'));\n        }\n        error = error.join('\\n') + stylize('', 'reset') + \"\\n\";\n    }\n    message += stylize(this.type + \"Error: \" + this.message, 'red');\n    if (this.filename) {\n        message += stylize(' in ', 'red') + this.filename;\n    }\n    if (this.line) {\n        message += stylize(\" on line \" + this.line + \", column \" + (this.column + 1) + \":\", 'grey');\n    }\n    message += \"\\n\" + error;\n    if (this.callLine) {\n        message += stylize('from ', 'red') + (this.filename || '') + \"/n\";\n        message += stylize(this.callLine, 'grey') + \" \" + this.callExtract + \"/n\";\n    }\n    return message;\n};\nexports.default = LessError;\n//# sourceMappingURL=less-error.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isNullOrUndefined = exports.flattenArray = exports.merge = exports.copyOptions = exports.defaults = exports.clone = exports.copyArray = exports.getLocation = void 0;\nvar tslib_1 = require(\"tslib\");\n/* jshint proto: true */\nvar Constants = tslib_1.__importStar(require(\"./constants\"));\nvar copy_anything_1 = require(\"copy-anything\");\nfunction getLocation(index, inputStream) {\n    var n = index + 1;\n    var line = null;\n    var column = -1;\n    while (--n >= 0 && inputStream.charAt(n) !== '\\n') {\n        column++;\n    }\n    if (typeof index === 'number') {\n        line = (inputStream.slice(0, index).match(/\\n/g) || '').length;\n    }\n    return {\n        line: line,\n        column: column\n    };\n}\nexports.getLocation = getLocation;\nfunction copyArray(arr) {\n    var i;\n    var length = arr.length;\n    var copy = new Array(length);\n    for (i = 0; i < length; i++) {\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nexports.copyArray = copyArray;\nfunction clone(obj) {\n    var cloned = {};\n    for (var prop in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n            cloned[prop] = obj[prop];\n        }\n    }\n    return cloned;\n}\nexports.clone = clone;\nfunction defaults(obj1, obj2) {\n    var newObj = obj2 || {};\n    if (!obj2._defaults) {\n        newObj = {};\n        var defaults_1 = copy_anything_1.copy(obj1);\n        newObj._defaults = defaults_1;\n        var cloned = obj2 ? copy_anything_1.copy(obj2) : {};\n        Object.assign(newObj, defaults_1, cloned);\n    }\n    return newObj;\n}\nexports.defaults = defaults;\nfunction copyOptions(obj1, obj2) {\n    if (obj2 && obj2._defaults) {\n        return obj2;\n    }\n    var opts = defaults(obj1, obj2);\n    if (opts.strictMath) {\n        opts.math = Constants.Math.PARENS;\n    }\n    // Back compat with changed relativeUrls option\n    if (opts.relativeUrls) {\n        opts.rewriteUrls = Constants.RewriteUrls.ALL;\n    }\n    if (typeof opts.math === 'string') {\n        switch (opts.math.toLowerCase()) {\n            case 'always':\n                opts.math = Constants.Math.ALWAYS;\n                break;\n            case 'parens-division':\n                opts.math = Constants.Math.PARENS_DIVISION;\n                break;\n            case 'strict':\n            case 'parens':\n                opts.math = Constants.Math.PARENS;\n                break;\n            default:\n                opts.math = Constants.Math.PARENS;\n        }\n    }\n    if (typeof opts.rewriteUrls === 'string') {\n        switch (opts.rewriteUrls.toLowerCase()) {\n            case 'off':\n                opts.rewriteUrls = Constants.RewriteUrls.OFF;\n                break;\n            case 'local':\n                opts.rewriteUrls = Constants.RewriteUrls.LOCAL;\n                break;\n            case 'all':\n                opts.rewriteUrls = Constants.RewriteUrls.ALL;\n                break;\n        }\n    }\n    return opts;\n}\nexports.copyOptions = copyOptions;\nfunction merge(obj1, obj2) {\n    for (var prop in obj2) {\n        if (Object.prototype.hasOwnProperty.call(obj2, prop)) {\n            obj1[prop] = obj2[prop];\n        }\n    }\n    return obj1;\n}\nexports.merge = merge;\nfunction flattenArray(arr, result) {\n    if (result === void 0) { result = []; }\n    for (var i = 0, length_1 = arr.length; i < length_1; i++) {\n        var value = arr[i];\n        if (Array.isArray(value)) {\n            flattenArray(value, result);\n        }\n        else {\n            if (value !== undefined) {\n                result.push(value);\n            }\n        }\n    }\n    return result;\n}\nexports.flattenArray = flattenArray;\nfunction isNullOrUndefined(val) {\n    return val === null || val === undefined;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n//# sourceMappingURL=utils.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RewriteUrls = exports.Math = void 0;\nexports.Math = {\n    ALWAYS: 0,\n    PARENS_DIVISION: 1,\n    PARENS: 2\n    // removed - STRICT_LEGACY: 3\n};\nexports.RewriteUrls = {\n    OFF: 0,\n    LOCAL: 1,\n    ALL: 2\n};\n//# sourceMappingURL=constants.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar less_error_1 = tslib_1.__importDefault(require(\"../less-error\"));\nvar tree_1 = tslib_1.__importDefault(require(\"../tree\"));\nvar visitors_1 = tslib_1.__importDefault(require(\"../visitors\"));\nvar parser_input_1 = tslib_1.__importDefault(require(\"./parser-input\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\nvar function_registry_1 = tslib_1.__importDefault(require(\"../functions/function-registry\"));\nvar atrule_syntax_1 = require(\"../tree/atrule-syntax\");\n//\n// less.js - parser\n//\n//    A relatively straight-forward predictive parser.\n//    There is no tokenization/lexing stage, the input is parsed\n//    in one sweep.\n//\n//    To make the parser fast enough to run in the browser, several\n//    optimization had to be made:\n//\n//    - Matching and slicing on a huge input is often cause of slowdowns.\n//      The solution is to chunkify the input into smaller strings.\n//      The chunks are stored in the `chunks` var,\n//      `j` holds the current chunk index, and `currentPos` holds\n//      the index of the current chunk in relation to `input`.\n//      This gives us an almost 4x speed-up.\n//\n//    - In many cases, we don't need to match individual tokens;\n//      for example, if a value doesn't hold any variables, operations\n//      or dynamic references, the parser can effectively 'skip' it,\n//      treating it as a literal.\n//      An example would be '1px solid #000' - which evaluates to itself,\n//      we don't need to know what the individual components are.\n//      The drawback, of course is that you don't get the benefits of\n//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,\n//      and a smaller speed-up in the code-gen.\n//\n//\n//    Token matching is done with the `$` function, which either takes\n//    a terminal string or regexp, or a non-terminal function to call.\n//    It also takes care of moving all the indices forwards.\n//\nvar Parser = function Parser(context, imports, fileInfo, currentIndex) {\n    currentIndex = currentIndex || 0;\n    var parsers;\n    var parserInput = parser_input_1.default();\n    function error(msg, type) {\n        throw new less_error_1.default({\n            index: parserInput.i,\n            filename: fileInfo.filename,\n            type: type || 'Syntax',\n            message: msg\n        }, imports);\n    }\n    function expect(arg, msg) {\n        // some older browsers return typeof 'function' for RegExp\n        var result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);\n        if (result) {\n            return result;\n        }\n        error(msg || (typeof arg === 'string'\n            ? \"expected '\" + arg + \"' got '\" + parserInput.currentChar() + \"'\"\n            : 'unexpected token'));\n    }\n    // Specialization of expect()\n    function expectChar(arg, msg) {\n        if (parserInput.$char(arg)) {\n            return arg;\n        }\n        error(msg || \"expected '\" + arg + \"' got '\" + parserInput.currentChar() + \"'\");\n    }\n    function getDebugInfo(index) {\n        var filename = fileInfo.filename;\n        return {\n            lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,\n            fileName: filename\n        };\n    }\n    /**\n     *  Used after initial parsing to create nodes on the fly\n     *\n     *  @param {String} str          - string to parse\n     *  @param {Array}  parseList    - array of parsers to run input through e.g. [\"value\", \"important\"]\n     *  @param {Number} currentIndex - start number to begin indexing\n     *  @param {Object} fileInfo     - fileInfo to attach to created nodes\n     */\n    function parseNode(str, parseList, callback) {\n        var result;\n        var returnNodes = [];\n        var parser = parserInput;\n        try {\n            parser.start(str, false, function fail(msg, index) {\n                callback({\n                    message: msg,\n                    index: index + currentIndex\n                });\n            });\n            for (var x = 0, p = void 0; (p = parseList[x]); x++) {\n                result = parsers[p]();\n                returnNodes.push(result || null);\n            }\n            var endInfo = parser.end();\n            if (endInfo.isFinished) {\n                callback(null, returnNodes);\n            }\n            else {\n                callback(true, null);\n            }\n        }\n        catch (e) {\n            throw new less_error_1.default({\n                index: e.index + currentIndex,\n                message: e.message\n            }, imports, fileInfo.filename);\n        }\n    }\n    //\n    // The Parser\n    //\n    return {\n        parserInput: parserInput,\n        imports: imports,\n        fileInfo: fileInfo,\n        parseNode: parseNode,\n        //\n        // Parse an input string into an abstract syntax tree,\n        // @param str A string containing 'less' markup\n        // @param callback call `callback` when done.\n        // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply\n        //\n        parse: function (str, callback, additionalData) {\n            var root;\n            var err = null;\n            var globalVars;\n            var modifyVars;\n            var ignored;\n            var preText = '';\n            // Optionally disable @plugin parsing\n            if (additionalData && additionalData.disablePluginRule) {\n                parsers.plugin = function () {\n                    var dir = parserInput.$re(/^@plugin?\\s+/);\n                    if (dir) {\n                        error('@plugin statements are not allowed when disablePluginRule is set to true');\n                    }\n                };\n            }\n            globalVars = (additionalData && additionalData.globalVars) ? Parser.serializeVars(additionalData.globalVars) + \"\\n\" : '';\n            modifyVars = (additionalData && additionalData.modifyVars) ? \"\\n\" + Parser.serializeVars(additionalData.modifyVars) : '';\n            if (context.pluginManager) {\n                var preProcessors = context.pluginManager.getPreProcessors();\n                for (var i = 0; i < preProcessors.length; i++) {\n                    str = preProcessors[i].process(str, { context: context, imports: imports, fileInfo: fileInfo });\n                }\n            }\n            if (globalVars || (additionalData && additionalData.banner)) {\n                preText = ((additionalData && additionalData.banner) ? additionalData.banner : '') + globalVars;\n                ignored = imports.contentsIgnoredChars;\n                ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;\n                ignored[fileInfo.filename] += preText.length;\n            }\n            str = str.replace(/\\r\\n?/g, '\\n');\n            // Remove potential UTF Byte Order Mark\n            str = preText + str.replace(/^\\uFEFF/, '') + modifyVars;\n            imports.contents[fileInfo.filename] = str;\n            // Start with the primary rule.\n            // The whole syntax tree is held under a Ruleset node,\n            // with the `root` property set to true, so no `{}` are\n            // output. The callback is called when the input is parsed.\n            try {\n                parserInput.start(str, context.chunkInput, function fail(msg, index) {\n                    throw new less_error_1.default({\n                        index: index,\n                        type: 'Parse',\n                        message: msg,\n                        filename: fileInfo.filename\n                    }, imports);\n                });\n                tree_1.default.Node.prototype.parse = this;\n                root = new tree_1.default.Ruleset(null, this.parsers.primary());\n                tree_1.default.Node.prototype.rootNode = root;\n                root.root = true;\n                root.firstRoot = true;\n                root.functionRegistry = function_registry_1.default.inherit();\n            }\n            catch (e) {\n                return callback(new less_error_1.default(e, imports, fileInfo.filename));\n            }\n            // If `i` is smaller than the `input.length - 1`,\n            // it means the parser wasn't able to parse the whole\n            // string, so we've got a parsing error.\n            //\n            // We try to extract a \\n delimited string,\n            // showing the line where the parse error occurred.\n            // We split it up into two parts (the part which parsed,\n            // and the part which didn't), so we can color them differently.\n            var endInfo = parserInput.end();\n            if (!endInfo.isFinished) {\n                var message = endInfo.furthestPossibleErrorMessage;\n                if (!message) {\n                    message = 'Unrecognised input';\n                    if (endInfo.furthestChar === '}') {\n                        message += '. Possibly missing opening \\'{\\'';\n                    }\n                    else if (endInfo.furthestChar === ')') {\n                        message += '. Possibly missing opening \\'(\\'';\n                    }\n                    else if (endInfo.furthestReachedEnd) {\n                        message += '. Possibly missing something';\n                    }\n                }\n                err = new less_error_1.default({\n                    type: 'Parse',\n                    message: message,\n                    index: endInfo.furthest,\n                    filename: fileInfo.filename\n                }, imports);\n            }\n            var finish = function (e) {\n                e = err || e || imports.error;\n                if (e) {\n                    if (!(e instanceof less_error_1.default)) {\n                        e = new less_error_1.default(e, imports, fileInfo.filename);\n                    }\n                    return callback(e);\n                }\n                else {\n                    return callback(null, root);\n                }\n            };\n            if (context.processImports !== false) {\n                new visitors_1.default.ImportVisitor(imports, finish)\n                    .run(root);\n            }\n            else {\n                return finish();\n            }\n        },\n        //\n        // Here in, the parsing rules/functions\n        //\n        // The basic structure of the syntax tree generated is as follows:\n        //\n        //   Ruleset ->  Declaration -> Value -> Expression -> Entity\n        //\n        // Here's some Less code:\n        //\n        //    .class {\n        //      color: #fff;\n        //      border: 1px solid #000;\n        //      width: @w + 4px;\n        //      > .child {...}\n        //    }\n        //\n        // And here's what the parse tree might look like:\n        //\n        //     Ruleset (Selector '.class', [\n        //         Declaration (\"color\",  Value ([Expression [Color #fff]]))\n        //         Declaration (\"border\", Value ([Expression [Dimension 1px][Keyword \"solid\"][Color #000]]))\n        //         Declaration (\"width\",  Value ([Expression [Operation \" + \" [Variable \"@w\"][Dimension 4px]]]))\n        //         Ruleset (Selector [Element '>', '.child'], [...])\n        //     ])\n        //\n        //  In general, most rules will try to parse a token with the `$re()` function, and if the return\n        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check\n        //  first, before parsing, that's when we use `peek()`.\n        //\n        parsers: parsers = {\n            //\n            // The `primary` rule is the *entry* and *exit* point of the parser.\n            // The rules here can appear at any level of the parse tree.\n            //\n            // The recursive nature of the grammar is an interplay between the `block`\n            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,\n            // as represented by this simplified grammar:\n            //\n            //     primary  →  (ruleset | declaration)+\n            //     ruleset  →  selector+ block\n            //     block    →  '{' primary '}'\n            //\n            // Only at one point is the primary rule not called from the\n            // block rule: at the root level.\n            //\n            primary: function () {\n                var mixin = this.mixin;\n                var root = [];\n                var node;\n                while (true) {\n                    while (true) {\n                        node = this.comment();\n                        if (!node) {\n                            break;\n                        }\n                        root.push(node);\n                    }\n                    // always process comments before deciding if finished\n                    if (parserInput.finished) {\n                        break;\n                    }\n                    if (parserInput.peek('}')) {\n                        break;\n                    }\n                    node = this.extendRule();\n                    if (node) {\n                        root = root.concat(node);\n                        continue;\n                    }\n                    node = mixin.definition() || this.declaration() || mixin.call(false, false) ||\n                        this.ruleset() || this.variableCall() || this.entities.call() || this.atrule();\n                    if (node) {\n                        root.push(node);\n                    }\n                    else {\n                        var foundSemiColon = false;\n                        while (parserInput.$char(';')) {\n                            foundSemiColon = true;\n                        }\n                        if (!foundSemiColon) {\n                            break;\n                        }\n                    }\n                }\n                return root;\n            },\n            // comments are collected by the main parsing mechanism and then assigned to nodes\n            // where the current structure allows it\n            comment: function () {\n                if (parserInput.commentStore.length) {\n                    var comment = parserInput.commentStore.shift();\n                    return new (tree_1.default.Comment)(comment.text, comment.isLineComment, comment.index + currentIndex, fileInfo);\n                }\n            },\n            //\n            // Entities are tokens which can be found inside an Expression\n            //\n            entities: {\n                mixinLookup: function () {\n                    return parsers.mixin.call(true, true);\n                },\n                //\n                // A string, which supports escaping \" and '\n                //\n                //     \"milky way\" 'he\\'s the one!'\n                //\n                quoted: function (forceEscaped) {\n                    var str;\n                    var index = parserInput.i;\n                    var isEscaped = false;\n                    parserInput.save();\n                    if (parserInput.$char('~')) {\n                        isEscaped = true;\n                    }\n                    else if (forceEscaped) {\n                        parserInput.restore();\n                        return;\n                    }\n                    str = parserInput.$quoted();\n                    if (!str) {\n                        parserInput.restore();\n                        return;\n                    }\n                    parserInput.forget();\n                    return new (tree_1.default.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index + currentIndex, fileInfo);\n                },\n                //\n                // A catch-all word, such as:\n                //\n                //     black border-collapse\n                //\n                keyword: function () {\n                    var k = parserInput.$char('%') || parserInput.$re(/^\\[?(?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\\]?/);\n                    if (k) {\n                        return tree_1.default.Color.fromKeyword(k) || new (tree_1.default.Keyword)(k);\n                    }\n                },\n                //\n                // A function call\n                //\n                //     rgb(255, 0, 255)\n                //\n                // The arguments are parsed with the `entities.arguments` parser.\n                //\n                call: function () {\n                    var name;\n                    var args;\n                    var func;\n                    var index = parserInput.i;\n                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                    if (parserInput.peek(/^url\\(/i)) {\n                        return;\n                    }\n                    parserInput.save();\n                    name = parserInput.$re(/^([\\w-]+|%|~|progid:[\\w.]+)\\(/);\n                    if (!name) {\n                        parserInput.forget();\n                        return;\n                    }\n                    name = name[1];\n                    func = this.customFuncCall(name);\n                    if (func) {\n                        args = func.parse();\n                        if (args && func.stop) {\n                            parserInput.forget();\n                            return args;\n                        }\n                    }\n                    args = this.arguments(args);\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore('Could not parse call arguments or missing \\')\\'');\n                        return;\n                    }\n                    parserInput.forget();\n                    return new (tree_1.default.Call)(name, args, index + currentIndex, fileInfo);\n                },\n                //\n                // Parsing rules for functions with non-standard args, e.g.:\n                //\n                //     boolean(not(2 > 1))\n                //\n                //     This is a quick prototype, to be modified/improved when\n                //     more custom-parsed funcs come (e.g. `selector(...)`)\n                //\n                customFuncCall: function (name) {\n                    /* Ideally the table is to be moved out of here for faster perf.,\n                       but it's quite tricky since it relies on all these `parsers`\n                       and `expect` available only here */\n                    return {\n                        alpha: f(parsers.ieAlpha, true),\n                        boolean: f(condition),\n                        'if': f(condition)\n                    }[name.toLowerCase()];\n                    function f(parse, stop) {\n                        return {\n                            parse: parse,\n                            stop: stop // when true - stop after parse() and return its result,\n                            // otherwise continue for plain args\n                        };\n                    }\n                    function condition() {\n                        return [expect(parsers.condition, 'expected condition')];\n                    }\n                },\n                arguments: function (prevArgs) {\n                    var argsComma = prevArgs || [];\n                    var argsSemiColon = [];\n                    var isSemiColonSeparated;\n                    var value;\n                    parserInput.save();\n                    while (true) {\n                        if (prevArgs) {\n                            prevArgs = false;\n                        }\n                        else {\n                            value = parsers.detachedRuleset() || this.assignment() || parsers.expression();\n                            if (!value) {\n                                break;\n                            }\n                            if (value.value && value.value.length == 1) {\n                                value = value.value[0];\n                            }\n                            argsComma.push(value);\n                        }\n                        if (parserInput.$char(',')) {\n                            continue;\n                        }\n                        if (parserInput.$char(';') || isSemiColonSeparated) {\n                            isSemiColonSeparated = true;\n                            value = (argsComma.length < 1) ? argsComma[0]\n                                : new tree_1.default.Value(argsComma);\n                            argsSemiColon.push(value);\n                            argsComma = [];\n                        }\n                    }\n                    parserInput.forget();\n                    return isSemiColonSeparated ? argsSemiColon : argsComma;\n                },\n                literal: function () {\n                    return this.dimension() ||\n                        this.color() ||\n                        this.quoted() ||\n                        this.unicodeDescriptor();\n                },\n                // Assignments are argument entities for calls.\n                // They are present in ie filter properties as shown below.\n                //\n                //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )\n                //\n                assignment: function () {\n                    var key;\n                    var value;\n                    parserInput.save();\n                    key = parserInput.$re(/^\\w+(?=\\s?=)/i);\n                    if (!key) {\n                        parserInput.restore();\n                        return;\n                    }\n                    if (!parserInput.$char('=')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    value = parsers.entity();\n                    if (value) {\n                        parserInput.forget();\n                        return new (tree_1.default.Assignment)(key, value);\n                    }\n                    else {\n                        parserInput.restore();\n                    }\n                },\n                //\n                // Parse url() tokens\n                //\n                // We use a specific rule for urls, because they don't really behave like\n                // standard function calls. The difference is that the argument doesn't have\n                // to be enclosed within a string, so it can't be parsed as an Expression.\n                //\n                url: function () {\n                    var value;\n                    var index = parserInput.i;\n                    parserInput.autoCommentAbsorb = false;\n                    if (!parserInput.$str('url(')) {\n                        parserInput.autoCommentAbsorb = true;\n                        return;\n                    }\n                    value = this.quoted() || this.variable() || this.property() ||\n                        parserInput.$re(/^(?:(?:\\\\[()'\"])|[^()'\"])+/) || '';\n                    parserInput.autoCommentAbsorb = true;\n                    expectChar(')');\n                    return new (tree_1.default.URL)((value.value !== undefined ||\n                        value instanceof tree_1.default.Variable ||\n                        value instanceof tree_1.default.Property) ?\n                        value : new (tree_1.default.Anonymous)(value, index), index + currentIndex, fileInfo);\n                },\n                //\n                // A Variable entity, such as `@fink`, in\n                //\n                //     width: @fink + 2px\n                //\n                // We use a different parser for variable definitions,\n                // see `parsers.variable`.\n                //\n                variable: function () {\n                    var ch;\n                    var name;\n                    var index = parserInput.i;\n                    parserInput.save();\n                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\\w-]+/))) {\n                        ch = parserInput.currentChar();\n                        if (ch === '(' || ch === '[' && !parserInput.prevChar().match(/^\\s/)) {\n                            // this may be a VariableCall lookup\n                            var result = parsers.variableCall(name);\n                            if (result) {\n                                parserInput.forget();\n                                return result;\n                            }\n                        }\n                        parserInput.forget();\n                        return new (tree_1.default.Variable)(name, index + currentIndex, fileInfo);\n                    }\n                    parserInput.restore();\n                },\n                // A variable entity using the protective {} e.g. @{var}\n                variableCurly: function () {\n                    var curly;\n                    var index = parserInput.i;\n                    if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\\{([\\w-]+)\\}/))) {\n                        return new (tree_1.default.Variable)(\"@\" + curly[1], index + currentIndex, fileInfo);\n                    }\n                },\n                //\n                // A Property accessor, such as `$color`, in\n                //\n                //     background-color: $color\n                //\n                property: function () {\n                    var name;\n                    var index = parserInput.i;\n                    if (parserInput.currentChar() === '$' && (name = parserInput.$re(/^\\$[\\w-]+/))) {\n                        return new (tree_1.default.Property)(name, index + currentIndex, fileInfo);\n                    }\n                },\n                // A property entity useing the protective {} e.g. ${prop}\n                propertyCurly: function () {\n                    var curly;\n                    var index = parserInput.i;\n                    if (parserInput.currentChar() === '$' && (curly = parserInput.$re(/^\\$\\{([\\w-]+)\\}/))) {\n                        return new (tree_1.default.Property)(\"$\" + curly[1], index + currentIndex, fileInfo);\n                    }\n                },\n                //\n                // A Hexadecimal color\n                //\n                //     #4F3C2F\n                //\n                // `rgb` and `hsl` colors are parsed through the `entities.call` parser.\n                //\n                color: function () {\n                    var rgb;\n                    parserInput.save();\n                    if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})([\\w.#[])?/))) {\n                        if (!rgb[2]) {\n                            parserInput.forget();\n                            return new (tree_1.default.Color)(rgb[1], undefined, rgb[0]);\n                        }\n                    }\n                    parserInput.restore();\n                },\n                colorKeyword: function () {\n                    parserInput.save();\n                    var autoCommentAbsorb = parserInput.autoCommentAbsorb;\n                    parserInput.autoCommentAbsorb = false;\n                    var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);\n                    parserInput.autoCommentAbsorb = autoCommentAbsorb;\n                    if (!k) {\n                        parserInput.forget();\n                        return;\n                    }\n                    parserInput.restore();\n                    var color = tree_1.default.Color.fromKeyword(k);\n                    if (color) {\n                        parserInput.$str(k);\n                        return color;\n                    }\n                },\n                //\n                // A Dimension, that is, a number and a unit\n                //\n                //     0.5em 95%\n                //\n                dimension: function () {\n                    if (parserInput.peekNotNumeric()) {\n                        return;\n                    }\n                    var value = parserInput.$re(/^([+-]?\\d*\\.?\\d+)(%|[a-z_]+)?/i);\n                    if (value) {\n                        return new (tree_1.default.Dimension)(value[1], value[2]);\n                    }\n                },\n                //\n                // A unicode descriptor, as is used in unicode-range\n                //\n                // U+0??  or U+00A1-00A9\n                //\n                unicodeDescriptor: function () {\n                    var ud;\n                    ud = parserInput.$re(/^U\\+[0-9a-fA-F?]+(-[0-9a-fA-F?]+)?/);\n                    if (ud) {\n                        return new (tree_1.default.UnicodeDescriptor)(ud[0]);\n                    }\n                },\n                //\n                // JavaScript code to be evaluated\n                //\n                //     `window.location.href`\n                //\n                javascript: function () {\n                    var js;\n                    var index = parserInput.i;\n                    parserInput.save();\n                    var escape = parserInput.$char('~');\n                    var jsQuote = parserInput.$char('`');\n                    if (!jsQuote) {\n                        parserInput.restore();\n                        return;\n                    }\n                    js = parserInput.$re(/^[^`]*`/);\n                    if (js) {\n                        parserInput.forget();\n                        return new (tree_1.default.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index + currentIndex, fileInfo);\n                    }\n                    parserInput.restore('invalid javascript definition');\n                }\n            },\n            //\n            // The variable part of a variable definition. Used in the `rule` parser\n            //\n            //     @fink:\n            //\n            variable: function () {\n                var name;\n                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\\w-]+)\\s*:/))) {\n                    return name[1];\n                }\n            },\n            //\n            // Call a variable value to retrieve a detached ruleset\n            // or a value from a detached ruleset's rules.\n            //\n            //     @fink();\n            //     @fink;\n            //     color: @fink[@color];\n            //\n            variableCall: function (parsedName) {\n                var lookups;\n                var i = parserInput.i;\n                var inValue = !!parsedName;\n                var name = parsedName;\n                parserInput.save();\n                if (name || (parserInput.currentChar() === '@'\n                    && (name = parserInput.$re(/^(@[\\w-]+)(\\(\\s*\\))?/)))) {\n                    lookups = this.mixin.ruleLookups();\n                    if (!lookups && ((inValue && parserInput.$str('()') !== '()') || (name[2] !== '()'))) {\n                        parserInput.restore('Missing \\'[...]\\' lookup in variable call');\n                        return;\n                    }\n                    if (!inValue) {\n                        name = name[1];\n                    }\n                    var call = new tree_1.default.VariableCall(name, i, fileInfo);\n                    if (!inValue && parsers.end()) {\n                        parserInput.forget();\n                        return call;\n                    }\n                    else {\n                        parserInput.forget();\n                        return new tree_1.default.NamespaceValue(call, lookups, i, fileInfo);\n                    }\n                }\n                parserInput.restore();\n            },\n            //\n            // extend syntax - used to extend selectors\n            //\n            extend: function (isRule) {\n                var elements;\n                var e;\n                var index = parserInput.i;\n                var option;\n                var extendList;\n                var extend;\n                if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {\n                    return;\n                }\n                do {\n                    option = null;\n                    elements = null;\n                    while (!(option = parserInput.$re(/^(all)(?=\\s*(\\)|,))/))) {\n                        e = this.element();\n                        if (!e) {\n                            break;\n                        }\n                        if (elements) {\n                            elements.push(e);\n                        }\n                        else {\n                            elements = [e];\n                        }\n                    }\n                    option = option && option[1];\n                    if (!elements) {\n                        error('Missing target selector for :extend().');\n                    }\n                    extend = new (tree_1.default.Extend)(new (tree_1.default.Selector)(elements), option, index + currentIndex, fileInfo);\n                    if (extendList) {\n                        extendList.push(extend);\n                    }\n                    else {\n                        extendList = [extend];\n                    }\n                } while (parserInput.$char(','));\n                expect(/^\\)/);\n                if (isRule) {\n                    expect(/^;/);\n                }\n                return extendList;\n            },\n            //\n            // extendRule - used in a rule to extend all the parent selectors\n            //\n            extendRule: function () {\n                return this.extend(true);\n            },\n            //\n            // Mixins\n            //\n            mixin: {\n                //\n                // A Mixin call, with an optional argument list\n                //\n                //     #mixins > .square(#fff);\n                //     #mixins.square(#fff);\n                //     .rounded(4px, black);\n                //     .button;\n                //\n                // We can lookup / return a value using the lookup syntax:\n                //\n                //     color: #mixin.square(#fff)[@color];\n                //\n                // The `while` loop is there because mixins can be\n                // namespaced, but we only support the child and descendant\n                // selector for now.\n                //\n                call: function (inValue, getLookup) {\n                    var s = parserInput.currentChar();\n                    var important = false;\n                    var lookups;\n                    var index = parserInput.i;\n                    var elements;\n                    var args;\n                    var hasParens;\n                    if (s !== '.' && s !== '#') {\n                        return;\n                    }\n                    parserInput.save(); // stop us absorbing part of an invalid selector\n                    elements = this.elements();\n                    if (elements) {\n                        if (parserInput.$char('(')) {\n                            args = this.args(true).args;\n                            expectChar(')');\n                            hasParens = true;\n                        }\n                        if (getLookup !== false) {\n                            lookups = this.ruleLookups();\n                        }\n                        if (getLookup === true && !lookups) {\n                            parserInput.restore();\n                            return;\n                        }\n                        if (inValue && !lookups && !hasParens) {\n                            // This isn't a valid in-value mixin call\n                            parserInput.restore();\n                            return;\n                        }\n                        if (!inValue && parsers.important()) {\n                            important = true;\n                        }\n                        if (inValue || parsers.end()) {\n                            parserInput.forget();\n                            var mixin = new (tree_1.default.mixin.Call)(elements, args, index + currentIndex, fileInfo, !lookups && important);\n                            if (lookups) {\n                                return new tree_1.default.NamespaceValue(mixin, lookups);\n                            }\n                            else {\n                                return mixin;\n                            }\n                        }\n                    }\n                    parserInput.restore();\n                },\n                /**\n                 * Matching elements for mixins\n                 * (Start with . or # and can have > )\n                 */\n                elements: function () {\n                    var elements;\n                    var e;\n                    var c;\n                    var elem;\n                    var elemIndex;\n                    var re = /^[#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;\n                    while (true) {\n                        elemIndex = parserInput.i;\n                        e = parserInput.$re(re);\n                        if (!e) {\n                            break;\n                        }\n                        elem = new (tree_1.default.Element)(c, e, false, elemIndex + currentIndex, fileInfo);\n                        if (elements) {\n                            elements.push(elem);\n                        }\n                        else {\n                            elements = [elem];\n                        }\n                        c = parserInput.$char('>');\n                    }\n                    return elements;\n                },\n                args: function (isCall) {\n                    var entities = parsers.entities;\n                    var returner = { args: null, variadic: false };\n                    var expressions = [];\n                    var argsSemiColon = [];\n                    var argsComma = [];\n                    var isSemiColonSeparated;\n                    var expressionContainsNamed;\n                    var name;\n                    var nameLoop;\n                    var value;\n                    var arg;\n                    var expand;\n                    var hasSep = true;\n                    parserInput.save();\n                    while (true) {\n                        if (isCall) {\n                            arg = parsers.detachedRuleset() || parsers.expression();\n                        }\n                        else {\n                            parserInput.commentStore.length = 0;\n                            if (parserInput.$str('...')) {\n                                returner.variadic = true;\n                                if (parserInput.$char(';') && !isSemiColonSeparated) {\n                                    isSemiColonSeparated = true;\n                                }\n                                (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                    .push({ variadic: true });\n                                break;\n                            }\n                            arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);\n                        }\n                        if (!arg || !hasSep) {\n                            break;\n                        }\n                        nameLoop = null;\n                        if (arg.throwAwayComments) {\n                            arg.throwAwayComments();\n                        }\n                        value = arg;\n                        var val = null;\n                        if (isCall) {\n                            // Variable\n                            if (arg.value && arg.value.length == 1) {\n                                val = arg.value[0];\n                            }\n                        }\n                        else {\n                            val = arg;\n                        }\n                        if (val && (val instanceof tree_1.default.Variable || val instanceof tree_1.default.Property)) {\n                            if (parserInput.$char(':')) {\n                                if (expressions.length > 0) {\n                                    if (isSemiColonSeparated) {\n                                        error('Cannot mix ; and , as delimiter types');\n                                    }\n                                    expressionContainsNamed = true;\n                                }\n                                value = parsers.detachedRuleset() || parsers.expression();\n                                if (!value) {\n                                    if (isCall) {\n                                        error('could not understand value for named argument');\n                                    }\n                                    else {\n                                        parserInput.restore();\n                                        returner.args = [];\n                                        return returner;\n                                    }\n                                }\n                                nameLoop = (name = val.name);\n                            }\n                            else if (parserInput.$str('...')) {\n                                if (!isCall) {\n                                    returner.variadic = true;\n                                    if (parserInput.$char(';') && !isSemiColonSeparated) {\n                                        isSemiColonSeparated = true;\n                                    }\n                                    (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                        .push({ name: arg.name, variadic: true });\n                                    break;\n                                }\n                                else {\n                                    expand = true;\n                                }\n                            }\n                            else if (!isCall) {\n                                name = nameLoop = val.name;\n                                value = null;\n                            }\n                        }\n                        if (value) {\n                            expressions.push(value);\n                        }\n                        argsComma.push({ name: nameLoop, value: value, expand: expand });\n                        if (parserInput.$char(',')) {\n                            hasSep = true;\n                            continue;\n                        }\n                        hasSep = parserInput.$char(';') === ';';\n                        if (hasSep || isSemiColonSeparated) {\n                            if (expressionContainsNamed) {\n                                error('Cannot mix ; and , as delimiter types');\n                            }\n                            isSemiColonSeparated = true;\n                            if (expressions.length > 1) {\n                                value = new (tree_1.default.Value)(expressions);\n                            }\n                            argsSemiColon.push({ name: name, value: value, expand: expand });\n                            name = null;\n                            expressions = [];\n                            expressionContainsNamed = false;\n                        }\n                    }\n                    parserInput.forget();\n                    returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;\n                    return returner;\n                },\n                //\n                // A Mixin definition, with a list of parameters\n                //\n                //     .rounded (@radius: 2px, @color) {\n                //        ...\n                //     }\n                //\n                // Until we have a finer grained state-machine, we have to\n                // do a look-ahead, to make sure we don't have a mixin call.\n                // See the `rule` function for more information.\n                //\n                // We start by matching `.rounded (`, and then proceed on to\n                // the argument list, which has optional default values.\n                // We store the parameters in `params`, with a `value` key,\n                // if there is a value, such as in the case of `@radius`.\n                //\n                // Once we've got our params list, and a closing `)`, we parse\n                // the `{...}` block.\n                //\n                definition: function () {\n                    var name;\n                    var params = [];\n                    var match;\n                    var ruleset;\n                    var cond;\n                    var variadic = false;\n                    if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||\n                        parserInput.peek(/^[^{]*\\}/)) {\n                        return;\n                    }\n                    parserInput.save();\n                    match = parserInput.$re(/^([#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\\s*\\(/);\n                    if (match) {\n                        name = match[1];\n                        var argInfo = this.args(false);\n                        params = argInfo.args;\n                        variadic = argInfo.variadic;\n                        // .mixincall(\"@{a}\");\n                        // looks a bit like a mixin definition..\n                        // also\n                        // .mixincall(@a: {rule: set;});\n                        // so we have to be nice and restore\n                        if (!parserInput.$char(')')) {\n                            parserInput.restore('Missing closing \\')\\'');\n                            return;\n                        }\n                        parserInput.commentStore.length = 0;\n                        if (parserInput.$str('when')) { // Guard\n                            cond = expect(parsers.conditions, 'expected condition');\n                        }\n                        ruleset = parsers.block();\n                        if (ruleset) {\n                            parserInput.forget();\n                            return new (tree_1.default.mixin.Definition)(name, params, ruleset, cond, variadic);\n                        }\n                        else {\n                            parserInput.restore();\n                        }\n                    }\n                    else {\n                        parserInput.restore();\n                    }\n                },\n                ruleLookups: function () {\n                    var rule;\n                    var lookups = [];\n                    if (parserInput.currentChar() !== '[') {\n                        return;\n                    }\n                    while (true) {\n                        parserInput.save();\n                        rule = this.lookupValue();\n                        if (!rule && rule !== '') {\n                            parserInput.restore();\n                            break;\n                        }\n                        lookups.push(rule);\n                        parserInput.forget();\n                    }\n                    if (lookups.length > 0) {\n                        return lookups;\n                    }\n                },\n                lookupValue: function () {\n                    parserInput.save();\n                    if (!parserInput.$char('[')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    var name = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);\n                    if (!parserInput.$char(']')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    if (name || name === '') {\n                        parserInput.forget();\n                        return name;\n                    }\n                    parserInput.restore();\n                }\n            },\n            //\n            // Entities are the smallest recognized token,\n            // and can be found inside a rule's value.\n            //\n            entity: function () {\n                var entities = this.entities;\n                return this.comment() || entities.literal() || entities.variable() || entities.url() ||\n                    entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) ||\n                    entities.javascript();\n            },\n            //\n            // A Declaration terminator. Note that we use `peek()` to check for '}',\n            // because the `block` rule will be expecting it, but we still need to make sure\n            // it's there, if ';' was omitted.\n            //\n            end: function () {\n                return parserInput.$char(';') || parserInput.peek('}');\n            },\n            //\n            // IE's alpha function\n            //\n            //     alpha(opacity=88)\n            //\n            ieAlpha: function () {\n                var value;\n                // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                if (!parserInput.$re(/^opacity=/i)) {\n                    return;\n                }\n                value = parserInput.$re(/^\\d+/);\n                if (!value) {\n                    value = expect(parsers.entities.variable, 'Could not parse alpha');\n                    value = \"@{\" + value.name.slice(1) + \"}\";\n                }\n                expectChar(')');\n                return new tree_1.default.Quoted('', \"alpha(opacity=\" + value + \")\");\n            },\n            //\n            // A Selector Element\n            //\n            //     div\n            //     + h1\n            //     #socks\n            //     input[type=\"text\"]\n            //\n            // Elements are the building blocks for Selectors,\n            // they are made out of a `Combinator` (see combinator rule),\n            // and an element name, such as a tag a class, or `*`.\n            //\n            element: function () {\n                var e;\n                var c;\n                var v;\n                var index = parserInput.i;\n                c = this.combinator();\n                e = parserInput.$re(/^(?:\\d+\\.\\d+|\\d+)%/) ||\n                    // eslint-disable-next-line no-control-regex\n                    parserInput.$re(/^(?:[.#]?|:*)(?:[\\w-]|[^\\x00-\\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||\n                    parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||\n                    parserInput.$re(/^\\([^&()@]+\\)/) || parserInput.$re(/^[.#:](?=@)/) ||\n                    this.entities.variableCurly();\n                if (!e) {\n                    parserInput.save();\n                    if (parserInput.$char('(')) {\n                        if ((v = this.selector(false)) && parserInput.$char(')')) {\n                            e = new (tree_1.default.Paren)(v);\n                            parserInput.forget();\n                        }\n                        else {\n                            parserInput.restore('Missing closing \\')\\'');\n                        }\n                    }\n                    else {\n                        parserInput.forget();\n                    }\n                }\n                if (e) {\n                    return new (tree_1.default.Element)(c, e, e instanceof tree_1.default.Variable, index + currentIndex, fileInfo);\n                }\n            },\n            //\n            // Combinators combine elements together, in a Selector.\n            //\n            // Because our parser isn't white-space sensitive, special care\n            // has to be taken, when parsing the descendant combinator, ` `,\n            // as it's an empty space. We have to check the previous character\n            // in the input, to see if it's a ` ` character. More info on how\n            // we deal with this in *combinator.js*.\n            //\n            combinator: function () {\n                var c = parserInput.currentChar();\n                if (c === '/') {\n                    parserInput.save();\n                    var slashedCombinator = parserInput.$re(/^\\/[a-z]+\\//i);\n                    if (slashedCombinator) {\n                        parserInput.forget();\n                        return new (tree_1.default.Combinator)(slashedCombinator);\n                    }\n                    parserInput.restore();\n                }\n                if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {\n                    parserInput.i++;\n                    if (c === '^' && parserInput.currentChar() === '^') {\n                        c = '^^';\n                        parserInput.i++;\n                    }\n                    while (parserInput.isWhitespace()) {\n                        parserInput.i++;\n                    }\n                    return new (tree_1.default.Combinator)(c);\n                }\n                else if (parserInput.isWhitespace(-1)) {\n                    return new (tree_1.default.Combinator)(' ');\n                }\n                else {\n                    return new (tree_1.default.Combinator)(null);\n                }\n            },\n            //\n            // A CSS Selector\n            // with less extensions e.g. the ability to extend and guard\n            //\n            //     .class > div + h1\n            //     li a:hover\n            //\n            // Selectors are made out of one or more Elements, see above.\n            //\n            selector: function (isLess) {\n                var index = parserInput.i;\n                var elements;\n                var extendList;\n                var c;\n                var e;\n                var allExtends;\n                var when;\n                var condition;\n                isLess = isLess !== false;\n                while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str('when'))) || (e = this.element())) {\n                    if (when) {\n                        condition = expect(this.conditions, 'expected condition');\n                    }\n                    else if (condition) {\n                        error('CSS guard can only be used at the end of selector');\n                    }\n                    else if (extendList) {\n                        if (allExtends) {\n                            allExtends = allExtends.concat(extendList);\n                        }\n                        else {\n                            allExtends = extendList;\n                        }\n                    }\n                    else {\n                        if (allExtends) {\n                            error('Extend can only be used at the end of selector');\n                        }\n                        c = parserInput.currentChar();\n                        if (elements) {\n                            elements.push(e);\n                        }\n                        else {\n                            elements = [e];\n                        }\n                        e = null;\n                    }\n                    if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {\n                        break;\n                    }\n                }\n                if (elements) {\n                    return new (tree_1.default.Selector)(elements, allExtends, condition, index + currentIndex, fileInfo);\n                }\n                if (allExtends) {\n                    error('Extend must be used to extend a selector, it cannot be used on its own');\n                }\n            },\n            selectors: function () {\n                var s;\n                var selectors;\n                while (true) {\n                    s = this.selector();\n                    if (!s) {\n                        break;\n                    }\n                    if (selectors) {\n                        selectors.push(s);\n                    }\n                    else {\n                        selectors = [s];\n                    }\n                    parserInput.commentStore.length = 0;\n                    if (s.condition && selectors.length > 1) {\n                        error('Guards are only currently allowed on a single selector.');\n                    }\n                    if (!parserInput.$char(',')) {\n                        break;\n                    }\n                    if (s.condition) {\n                        error('Guards are only currently allowed on a single selector.');\n                    }\n                    parserInput.commentStore.length = 0;\n                }\n                return selectors;\n            },\n            attribute: function () {\n                if (!parserInput.$char('[')) {\n                    return;\n                }\n                var entities = this.entities;\n                var key;\n                var val;\n                var op;\n                //\n                // case-insensitive flag\n                // e.g. [attr operator value i]\n                //\n                var cif;\n                if (!(key = entities.variableCurly())) {\n                    key = expect(/^(?:[_A-Za-z0-9-*]*\\|)?(?:[_A-Za-z0-9-]|\\\\.)+/);\n                }\n                op = parserInput.$re(/^[|~*$^]?=/);\n                if (op) {\n                    val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\\w-]+/) || entities.variableCurly();\n                    if (val) {\n                        cif = parserInput.$re(/^[iIsS]/);\n                    }\n                }\n                expectChar(']');\n                return new (tree_1.default.Attribute)(key, op, val, cif);\n            },\n            //\n            // The `block` rule is used by `ruleset` and `mixin.definition`.\n            // It's a wrapper around the `primary` rule, with added `{}`.\n            //\n            block: function () {\n                var content;\n                if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {\n                    return content;\n                }\n            },\n            blockRuleset: function () {\n                var block = this.block();\n                if (block) {\n                    block = new tree_1.default.Ruleset(null, block);\n                }\n                return block;\n            },\n            detachedRuleset: function () {\n                var argInfo;\n                var params;\n                var variadic;\n                parserInput.save();\n                if (parserInput.$re(/^[.#]\\(/)) {\n                    /**\n                     * DR args currently only implemented for each() function, and not\n                     * yet settable as `@dr: #(@arg) {}`\n                     * This should be done when DRs are merged with mixins.\n                     * See: https://github.com/less/less-meta/issues/16\n                     */\n                    argInfo = this.mixin.args(false);\n                    params = argInfo.args;\n                    variadic = argInfo.variadic;\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return;\n                    }\n                }\n                var blockRuleset = this.blockRuleset();\n                if (blockRuleset) {\n                    parserInput.forget();\n                    if (params) {\n                        return new tree_1.default.mixin.Definition(null, params, blockRuleset, null, variadic);\n                    }\n                    return new tree_1.default.DetachedRuleset(blockRuleset);\n                }\n                parserInput.restore();\n            },\n            //\n            // div, .class, body > p {...}\n            //\n            ruleset: function () {\n                var selectors;\n                var rules;\n                var debugInfo;\n                parserInput.save();\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(parserInput.i);\n                }\n                selectors = this.selectors();\n                if (selectors && (rules = this.block())) {\n                    parserInput.forget();\n                    var ruleset = new (tree_1.default.Ruleset)(selectors, rules, context.strictImports);\n                    if (context.dumpLineNumbers) {\n                        ruleset.debugInfo = debugInfo;\n                    }\n                    return ruleset;\n                }\n                else {\n                    parserInput.restore();\n                }\n            },\n            declaration: function () {\n                var name;\n                var value;\n                var index = parserInput.i;\n                var hasDR;\n                var c = parserInput.currentChar();\n                var important;\n                var merge;\n                var isVariable;\n                if (c === '.' || c === '#' || c === '&' || c === ':') {\n                    return;\n                }\n                parserInput.save();\n                name = this.variable() || this.ruleProperty();\n                if (name) {\n                    isVariable = typeof name === 'string';\n                    if (isVariable) {\n                        value = this.detachedRuleset();\n                        if (value) {\n                            hasDR = true;\n                        }\n                    }\n                    parserInput.commentStore.length = 0;\n                    if (!value) {\n                        // a name returned by this.ruleProperty() is always an array of the form:\n                        // [string-1, ..., string-n, \"\"] or [string-1, ..., string-n, \"+\"]\n                        // where each item is a tree.Keyword or tree.Variable\n                        merge = !isVariable && name.length > 1 && name.pop().value;\n                        // Custom property values get permissive parsing\n                        if (name[0].value && name[0].value.slice(0, 2) === '--') {\n                            value = this.permissiveValue(/[;}]/);\n                        }\n                        // Try to store values as anonymous\n                        // If we need the value later we'll re-parse it in ruleset.parseValue\n                        else {\n                            value = this.anonymousValue();\n                        }\n                        if (value) {\n                            parserInput.forget();\n                            // anonymous values absorb the end ';' which is required for them to work\n                            return new (tree_1.default.Declaration)(name, value, false, merge, index + currentIndex, fileInfo);\n                        }\n                        if (!value) {\n                            value = this.value();\n                        }\n                        if (value) {\n                            important = this.important();\n                        }\n                        else if (isVariable) {\n                            // As a last resort, try permissiveValue\n                            value = this.permissiveValue();\n                        }\n                    }\n                    if (value && (this.end() || hasDR)) {\n                        parserInput.forget();\n                        return new (tree_1.default.Declaration)(name, value, important, merge, index + currentIndex, fileInfo);\n                    }\n                    else {\n                        parserInput.restore();\n                    }\n                }\n                else {\n                    parserInput.restore();\n                }\n            },\n            anonymousValue: function () {\n                var index = parserInput.i;\n                var match = parserInput.$re(/^([^.#@$+/'\"*`(;{}-]*);/);\n                if (match) {\n                    return new (tree_1.default.Anonymous)(match[1], index + currentIndex);\n                }\n            },\n            /**\n             * Used for custom properties, at-rules, and variables (as fallback)\n             * Parses almost anything inside of {} [] () \"\" blocks\n             * until it reaches outer-most tokens.\n             *\n             * First, it will try to parse comments and entities to reach\n             * the end. This is mostly like the Expression parser except no\n             * math is allowed.\n             */\n            permissiveValue: function (untilTokens) {\n                var i;\n                var e;\n                var done;\n                var value;\n                var tok = untilTokens || ';';\n                var index = parserInput.i;\n                var result = [];\n                function testCurrentChar() {\n                    var char = parserInput.currentChar();\n                    if (typeof tok === 'string') {\n                        return char === tok;\n                    }\n                    else {\n                        return tok.test(char);\n                    }\n                }\n                if (testCurrentChar()) {\n                    return;\n                }\n                value = [];\n                do {\n                    e = this.comment();\n                    if (e) {\n                        value.push(e);\n                        continue;\n                    }\n                    e = this.entity();\n                    if (e) {\n                        value.push(e);\n                    }\n                } while (e);\n                done = testCurrentChar();\n                if (value.length > 0) {\n                    value = new (tree_1.default.Expression)(value);\n                    if (done) {\n                        return value;\n                    }\n                    else {\n                        result.push(value);\n                    }\n                    // Preserve space before $parseUntil as it will not\n                    if (parserInput.prevChar() === ' ') {\n                        result.push(new tree_1.default.Anonymous(' ', index));\n                    }\n                }\n                parserInput.save();\n                value = parserInput.$parseUntil(tok);\n                if (value) {\n                    if (typeof value === 'string') {\n                        error(\"Expected '\" + value + \"'\", 'Parse');\n                    }\n                    if (value.length === 1 && value[0] === ' ') {\n                        parserInput.forget();\n                        return new tree_1.default.Anonymous('', index);\n                    }\n                    var item = void 0;\n                    for (i = 0; i < value.length; i++) {\n                        item = value[i];\n                        if (Array.isArray(item)) {\n                            // Treat actual quotes as normal quoted values\n                            result.push(new tree_1.default.Quoted(item[0], item[1], true, index, fileInfo));\n                        }\n                        else {\n                            if (i === value.length - 1) {\n                                item = item.trim();\n                            }\n                            // Treat like quoted values, but replace vars like unquoted expressions\n                            var quote = new tree_1.default.Quoted('\\'', item, true, index, fileInfo);\n                            quote.variableRegex = /@([\\w-]+)/g;\n                            quote.propRegex = /\\$([\\w-]+)/g;\n                            result.push(quote);\n                        }\n                    }\n                    parserInput.forget();\n                    return new tree_1.default.Expression(result, true);\n                }\n                parserInput.restore();\n            },\n            //\n            // An @import atrule\n            //\n            //     @import \"lib\";\n            //\n            // Depending on our environment, importing is done differently:\n            // In the browser, it's an XHR request, in Node, it would be a\n            // file-system operation. The function used for importing is\n            // stored in `import`, which we pass to the Import constructor.\n            //\n            'import': function () {\n                var path;\n                var features;\n                var index = parserInput.i;\n                var dir = parserInput.$re(/^@import\\s+/);\n                if (dir) {\n                    var options = (dir ? this.importOptions() : null) || {};\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n                        features = this.mediaFeatures({});\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error('missing semi-colon or unrecognised media features on import');\n                        }\n                        features = features && new (tree_1.default.Value)(features);\n                        return new (tree_1.default.Import)(path, features, options, index + currentIndex, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error('malformed import statement');\n                    }\n                }\n            },\n            importOptions: function () {\n                var o;\n                var options = {};\n                var optionName;\n                var value;\n                // list of options, surrounded by parens\n                if (!parserInput.$char('(')) {\n                    return null;\n                }\n                do {\n                    o = this.importOption();\n                    if (o) {\n                        optionName = o;\n                        value = true;\n                        switch (optionName) {\n                            case 'css':\n                                optionName = 'less';\n                                value = false;\n                                break;\n                            case 'once':\n                                optionName = 'multiple';\n                                value = false;\n                                break;\n                        }\n                        options[optionName] = value;\n                        if (!parserInput.$char(',')) {\n                            break;\n                        }\n                    }\n                } while (o);\n                expectChar(')');\n                return options;\n            },\n            importOption: function () {\n                var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);\n                if (opt) {\n                    return opt[1];\n                }\n            },\n            mediaFeature: function (syntaxOptions) {\n                var entities = this.entities;\n                var nodes = [];\n                var e;\n                var p;\n                var rangeP;\n                parserInput.save();\n                do {\n                    e = entities.keyword() || entities.variable() || entities.mixinLookup();\n                    if (e) {\n                        nodes.push(e);\n                    }\n                    else if (parserInput.$char('(')) {\n                        p = this.property();\n                        parserInput.save();\n                        if (!p && syntaxOptions.queryInParens && parserInput.$re(/^[0-9a-z-]*\\s*([<>]=|<=|>=|[<>]|=)/)) {\n                            parserInput.restore();\n                            p = this.condition();\n                            parserInput.save();\n                            rangeP = this.atomicCondition(null, p.rvalue);\n                            if (!rangeP) {\n                                parserInput.restore();\n                            }\n                        }\n                        else {\n                            parserInput.restore();\n                            e = this.value();\n                        }\n                        if (parserInput.$char(')')) {\n                            if (p && !e) {\n                                nodes.push(new (tree_1.default.Paren)(new (tree_1.default.QueryInParens)(p.op, p.lvalue, p.rvalue, rangeP ? rangeP.op : null, rangeP ? rangeP.rvalue : null, p._index)));\n                                e = p;\n                            }\n                            else if (p && e) {\n                                nodes.push(new (tree_1.default.Paren)(new (tree_1.default.Declaration)(p, e, null, null, parserInput.i + currentIndex, fileInfo, true)));\n                            }\n                            else if (e) {\n                                nodes.push(new (tree_1.default.Paren)(e));\n                            }\n                            else {\n                                error('badly formed media feature definition');\n                            }\n                        }\n                        else {\n                            error('Missing closing \\')\\'', 'Parse');\n                        }\n                    }\n                } while (e);\n                parserInput.forget();\n                if (nodes.length > 0) {\n                    return new (tree_1.default.Expression)(nodes);\n                }\n            },\n            mediaFeatures: function (syntaxOptions) {\n                var entities = this.entities;\n                var features = [];\n                var e;\n                do {\n                    e = this.mediaFeature(syntaxOptions);\n                    if (e) {\n                        features.push(e);\n                        if (!parserInput.$char(',')) {\n                            break;\n                        }\n                    }\n                    else {\n                        e = entities.variable() || entities.mixinLookup();\n                        if (e) {\n                            features.push(e);\n                            if (!parserInput.$char(',')) {\n                                break;\n                            }\n                        }\n                    }\n                } while (e);\n                return features.length > 0 ? features : null;\n            },\n            prepareAndGetNestableAtRule: function (treeType, index, debugInfo, syntaxOptions) {\n                var features = this.mediaFeatures(syntaxOptions);\n                var rules = this.block();\n                if (!rules) {\n                    error('media definitions require block statements after any features');\n                }\n                parserInput.forget();\n                var atRule = new (treeType)(rules, features, index + currentIndex, fileInfo);\n                if (context.dumpLineNumbers) {\n                    atRule.debugInfo = debugInfo;\n                }\n                return atRule;\n            },\n            nestableAtRule: function () {\n                var debugInfo;\n                var index = parserInput.i;\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(index);\n                }\n                parserInput.save();\n                if (parserInput.$peekChar('@')) {\n                    if (parserInput.$str('@media')) {\n                        return this.prepareAndGetNestableAtRule(tree_1.default.Media, index, debugInfo, atrule_syntax_1.MediaSyntaxOptions);\n                    }\n                    if (parserInput.$str('@container')) {\n                        return this.prepareAndGetNestableAtRule(tree_1.default.Container, index, debugInfo, atrule_syntax_1.ContainerSyntaxOptions);\n                    }\n                }\n                parserInput.restore();\n            },\n            //\n            // A @plugin directive, used to import plugins dynamically.\n            //\n            //     @plugin (args) \"lib\";\n            //\n            plugin: function () {\n                var path;\n                var args;\n                var options;\n                var index = parserInput.i;\n                var dir = parserInput.$re(/^@plugin\\s+/);\n                if (dir) {\n                    args = this.pluginArgs();\n                    if (args) {\n                        options = {\n                            pluginArgs: args,\n                            isPlugin: true\n                        };\n                    }\n                    else {\n                        options = { isPlugin: true };\n                    }\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error('missing semi-colon on @plugin');\n                        }\n                        return new (tree_1.default.Import)(path, null, options, index + currentIndex, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error('malformed @plugin statement');\n                    }\n                }\n            },\n            pluginArgs: function () {\n                // list of options, surrounded by parens\n                parserInput.save();\n                if (!parserInput.$char('(')) {\n                    parserInput.restore();\n                    return null;\n                }\n                var args = parserInput.$re(/^\\s*([^);]+)\\)\\s*/);\n                if (args[1]) {\n                    parserInput.forget();\n                    return args[1].trim();\n                }\n                else {\n                    parserInput.restore();\n                    return null;\n                }\n            },\n            //\n            // A CSS AtRule\n            //\n            //     @charset \"utf-8\";\n            //\n            atrule: function () {\n                var index = parserInput.i;\n                var name;\n                var value;\n                var rules;\n                var nonVendorSpecificName;\n                var hasIdentifier;\n                var hasExpression;\n                var hasUnknown;\n                var hasBlock = true;\n                var isRooted = true;\n                if (parserInput.currentChar() !== '@') {\n                    return;\n                }\n                value = this['import']() || this.plugin() || this.nestableAtRule();\n                if (value) {\n                    return value;\n                }\n                parserInput.save();\n                name = parserInput.$re(/^@[a-z-]+/);\n                if (!name) {\n                    return;\n                }\n                nonVendorSpecificName = name;\n                if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {\n                    nonVendorSpecificName = \"@\" + name.slice(name.indexOf('-', 2) + 1);\n                }\n                switch (nonVendorSpecificName) {\n                    case '@charset':\n                        hasIdentifier = true;\n                        hasBlock = false;\n                        break;\n                    case '@namespace':\n                        hasExpression = true;\n                        hasBlock = false;\n                        break;\n                    case '@keyframes':\n                    case '@counter-style':\n                        hasIdentifier = true;\n                        break;\n                    case '@document':\n                    case '@supports':\n                        hasUnknown = true;\n                        isRooted = false;\n                        break;\n                    default:\n                        hasUnknown = true;\n                        break;\n                }\n                parserInput.commentStore.length = 0;\n                if (hasIdentifier) {\n                    value = this.entity();\n                    if (!value) {\n                        error(\"expected \" + name + \" identifier\");\n                    }\n                }\n                else if (hasExpression) {\n                    value = this.expression();\n                    if (!value) {\n                        error(\"expected \" + name + \" expression\");\n                    }\n                }\n                else if (hasUnknown) {\n                    value = this.permissiveValue(/^[{;]/);\n                    hasBlock = (parserInput.currentChar() === '{');\n                    if (!value) {\n                        if (!hasBlock && parserInput.currentChar() !== ';') {\n                            error(name + \" rule is missing block or ending semi-colon\");\n                        }\n                    }\n                    else if (!value.value) {\n                        value = null;\n                    }\n                }\n                if (hasBlock) {\n                    rules = this.blockRuleset();\n                }\n                if (rules || (!hasBlock && value && parserInput.$char(';'))) {\n                    parserInput.forget();\n                    return new (tree_1.default.AtRule)(name, value, rules, index + currentIndex, fileInfo, context.dumpLineNumbers ? getDebugInfo(index) : null, isRooted);\n                }\n                parserInput.restore('at-rule options not recognised');\n            },\n            //\n            // A Value is a comma-delimited list of Expressions\n            //\n            //     font-family: Baskerville, Georgia, serif;\n            //\n            // In a Rule, a Value represents everything after the `:`,\n            // and before the `;`.\n            //\n            value: function () {\n                var e;\n                var expressions = [];\n                var index = parserInput.i;\n                do {\n                    e = this.expression();\n                    if (e) {\n                        expressions.push(e);\n                        if (!parserInput.$char(',')) {\n                            break;\n                        }\n                    }\n                } while (e);\n                if (expressions.length > 0) {\n                    return new (tree_1.default.Value)(expressions, index + currentIndex);\n                }\n            },\n            important: function () {\n                if (parserInput.currentChar() === '!') {\n                    return parserInput.$re(/^! *important/);\n                }\n            },\n            sub: function () {\n                var a;\n                var e;\n                parserInput.save();\n                if (parserInput.$char('(')) {\n                    a = this.addition();\n                    if (a && parserInput.$char(')')) {\n                        parserInput.forget();\n                        e = new (tree_1.default.Expression)([a]);\n                        e.parens = true;\n                        return e;\n                    }\n                    parserInput.restore('Expected \\')\\'');\n                    return;\n                }\n                parserInput.restore();\n            },\n            multiplication: function () {\n                var m;\n                var a;\n                var op;\n                var operation;\n                var isSpaced;\n                m = this.operand();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        if (parserInput.peek(/^\\/[*/]/)) {\n                            break;\n                        }\n                        parserInput.save();\n                        op = parserInput.$char('/') || parserInput.$char('*') || parserInput.$str('./');\n                        if (!op) {\n                            parserInput.forget();\n                            break;\n                        }\n                        a = this.operand();\n                        if (!a) {\n                            parserInput.restore();\n                            break;\n                        }\n                        parserInput.forget();\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new (tree_1.default.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            addition: function () {\n                var m;\n                var a;\n                var op;\n                var operation;\n                var isSpaced;\n                m = this.multiplication();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        op = parserInput.$re(/^[-+]\\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));\n                        if (!op) {\n                            break;\n                        }\n                        a = this.multiplication();\n                        if (!a) {\n                            break;\n                        }\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new (tree_1.default.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            conditions: function () {\n                var a;\n                var b;\n                var index = parserInput.i;\n                var condition;\n                a = this.condition(true);\n                if (a) {\n                    while (true) {\n                        if (!parserInput.peek(/^,\\s*(not\\s*)?\\(/) || !parserInput.$char(',')) {\n                            break;\n                        }\n                        b = this.condition(true);\n                        if (!b) {\n                            break;\n                        }\n                        condition = new (tree_1.default.Condition)('or', condition || a, b, index + currentIndex);\n                    }\n                    return condition || a;\n                }\n            },\n            condition: function (needsParens) {\n                var result;\n                var logical;\n                var next;\n                function or() {\n                    return parserInput.$str('or');\n                }\n                result = this.conditionAnd(needsParens);\n                if (!result) {\n                    return;\n                }\n                logical = or();\n                if (logical) {\n                    next = this.condition(needsParens);\n                    if (next) {\n                        result = new (tree_1.default.Condition)(logical, result, next);\n                    }\n                    else {\n                        return;\n                    }\n                }\n                return result;\n            },\n            conditionAnd: function (needsParens) {\n                var result;\n                var logical;\n                var next;\n                var self = this;\n                function insideCondition() {\n                    var cond = self.negatedCondition(needsParens) || self.parenthesisCondition(needsParens);\n                    if (!cond && !needsParens) {\n                        return self.atomicCondition(needsParens);\n                    }\n                    return cond;\n                }\n                function and() {\n                    return parserInput.$str('and');\n                }\n                result = insideCondition();\n                if (!result) {\n                    return;\n                }\n                logical = and();\n                if (logical) {\n                    next = this.conditionAnd(needsParens);\n                    if (next) {\n                        result = new (tree_1.default.Condition)(logical, result, next);\n                    }\n                    else {\n                        return;\n                    }\n                }\n                return result;\n            },\n            negatedCondition: function (needsParens) {\n                if (parserInput.$str('not')) {\n                    var result = this.parenthesisCondition(needsParens);\n                    if (result) {\n                        result.negate = !result.negate;\n                    }\n                    return result;\n                }\n            },\n            parenthesisCondition: function (needsParens) {\n                function tryConditionFollowedByParenthesis(me) {\n                    var body;\n                    parserInput.save();\n                    body = me.condition(needsParens);\n                    if (!body) {\n                        parserInput.restore();\n                        return;\n                    }\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    parserInput.forget();\n                    return body;\n                }\n                var body;\n                parserInput.save();\n                if (!parserInput.$str('(')) {\n                    parserInput.restore();\n                    return;\n                }\n                body = tryConditionFollowedByParenthesis(this);\n                if (body) {\n                    parserInput.forget();\n                    return body;\n                }\n                body = this.atomicCondition(needsParens);\n                if (!body) {\n                    parserInput.restore();\n                    return;\n                }\n                if (!parserInput.$char(')')) {\n                    parserInput.restore(\"expected ')' got '\" + parserInput.currentChar() + \"'\");\n                    return;\n                }\n                parserInput.forget();\n                return body;\n            },\n            atomicCondition: function (needsParens, preparsedCond) {\n                var entities = this.entities;\n                var index = parserInput.i;\n                var a;\n                var b;\n                var c;\n                var op;\n                var cond = (function () {\n                    return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();\n                }).bind(this);\n                if (preparsedCond) {\n                    a = preparsedCond;\n                }\n                else {\n                    a = cond();\n                }\n                if (a) {\n                    if (parserInput.$char('>')) {\n                        if (parserInput.$char('=')) {\n                            op = '>=';\n                        }\n                        else {\n                            op = '>';\n                        }\n                    }\n                    else if (parserInput.$char('<')) {\n                        if (parserInput.$char('=')) {\n                            op = '<=';\n                        }\n                        else {\n                            op = '<';\n                        }\n                    }\n                    else if (parserInput.$char('=')) {\n                        if (parserInput.$char('>')) {\n                            op = '=>';\n                        }\n                        else if (parserInput.$char('<')) {\n                            op = '=<';\n                        }\n                        else {\n                            op = '=';\n                        }\n                    }\n                    if (op) {\n                        b = cond();\n                        if (b) {\n                            c = new (tree_1.default.Condition)(op, a, b, index + currentIndex, false);\n                        }\n                        else {\n                            error('expected expression');\n                        }\n                    }\n                    else if (!preparsedCond) {\n                        c = new (tree_1.default.Condition)('=', a, new (tree_1.default.Keyword)('true'), index + currentIndex, false);\n                    }\n                    return c;\n                }\n            },\n            //\n            // An operand is anything that can be part of an operation,\n            // such as a Color, or a Variable\n            //\n            operand: function () {\n                var entities = this.entities;\n                var negate;\n                if (parserInput.peek(/^-[@$(]/)) {\n                    negate = parserInput.$char('-');\n                }\n                var o = this.sub() || entities.dimension() ||\n                    entities.color() || entities.variable() ||\n                    entities.property() || entities.call() ||\n                    entities.quoted(true) || entities.colorKeyword() ||\n                    entities.mixinLookup();\n                if (negate) {\n                    o.parensInOp = true;\n                    o = new (tree_1.default.Negative)(o);\n                }\n                return o;\n            },\n            //\n            // Expressions either represent mathematical operations,\n            // or white-space delimited Entities.\n            //\n            //     1px solid black\n            //     @var * 2\n            //\n            expression: function () {\n                var entities = [];\n                var e;\n                var delim;\n                var index = parserInput.i;\n                do {\n                    e = this.comment();\n                    if (e) {\n                        entities.push(e);\n                        continue;\n                    }\n                    e = this.addition() || this.entity();\n                    if (e instanceof tree_1.default.Comment) {\n                        e = null;\n                    }\n                    if (e) {\n                        entities.push(e);\n                        // operations do not allow keyword \"/\" dimension (e.g. small/20px) so we support that here\n                        if (!parserInput.peek(/^\\/[/*]/)) {\n                            delim = parserInput.$char('/');\n                            if (delim) {\n                                entities.push(new (tree_1.default.Anonymous)(delim, index + currentIndex));\n                            }\n                        }\n                    }\n                } while (e);\n                if (entities.length > 0) {\n                    return new (tree_1.default.Expression)(entities);\n                }\n            },\n            property: function () {\n                var name = parserInput.$re(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*:/);\n                if (name) {\n                    return name[1];\n                }\n            },\n            ruleProperty: function () {\n                var name = [];\n                var index = [];\n                var s;\n                var k;\n                parserInput.save();\n                var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\\s*:/);\n                if (simpleProperty) {\n                    name = [new (tree_1.default.Keyword)(simpleProperty[1])];\n                    parserInput.forget();\n                    return name;\n                }\n                function match(re) {\n                    var i = parserInput.i;\n                    var chunk = parserInput.$re(re);\n                    if (chunk) {\n                        index.push(i);\n                        return name.push(chunk[1]);\n                    }\n                }\n                match(/^(\\*?)/);\n                while (true) {\n                    if (!match(/^((?:[\\w-]+)|(?:[@$]\\{[\\w-]+\\}))/)) {\n                        break;\n                    }\n                }\n                if ((name.length > 1) && match(/^((?:\\+_|\\+)?)\\s*:/)) {\n                    parserInput.forget();\n                    // at last, we have the complete match now. move forward,\n                    // convert name particles to tree objects and return:\n                    if (name[0] === '') {\n                        name.shift();\n                        index.shift();\n                    }\n                    for (k = 0; k < name.length; k++) {\n                        s = name[k];\n                        name[k] = (s.charAt(0) !== '@' && s.charAt(0) !== '$') ?\n                            new (tree_1.default.Keyword)(s) :\n                            (s.charAt(0) === '@' ?\n                                new (tree_1.default.Variable)(\"@\" + s.slice(2, -1), index[k] + currentIndex, fileInfo) :\n                                new (tree_1.default.Property)(\"$\" + s.slice(2, -1), index[k] + currentIndex, fileInfo));\n                    }\n                    return name;\n                }\n                parserInput.restore();\n            }\n        }\n    };\n};\nParser.serializeVars = function (vars) {\n    var s = '';\n    for (var name_1 in vars) {\n        if (Object.hasOwnProperty.call(vars, name_1)) {\n            var value = vars[name_1];\n            s += ((name_1[0] === '@') ? '' : '@') + name_1 + \": \" + value + ((String(value).slice(-1) === ';') ? '' : ';');\n        }\n    }\n    return s;\n};\nexports.default = Parser;\n//# sourceMappingURL=parser.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar visitor_1 = tslib_1.__importDefault(require(\"./visitor\"));\nvar import_visitor_1 = tslib_1.__importDefault(require(\"./import-visitor\"));\nvar set_tree_visibility_visitor_1 = tslib_1.__importDefault(require(\"./set-tree-visibility-visitor\"));\nvar extend_visitor_1 = tslib_1.__importDefault(require(\"./extend-visitor\"));\nvar join_selector_visitor_1 = tslib_1.__importDefault(require(\"./join-selector-visitor\"));\nvar to_css_visitor_1 = tslib_1.__importDefault(require(\"./to-css-visitor\"));\nexports.default = {\n    Visitor: visitor_1.default,\n    ImportVisitor: import_visitor_1.default,\n    MarkVisibleSelectorsVisitor: set_tree_visibility_visitor_1.default,\n    ExtendVisitor: extend_visitor_1.default,\n    JoinSelectorVisitor: join_selector_visitor_1.default,\n    ToCSSVisitor: to_css_visitor_1.default\n};\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tree_1 = tslib_1.__importDefault(require(\"../tree\"));\nvar _visitArgs = { visitDeeper: true };\nvar _hasIndexed = false;\nfunction _noop(node) {\n    return node;\n}\nfunction indexNodeTypes(parent, ticker) {\n    // add .typeIndex to tree node types for lookup table\n    var key, child;\n    for (key in parent) {\n        /* eslint guard-for-in: 0 */\n        child = parent[key];\n        switch (typeof child) {\n            case 'function':\n                // ignore bound functions directly on tree which do not have a prototype\n                // or aren't nodes\n                if (child.prototype && child.prototype.type) {\n                    child.prototype.typeIndex = ticker++;\n                }\n                break;\n            case 'object':\n                ticker = indexNodeTypes(child, ticker);\n                break;\n        }\n    }\n    return ticker;\n}\nvar Visitor = /** @class */ (function () {\n    function Visitor(implementation) {\n        this._implementation = implementation;\n        this._visitInCache = {};\n        this._visitOutCache = {};\n        if (!_hasIndexed) {\n            indexNodeTypes(tree_1.default, 1);\n            _hasIndexed = true;\n        }\n    }\n    Visitor.prototype.visit = function (node) {\n        if (!node) {\n            return node;\n        }\n        var nodeTypeIndex = node.typeIndex;\n        if (!nodeTypeIndex) {\n            // MixinCall args aren't a node type?\n            if (node.value && node.value.typeIndex) {\n                this.visit(node.value);\n            }\n            return node;\n        }\n        var impl = this._implementation;\n        var func = this._visitInCache[nodeTypeIndex];\n        var funcOut = this._visitOutCache[nodeTypeIndex];\n        var visitArgs = _visitArgs;\n        var fnName;\n        visitArgs.visitDeeper = true;\n        if (!func) {\n            fnName = \"visit\" + node.type;\n            func = impl[fnName] || _noop;\n            funcOut = impl[fnName + \"Out\"] || _noop;\n            this._visitInCache[nodeTypeIndex] = func;\n            this._visitOutCache[nodeTypeIndex] = funcOut;\n        }\n        if (func !== _noop) {\n            var newNode = func.call(impl, node, visitArgs);\n            if (node && impl.isReplacing) {\n                node = newNode;\n            }\n        }\n        if (visitArgs.visitDeeper && node) {\n            if (node.length) {\n                for (var i = 0, cnt = node.length; i < cnt; i++) {\n                    if (node[i].accept) {\n                        node[i].accept(this);\n                    }\n                }\n            }\n            else if (node.accept) {\n                node.accept(this);\n            }\n        }\n        if (funcOut != _noop) {\n            funcOut.call(impl, node);\n        }\n        return node;\n    };\n    Visitor.prototype.visitArray = function (nodes, nonReplacing) {\n        if (!nodes) {\n            return nodes;\n        }\n        var cnt = nodes.length;\n        var i;\n        // Non-replacing\n        if (nonReplacing || !this._implementation.isReplacing) {\n            for (i = 0; i < cnt; i++) {\n                this.visit(nodes[i]);\n            }\n            return nodes;\n        }\n        // Replacing\n        var out = [];\n        for (i = 0; i < cnt; i++) {\n            var evald = this.visit(nodes[i]);\n            if (evald === undefined) {\n                continue;\n            }\n            if (!evald.splice) {\n                out.push(evald);\n            }\n            else if (evald.length) {\n                this.flatten(evald, out);\n            }\n        }\n        return out;\n    };\n    Visitor.prototype.flatten = function (arr, out) {\n        if (!out) {\n            out = [];\n        }\n        var cnt, i, item, nestedCnt, j, nestedItem;\n        for (i = 0, cnt = arr.length; i < cnt; i++) {\n            item = arr[i];\n            if (item === undefined) {\n                continue;\n            }\n            if (!item.splice) {\n                out.push(item);\n                continue;\n            }\n            for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {\n                nestedItem = item[j];\n                if (nestedItem === undefined) {\n                    continue;\n                }\n                if (!nestedItem.splice) {\n                    out.push(nestedItem);\n                }\n                else if (nestedItem.length) {\n                    this.flatten(nestedItem, out);\n                }\n            }\n        }\n        return out;\n    };\n    return Visitor;\n}());\nexports.default = Visitor;\n//# sourceMappingURL=visitor.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/* eslint-disable no-unused-vars */\n/**\n * @todo - Remove unused when JSDoc types are added for visitor methods\n */\nvar contexts_1 = tslib_1.__importDefault(require(\"../contexts\"));\nvar visitor_1 = tslib_1.__importDefault(require(\"./visitor\"));\nvar import_sequencer_1 = tslib_1.__importDefault(require(\"./import-sequencer\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\nvar ImportVisitor = function (importer, finish) {\n    this._visitor = new visitor_1.default(this);\n    this._importer = importer;\n    this._finish = finish;\n    this.context = new contexts_1.default.Eval();\n    this.importCount = 0;\n    this.onceFileDetectionMap = {};\n    this.recursionDetector = {};\n    this._sequencer = new import_sequencer_1.default(this._onSequencerEmpty.bind(this));\n};\nImportVisitor.prototype = {\n    isReplacing: false,\n    run: function (root) {\n        try {\n            // process the contents\n            this._visitor.visit(root);\n        }\n        catch (e) {\n            this.error = e;\n        }\n        this.isFinished = true;\n        this._sequencer.tryRun();\n    },\n    _onSequencerEmpty: function () {\n        if (!this.isFinished) {\n            return;\n        }\n        this._finish(this.error);\n    },\n    visitImport: function (importNode, visitArgs) {\n        var inlineCSS = importNode.options.inline;\n        if (!importNode.css || inlineCSS) {\n            var context = new contexts_1.default.Eval(this.context, utils.copyArray(this.context.frames));\n            var importParent = context.frames[0];\n            this.importCount++;\n            if (importNode.isVariableImport()) {\n                this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));\n            }\n            else {\n                this.processImportNode(importNode, context, importParent);\n            }\n        }\n        visitArgs.visitDeeper = false;\n    },\n    processImportNode: function (importNode, context, importParent) {\n        var evaldImportNode;\n        var inlineCSS = importNode.options.inline;\n        try {\n            evaldImportNode = importNode.evalForImport(context);\n        }\n        catch (e) {\n            if (!e.filename) {\n                e.index = importNode.getIndex();\n                e.filename = importNode.fileInfo().filename;\n            }\n            // attempt to eval properly and treat as css\n            importNode.css = true;\n            // if that fails, this error will be thrown\n            importNode.error = e;\n        }\n        if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {\n            if (evaldImportNode.options.multiple) {\n                context.importMultiple = true;\n            }\n            // try appending if we haven't determined if it is css or not\n            var tryAppendLessExtension = evaldImportNode.css === undefined;\n            for (var i = 0; i < importParent.rules.length; i++) {\n                if (importParent.rules[i] === importNode) {\n                    importParent.rules[i] = evaldImportNode;\n                    break;\n                }\n            }\n            var onImported = this.onImported.bind(this, evaldImportNode, context), sequencedOnImported = this._sequencer.addImport(onImported);\n            this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.fileInfo(), evaldImportNode.options, sequencedOnImported);\n        }\n        else {\n            this.importCount--;\n            if (this.isFinished) {\n                this._sequencer.tryRun();\n            }\n        }\n    },\n    onImported: function (importNode, context, e, root, importedAtRoot, fullPath) {\n        if (e) {\n            if (!e.filename) {\n                e.index = importNode.getIndex();\n                e.filename = importNode.fileInfo().filename;\n            }\n            this.error = e;\n        }\n        var importVisitor = this, inlineCSS = importNode.options.inline, isPlugin = importNode.options.isPlugin, isOptional = importNode.options.optional, duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;\n        if (!context.importMultiple) {\n            if (duplicateImport) {\n                importNode.skip = true;\n            }\n            else {\n                importNode.skip = function () {\n                    if (fullPath in importVisitor.onceFileDetectionMap) {\n                        return true;\n                    }\n                    importVisitor.onceFileDetectionMap[fullPath] = true;\n                    return false;\n                };\n            }\n        }\n        if (!fullPath && isOptional) {\n            importNode.skip = true;\n        }\n        if (root) {\n            importNode.root = root;\n            importNode.importedFilename = fullPath;\n            if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {\n                importVisitor.recursionDetector[fullPath] = true;\n                var oldContext = this.context;\n                this.context = context;\n                try {\n                    this._visitor.visit(root);\n                }\n                catch (e) {\n                    this.error = e;\n                }\n                this.context = oldContext;\n            }\n        }\n        importVisitor.importCount--;\n        if (importVisitor.isFinished) {\n            importVisitor._sequencer.tryRun();\n        }\n    },\n    visitDeclaration: function (declNode, visitArgs) {\n        if (declNode.value.type === 'DetachedRuleset') {\n            this.context.frames.unshift(declNode);\n        }\n        else {\n            visitArgs.visitDeeper = false;\n        }\n    },\n    visitDeclarationOut: function (declNode) {\n        if (declNode.value.type === 'DetachedRuleset') {\n            this.context.frames.shift();\n        }\n    },\n    visitAtRule: function (atRuleNode, visitArgs) {\n        this.context.frames.unshift(atRuleNode);\n    },\n    visitAtRuleOut: function (atRuleNode) {\n        this.context.frames.shift();\n    },\n    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {\n        this.context.frames.unshift(mixinDefinitionNode);\n    },\n    visitMixinDefinitionOut: function (mixinDefinitionNode) {\n        this.context.frames.shift();\n    },\n    visitRuleset: function (rulesetNode, visitArgs) {\n        this.context.frames.unshift(rulesetNode);\n    },\n    visitRulesetOut: function (rulesetNode) {\n        this.context.frames.shift();\n    },\n    visitMedia: function (mediaNode, visitArgs) {\n        this.context.frames.unshift(mediaNode.rules[0]);\n    },\n    visitMediaOut: function (mediaNode) {\n        this.context.frames.shift();\n    }\n};\nexports.default = ImportVisitor;\n//# sourceMappingURL=import-visitor.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar contexts = {};\nexports.default = contexts;\nvar Constants = tslib_1.__importStar(require(\"./constants\"));\nvar copyFromOriginal = function copyFromOriginal(original, destination, propertiesToCopy) {\n    if (!original) {\n        return;\n    }\n    for (var i = 0; i < propertiesToCopy.length; i++) {\n        if (Object.prototype.hasOwnProperty.call(original, propertiesToCopy[i])) {\n            destination[propertiesToCopy[i]] = original[propertiesToCopy[i]];\n        }\n    }\n};\n/*\n parse is used whilst parsing\n */\nvar parseCopyProperties = [\n    // options\n    'paths',\n    'rewriteUrls',\n    'rootpath',\n    'strictImports',\n    'insecure',\n    'dumpLineNumbers',\n    'compress',\n    'syncImport',\n    'chunkInput',\n    'mime',\n    'useFileCache',\n    // context\n    'processImports',\n    // Used by the import manager to stop multiple import visitors being created.\n    'pluginManager' // Used as the plugin manager for the session\n];\ncontexts.Parse = function (options) {\n    copyFromOriginal(options, this, parseCopyProperties);\n    if (typeof this.paths === 'string') {\n        this.paths = [this.paths];\n    }\n};\nvar evalCopyProperties = [\n    'paths',\n    'compress',\n    'math',\n    'strictUnits',\n    'sourceMap',\n    'importMultiple',\n    'urlArgs',\n    'javascriptEnabled',\n    'pluginManager',\n    'importantScope',\n    'rewriteUrls' // option - whether to adjust URL's to be relative\n];\ncontexts.Eval = function (options, frames) {\n    copyFromOriginal(options, this, evalCopyProperties);\n    if (typeof this.paths === 'string') {\n        this.paths = [this.paths];\n    }\n    this.frames = frames || [];\n    this.importantScope = this.importantScope || [];\n};\ncontexts.Eval.prototype.enterCalc = function () {\n    if (!this.calcStack) {\n        this.calcStack = [];\n    }\n    this.calcStack.push(true);\n    this.inCalc = true;\n};\ncontexts.Eval.prototype.exitCalc = function () {\n    this.calcStack.pop();\n    if (!this.calcStack.length) {\n        this.inCalc = false;\n    }\n};\ncontexts.Eval.prototype.inParenthesis = function () {\n    if (!this.parensStack) {\n        this.parensStack = [];\n    }\n    this.parensStack.push(true);\n};\ncontexts.Eval.prototype.outOfParenthesis = function () {\n    this.parensStack.pop();\n};\ncontexts.Eval.prototype.inCalc = false;\ncontexts.Eval.prototype.mathOn = true;\ncontexts.Eval.prototype.isMathOn = function (op) {\n    if (!this.mathOn) {\n        return false;\n    }\n    if (op === '/' && this.math !== Constants.Math.ALWAYS && (!this.parensStack || !this.parensStack.length)) {\n        return false;\n    }\n    if (this.math > Constants.Math.PARENS_DIVISION) {\n        return this.parensStack && this.parensStack.length;\n    }\n    return true;\n};\ncontexts.Eval.prototype.pathRequiresRewrite = function (path) {\n    var isRelative = this.rewriteUrls === Constants.RewriteUrls.LOCAL ? isPathLocalRelative : isPathRelative;\n    return isRelative(path);\n};\ncontexts.Eval.prototype.rewritePath = function (path, rootpath) {\n    var newPath;\n    rootpath = rootpath || '';\n    newPath = this.normalizePath(rootpath + path);\n    // If a path was explicit relative and the rootpath was not an absolute path\n    // we must ensure that the new path is also explicit relative.\n    if (isPathLocalRelative(path) &&\n        isPathRelative(rootpath) &&\n        isPathLocalRelative(newPath) === false) {\n        newPath = \"./\" + newPath;\n    }\n    return newPath;\n};\ncontexts.Eval.prototype.normalizePath = function (path) {\n    var segments = path.split('/').reverse();\n    var segment;\n    path = [];\n    while (segments.length !== 0) {\n        segment = segments.pop();\n        switch (segment) {\n            case '.':\n                break;\n            case '..':\n                if ((path.length === 0) || (path[path.length - 1] === '..')) {\n                    path.push(segment);\n                }\n                else {\n                    path.pop();\n                }\n                break;\n            default:\n                path.push(segment);\n                break;\n        }\n    }\n    return path.join('/');\n};\nfunction isPathRelative(path) {\n    return !/^(?:[a-z-]+:|\\/|#)/i.test(path);\n}\nfunction isPathLocalRelative(path) {\n    return path.charAt(0) === '.';\n}\n// todo - do the same for the toCSS ?\n//# sourceMappingURL=contexts.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ImportSequencer = /** @class */ (function () {\n    function ImportSequencer(onSequencerEmpty) {\n        this.imports = [];\n        this.variableImports = [];\n        this._onSequencerEmpty = onSequencerEmpty;\n        this._currentDepth = 0;\n    }\n    ImportSequencer.prototype.addImport = function (callback) {\n        var importSequencer = this, importItem = {\n            callback: callback,\n            args: null,\n            isReady: false\n        };\n        this.imports.push(importItem);\n        return function () {\n            importItem.args = Array.prototype.slice.call(arguments, 0);\n            importItem.isReady = true;\n            importSequencer.tryRun();\n        };\n    };\n    ImportSequencer.prototype.addVariableImport = function (callback) {\n        this.variableImports.push(callback);\n    };\n    ImportSequencer.prototype.tryRun = function () {\n        this._currentDepth++;\n        try {\n            while (true) {\n                while (this.imports.length > 0) {\n                    var importItem = this.imports[0];\n                    if (!importItem.isReady) {\n                        return;\n                    }\n                    this.imports = this.imports.slice(1);\n                    importItem.callback.apply(null, importItem.args);\n                }\n                if (this.variableImports.length === 0) {\n                    break;\n                }\n                var variableImport = this.variableImports[0];\n                this.variableImports = this.variableImports.slice(1);\n                variableImport();\n            }\n        }\n        finally {\n            this._currentDepth--;\n        }\n        if (this._currentDepth === 0 && this._onSequencerEmpty) {\n            this._onSequencerEmpty();\n        }\n    };\n    return ImportSequencer;\n}());\nexports.default = ImportSequencer;\n//# sourceMappingURL=import-sequencer.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SetTreeVisibilityVisitor = /** @class */ (function () {\n    function SetTreeVisibilityVisitor(visible) {\n        this.visible = visible;\n    }\n    SetTreeVisibilityVisitor.prototype.run = function (root) {\n        this.visit(root);\n    };\n    SetTreeVisibilityVisitor.prototype.visitArray = function (nodes) {\n        if (!nodes) {\n            return nodes;\n        }\n        var cnt = nodes.length;\n        var i;\n        for (i = 0; i < cnt; i++) {\n            this.visit(nodes[i]);\n        }\n        return nodes;\n    };\n    SetTreeVisibilityVisitor.prototype.visit = function (node) {\n        if (!node) {\n            return node;\n        }\n        if (node.constructor === Array) {\n            return this.visitArray(node);\n        }\n        if (!node.blocksVisibility || node.blocksVisibility()) {\n            return node;\n        }\n        if (this.visible) {\n            node.ensureVisibility();\n        }\n        else {\n            node.ensureInvisibility();\n        }\n        node.accept(this);\n        return node;\n    };\n    return SetTreeVisibilityVisitor;\n}());\nexports.default = SetTreeVisibilityVisitor;\n//# sourceMappingURL=set-tree-visibility-visitor.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/* eslint-disable no-unused-vars */\n/**\n * @todo - Remove unused when JSDoc types are added for visitor methods\n */\nvar tree_1 = tslib_1.__importDefault(require(\"../tree\"));\nvar visitor_1 = tslib_1.__importDefault(require(\"./visitor\"));\nvar logger_1 = tslib_1.__importDefault(require(\"../logger\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\n/* jshint loopfunc:true */\nvar ExtendFinderVisitor = /** @class */ (function () {\n    function ExtendFinderVisitor() {\n        this._visitor = new visitor_1.default(this);\n        this.contexts = [];\n        this.allExtendsStack = [[]];\n    }\n    ExtendFinderVisitor.prototype.run = function (root) {\n        root = this._visitor.visit(root);\n        root.allExtends = this.allExtendsStack[0];\n        return root;\n    };\n    ExtendFinderVisitor.prototype.visitDeclaration = function (declNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    };\n    ExtendFinderVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    };\n    ExtendFinderVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {\n        if (rulesetNode.root) {\n            return;\n        }\n        var i;\n        var j;\n        var extend;\n        var allSelectorsExtendList = [];\n        var extendList;\n        // get &:extend(.a); rules which apply to all selectors in this ruleset\n        var rules = rulesetNode.rules, ruleCnt = rules ? rules.length : 0;\n        for (i = 0; i < ruleCnt; i++) {\n            if (rulesetNode.rules[i] instanceof tree_1.default.Extend) {\n                allSelectorsExtendList.push(rules[i]);\n                rulesetNode.extendOnEveryPath = true;\n            }\n        }\n        // now find every selector and apply the extends that apply to all extends\n        // and the ones which apply to an individual extend\n        var paths = rulesetNode.paths;\n        for (i = 0; i < paths.length; i++) {\n            var selectorPath = paths[i], selector = selectorPath[selectorPath.length - 1], selExtendList = selector.extendList;\n            extendList = selExtendList ? utils.copyArray(selExtendList).concat(allSelectorsExtendList)\n                : allSelectorsExtendList;\n            if (extendList) {\n                extendList = extendList.map(function (allSelectorsExtend) {\n                    return allSelectorsExtend.clone();\n                });\n            }\n            for (j = 0; j < extendList.length; j++) {\n                this.foundExtends = true;\n                extend = extendList[j];\n                extend.findSelfSelectors(selectorPath);\n                extend.ruleset = rulesetNode;\n                if (j === 0) {\n                    extend.firstExtendOnThisSelectorPath = true;\n                }\n                this.allExtendsStack[this.allExtendsStack.length - 1].push(extend);\n            }\n        }\n        this.contexts.push(rulesetNode.selectors);\n    };\n    ExtendFinderVisitor.prototype.visitRulesetOut = function (rulesetNode) {\n        if (!rulesetNode.root) {\n            this.contexts.length = this.contexts.length - 1;\n        }\n    };\n    ExtendFinderVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {\n        mediaNode.allExtends = [];\n        this.allExtendsStack.push(mediaNode.allExtends);\n    };\n    ExtendFinderVisitor.prototype.visitMediaOut = function (mediaNode) {\n        this.allExtendsStack.length = this.allExtendsStack.length - 1;\n    };\n    ExtendFinderVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {\n        atRuleNode.allExtends = [];\n        this.allExtendsStack.push(atRuleNode.allExtends);\n    };\n    ExtendFinderVisitor.prototype.visitAtRuleOut = function (atRuleNode) {\n        this.allExtendsStack.length = this.allExtendsStack.length - 1;\n    };\n    return ExtendFinderVisitor;\n}());\nvar ProcessExtendsVisitor = /** @class */ (function () {\n    function ProcessExtendsVisitor() {\n        this._visitor = new visitor_1.default(this);\n    }\n    ProcessExtendsVisitor.prototype.run = function (root) {\n        var extendFinder = new ExtendFinderVisitor();\n        this.extendIndices = {};\n        extendFinder.run(root);\n        if (!extendFinder.foundExtends) {\n            return root;\n        }\n        root.allExtends = root.allExtends.concat(this.doExtendChaining(root.allExtends, root.allExtends));\n        this.allExtendsStack = [root.allExtends];\n        var newRoot = this._visitor.visit(root);\n        this.checkExtendsForNonMatched(root.allExtends);\n        return newRoot;\n    };\n    ProcessExtendsVisitor.prototype.checkExtendsForNonMatched = function (extendList) {\n        var indices = this.extendIndices;\n        extendList.filter(function (extend) {\n            return !extend.hasFoundMatches && extend.parent_ids.length == 1;\n        }).forEach(function (extend) {\n            var selector = '_unknown_';\n            try {\n                selector = extend.selector.toCSS({});\n            }\n            catch (_) { }\n            if (!indices[extend.index + \" \" + selector]) {\n                indices[extend.index + \" \" + selector] = true;\n                logger_1.default.warn(\"extend '\" + selector + \"' has no matches\");\n            }\n        });\n    };\n    ProcessExtendsVisitor.prototype.doExtendChaining = function (extendsList, extendsListTarget, iterationCount) {\n        //\n        // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering\n        // and pasting the selector we would do normally, but we are also adding an extend with the same target selector\n        // this means this new extend can then go and alter other extends\n        //\n        // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors\n        // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already\n        // processed if we look at each selector at a time, as is done in visitRuleset\n        var extendIndex;\n        var targetExtendIndex;\n        var matches;\n        var extendsToAdd = [];\n        var newSelector;\n        var extendVisitor = this;\n        var selectorPath;\n        var extend;\n        var targetExtend;\n        var newExtend;\n        iterationCount = iterationCount || 0;\n        // loop through comparing every extend with every target extend.\n        // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place\n        // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one\n        // and the second is the target.\n        // the separation into two lists allows us to process a subset of chains with a bigger set, as is the\n        // case when processing media queries\n        for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {\n            for (targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++) {\n                extend = extendsList[extendIndex];\n                targetExtend = extendsListTarget[targetExtendIndex];\n                // look for circular references\n                if (extend.parent_ids.indexOf(targetExtend.object_id) >= 0) {\n                    continue;\n                }\n                // find a match in the target extends self selector (the bit before :extend)\n                selectorPath = [targetExtend.selfSelectors[0]];\n                matches = extendVisitor.findMatch(extend, selectorPath);\n                if (matches.length) {\n                    extend.hasFoundMatches = true;\n                    // we found a match, so for each self selector..\n                    extend.selfSelectors.forEach(function (selfSelector) {\n                        var info = targetExtend.visibilityInfo();\n                        // process the extend as usual\n                        newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector, extend.isVisible());\n                        // but now we create a new extend from it\n                        newExtend = new (tree_1.default.Extend)(targetExtend.selector, targetExtend.option, 0, targetExtend.fileInfo(), info);\n                        newExtend.selfSelectors = newSelector;\n                        // add the extend onto the list of extends for that selector\n                        newSelector[newSelector.length - 1].extendList = [newExtend];\n                        // record that we need to add it.\n                        extendsToAdd.push(newExtend);\n                        newExtend.ruleset = targetExtend.ruleset;\n                        // remember its parents for circular references\n                        newExtend.parent_ids = newExtend.parent_ids.concat(targetExtend.parent_ids, extend.parent_ids);\n                        // only process the selector once.. if we have :extend(.a,.b) then multiple\n                        // extends will look at the same selector path, so when extending\n                        // we know that any others will be duplicates in terms of what is added to the css\n                        if (targetExtend.firstExtendOnThisSelectorPath) {\n                            newExtend.firstExtendOnThisSelectorPath = true;\n                            targetExtend.ruleset.paths.push(newSelector);\n                        }\n                    });\n                }\n            }\n        }\n        if (extendsToAdd.length) {\n            // try to detect circular references to stop a stack overflow.\n            // may no longer be needed.\n            this.extendChainCount++;\n            if (iterationCount > 100) {\n                var selectorOne = '{unable to calculate}';\n                var selectorTwo = '{unable to calculate}';\n                try {\n                    selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();\n                    selectorTwo = extendsToAdd[0].selector.toCSS();\n                }\n                catch (e) { }\n                throw { message: \"extend circular reference detected. One of the circular extends is currently:\" + selectorOne + \":extend(\" + selectorTwo + \")\" };\n            }\n            // now process the new extends on the existing rules so that we can handle a extending b extending c extending\n            // d extending e...\n            return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount + 1));\n        }\n        else {\n            return extendsToAdd;\n        }\n    };\n    ProcessExtendsVisitor.prototype.visitDeclaration = function (ruleNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    };\n    ProcessExtendsVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    };\n    ProcessExtendsVisitor.prototype.visitSelector = function (selectorNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    };\n    ProcessExtendsVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {\n        if (rulesetNode.root) {\n            return;\n        }\n        var matches;\n        var pathIndex;\n        var extendIndex;\n        var allExtends = this.allExtendsStack[this.allExtendsStack.length - 1];\n        var selectorsToAdd = [];\n        var extendVisitor = this;\n        var selectorPath;\n        // look at each selector path in the ruleset, find any extend matches and then copy, find and replace\n        for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {\n            for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {\n                selectorPath = rulesetNode.paths[pathIndex];\n                // extending extends happens initially, before the main pass\n                if (rulesetNode.extendOnEveryPath) {\n                    continue;\n                }\n                var extendList = selectorPath[selectorPath.length - 1].extendList;\n                if (extendList && extendList.length) {\n                    continue;\n                }\n                matches = this.findMatch(allExtends[extendIndex], selectorPath);\n                if (matches.length) {\n                    allExtends[extendIndex].hasFoundMatches = true;\n                    allExtends[extendIndex].selfSelectors.forEach(function (selfSelector) {\n                        var extendedSelectors;\n                        extendedSelectors = extendVisitor.extendSelector(matches, selectorPath, selfSelector, allExtends[extendIndex].isVisible());\n                        selectorsToAdd.push(extendedSelectors);\n                    });\n                }\n            }\n        }\n        rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);\n    };\n    ProcessExtendsVisitor.prototype.findMatch = function (extend, haystackSelectorPath) {\n        //\n        // look through the haystack selector path to try and find the needle - extend.selector\n        // returns an array of selector matches that can then be replaced\n        //\n        var haystackSelectorIndex;\n        var hackstackSelector;\n        var hackstackElementIndex;\n        var haystackElement;\n        var targetCombinator;\n        var i;\n        var extendVisitor = this;\n        var needleElements = extend.selector.elements;\n        var potentialMatches = [];\n        var potentialMatch;\n        var matches = [];\n        // loop through the haystack elements\n        for (haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {\n            hackstackSelector = haystackSelectorPath[haystackSelectorIndex];\n            for (hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {\n                haystackElement = hackstackSelector.elements[hackstackElementIndex];\n                // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.\n                if (extend.allowBefore || (haystackSelectorIndex === 0 && hackstackElementIndex === 0)) {\n                    potentialMatches.push({ pathIndex: haystackSelectorIndex, index: hackstackElementIndex, matched: 0,\n                        initialCombinator: haystackElement.combinator });\n                }\n                for (i = 0; i < potentialMatches.length; i++) {\n                    potentialMatch = potentialMatches[i];\n                    // selectors add \" \" onto the first element. When we use & it joins the selectors together, but if we don't\n                    // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to\n                    // work out what the resulting combinator will be\n                    targetCombinator = haystackElement.combinator.value;\n                    if (targetCombinator === '' && hackstackElementIndex === 0) {\n                        targetCombinator = ' ';\n                    }\n                    // if we don't match, null our match to indicate failure\n                    if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) ||\n                        (potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator)) {\n                        potentialMatch = null;\n                    }\n                    else {\n                        potentialMatch.matched++;\n                    }\n                    // if we are still valid and have finished, test whether we have elements after and whether these are allowed\n                    if (potentialMatch) {\n                        potentialMatch.finished = potentialMatch.matched === needleElements.length;\n                        if (potentialMatch.finished &&\n                            (!extend.allowAfter &&\n                                (hackstackElementIndex + 1 < hackstackSelector.elements.length || haystackSelectorIndex + 1 < haystackSelectorPath.length))) {\n                            potentialMatch = null;\n                        }\n                    }\n                    // if null we remove, if not, we are still valid, so either push as a valid match or continue\n                    if (potentialMatch) {\n                        if (potentialMatch.finished) {\n                            potentialMatch.length = needleElements.length;\n                            potentialMatch.endPathIndex = haystackSelectorIndex;\n                            potentialMatch.endPathElementIndex = hackstackElementIndex + 1; // index after end of match\n                            potentialMatches.length = 0; // we don't allow matches to overlap, so start matching again\n                            matches.push(potentialMatch);\n                        }\n                    }\n                    else {\n                        potentialMatches.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n        }\n        return matches;\n    };\n    ProcessExtendsVisitor.prototype.isElementValuesEqual = function (elementValue1, elementValue2) {\n        if (typeof elementValue1 === 'string' || typeof elementValue2 === 'string') {\n            return elementValue1 === elementValue2;\n        }\n        if (elementValue1 instanceof tree_1.default.Attribute) {\n            if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {\n                return false;\n            }\n            if (!elementValue1.value || !elementValue2.value) {\n                if (elementValue1.value || elementValue2.value) {\n                    return false;\n                }\n                return true;\n            }\n            elementValue1 = elementValue1.value.value || elementValue1.value;\n            elementValue2 = elementValue2.value.value || elementValue2.value;\n            return elementValue1 === elementValue2;\n        }\n        elementValue1 = elementValue1.value;\n        elementValue2 = elementValue2.value;\n        if (elementValue1 instanceof tree_1.default.Selector) {\n            if (!(elementValue2 instanceof tree_1.default.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {\n                return false;\n            }\n            for (var i = 0; i < elementValue1.elements.length; i++) {\n                if (elementValue1.elements[i].combinator.value !== elementValue2.elements[i].combinator.value) {\n                    if (i !== 0 || (elementValue1.elements[i].combinator.value || ' ') !== (elementValue2.elements[i].combinator.value || ' ')) {\n                        return false;\n                    }\n                }\n                if (!this.isElementValuesEqual(elementValue1.elements[i].value, elementValue2.elements[i].value)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    ProcessExtendsVisitor.prototype.extendSelector = function (matches, selectorPath, replacementSelector, isVisible) {\n        // for a set of matches, replace each match with the replacement selector\n        var currentSelectorPathIndex = 0, currentSelectorPathElementIndex = 0, path = [], matchIndex, selector, firstElement, match, newElements;\n        for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {\n            match = matches[matchIndex];\n            selector = selectorPath[match.pathIndex];\n            firstElement = new tree_1.default.Element(match.initialCombinator, replacementSelector.elements[0].value, replacementSelector.elements[0].isVariable, replacementSelector.elements[0].getIndex(), replacementSelector.elements[0].fileInfo());\n            if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {\n                path[path.length - 1].elements = path[path.length - 1]\n                    .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));\n                currentSelectorPathElementIndex = 0;\n                currentSelectorPathIndex++;\n            }\n            newElements = selector.elements\n                .slice(currentSelectorPathElementIndex, match.index)\n                .concat([firstElement])\n                .concat(replacementSelector.elements.slice(1));\n            if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {\n                path[path.length - 1].elements =\n                    path[path.length - 1].elements.concat(newElements);\n            }\n            else {\n                path = path.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));\n                path.push(new tree_1.default.Selector(newElements));\n            }\n            currentSelectorPathIndex = match.endPathIndex;\n            currentSelectorPathElementIndex = match.endPathElementIndex;\n            if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {\n                currentSelectorPathElementIndex = 0;\n                currentSelectorPathIndex++;\n            }\n        }\n        if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {\n            path[path.length - 1].elements = path[path.length - 1]\n                .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));\n            currentSelectorPathIndex++;\n        }\n        path = path.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));\n        path = path.map(function (currentValue) {\n            // we can re-use elements here, because the visibility property matters only for selectors\n            var derived = currentValue.createDerived(currentValue.elements);\n            if (isVisible) {\n                derived.ensureVisibility();\n            }\n            else {\n                derived.ensureInvisibility();\n            }\n            return derived;\n        });\n        return path;\n    };\n    ProcessExtendsVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {\n        var newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);\n        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));\n        this.allExtendsStack.push(newAllExtends);\n    };\n    ProcessExtendsVisitor.prototype.visitMediaOut = function (mediaNode) {\n        var lastIndex = this.allExtendsStack.length - 1;\n        this.allExtendsStack.length = lastIndex;\n    };\n    ProcessExtendsVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {\n        var newAllExtends = atRuleNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);\n        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, atRuleNode.allExtends));\n        this.allExtendsStack.push(newAllExtends);\n    };\n    ProcessExtendsVisitor.prototype.visitAtRuleOut = function (atRuleNode) {\n        var lastIndex = this.allExtendsStack.length - 1;\n        this.allExtendsStack.length = lastIndex;\n    };\n    return ProcessExtendsVisitor;\n}());\nexports.default = ProcessExtendsVisitor;\n//# sourceMappingURL=extend-visitor.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/* eslint-disable no-unused-vars */\n/**\n * @todo - Remove unused when JSDoc types are added for visitor methods\n */\nvar visitor_1 = tslib_1.__importDefault(require(\"./visitor\"));\nvar JoinSelectorVisitor = /** @class */ (function () {\n    function JoinSelectorVisitor() {\n        this.contexts = [[]];\n        this._visitor = new visitor_1.default(this);\n    }\n    JoinSelectorVisitor.prototype.run = function (root) {\n        return this._visitor.visit(root);\n    };\n    JoinSelectorVisitor.prototype.visitDeclaration = function (declNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    };\n    JoinSelectorVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    };\n    JoinSelectorVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {\n        var context = this.contexts[this.contexts.length - 1];\n        var paths = [];\n        var selectors;\n        this.contexts.push(paths);\n        if (!rulesetNode.root) {\n            selectors = rulesetNode.selectors;\n            if (selectors) {\n                selectors = selectors.filter(function (selector) { return selector.getIsOutput(); });\n                rulesetNode.selectors = selectors.length ? selectors : (selectors = null);\n                if (selectors) {\n                    rulesetNode.joinSelectors(paths, context, selectors);\n                }\n            }\n            if (!selectors) {\n                rulesetNode.rules = null;\n            }\n            rulesetNode.paths = paths;\n        }\n    };\n    JoinSelectorVisitor.prototype.visitRulesetOut = function (rulesetNode) {\n        this.contexts.length = this.contexts.length - 1;\n    };\n    JoinSelectorVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {\n        var context = this.contexts[this.contexts.length - 1];\n        mediaNode.rules[0].root = (context.length === 0 || context[0].multiMedia);\n    };\n    JoinSelectorVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {\n        var context = this.contexts[this.contexts.length - 1];\n        if (atRuleNode.rules && atRuleNode.rules.length) {\n            atRuleNode.rules[0].root = (atRuleNode.isRooted || context.length === 0 || null);\n        }\n    };\n    return JoinSelectorVisitor;\n}());\nexports.default = JoinSelectorVisitor;\n//# sourceMappingURL=join-selector-visitor.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/* eslint-disable no-unused-vars */\n/**\n * @todo - Remove unused when JSDoc types are added for visitor methods\n */\nvar tree_1 = tslib_1.__importDefault(require(\"../tree\"));\nvar visitor_1 = tslib_1.__importDefault(require(\"./visitor\"));\nvar CSSVisitorUtils = /** @class */ (function () {\n    function CSSVisitorUtils(context) {\n        this._visitor = new visitor_1.default(this);\n        this._context = context;\n    }\n    CSSVisitorUtils.prototype.containsSilentNonBlockedChild = function (bodyRules) {\n        var rule;\n        if (!bodyRules) {\n            return false;\n        }\n        for (var r = 0; r < bodyRules.length; r++) {\n            rule = bodyRules[r];\n            if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {\n                // the atrule contains something that was referenced (likely by extend)\n                // therefore it needs to be shown in output too\n                return true;\n            }\n        }\n        return false;\n    };\n    CSSVisitorUtils.prototype.keepOnlyVisibleChilds = function (owner) {\n        if (owner && owner.rules) {\n            owner.rules = owner.rules.filter(function (thing) { return thing.isVisible(); });\n        }\n    };\n    CSSVisitorUtils.prototype.isEmpty = function (owner) {\n        return (owner && owner.rules)\n            ? (owner.rules.length === 0) : true;\n    };\n    CSSVisitorUtils.prototype.hasVisibleSelector = function (rulesetNode) {\n        return (rulesetNode && rulesetNode.paths)\n            ? (rulesetNode.paths.length > 0) : false;\n    };\n    CSSVisitorUtils.prototype.resolveVisibility = function (node) {\n        if (!node.blocksVisibility()) {\n            if (this.isEmpty(node)) {\n                return;\n            }\n            return node;\n        }\n        var compiledRulesBody = node.rules[0];\n        this.keepOnlyVisibleChilds(compiledRulesBody);\n        if (this.isEmpty(compiledRulesBody)) {\n            return;\n        }\n        node.ensureVisibility();\n        node.removeVisibilityBlock();\n        return node;\n    };\n    CSSVisitorUtils.prototype.isVisibleRuleset = function (rulesetNode) {\n        if (rulesetNode.firstRoot) {\n            return true;\n        }\n        if (this.isEmpty(rulesetNode)) {\n            return false;\n        }\n        if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {\n            return false;\n        }\n        return true;\n    };\n    return CSSVisitorUtils;\n}());\nvar ToCSSVisitor = function (context) {\n    this._visitor = new visitor_1.default(this);\n    this._context = context;\n    this.utils = new CSSVisitorUtils(context);\n};\nToCSSVisitor.prototype = {\n    isReplacing: true,\n    run: function (root) {\n        return this._visitor.visit(root);\n    },\n    visitDeclaration: function (declNode, visitArgs) {\n        if (declNode.blocksVisibility() || declNode.variable) {\n            return;\n        }\n        return declNode;\n    },\n    visitMixinDefinition: function (mixinNode, visitArgs) {\n        // mixin definitions do not get eval'd - this means they keep state\n        // so we have to clear that state here so it isn't used if toCSS is called twice\n        mixinNode.frames = [];\n    },\n    visitExtend: function (extendNode, visitArgs) {\n    },\n    visitComment: function (commentNode, visitArgs) {\n        if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {\n            return;\n        }\n        return commentNode;\n    },\n    visitMedia: function (mediaNode, visitArgs) {\n        var originalRules = mediaNode.rules[0].rules;\n        mediaNode.accept(this._visitor);\n        visitArgs.visitDeeper = false;\n        return this.utils.resolveVisibility(mediaNode, originalRules);\n    },\n    visitImport: function (importNode, visitArgs) {\n        if (importNode.blocksVisibility()) {\n            return;\n        }\n        return importNode;\n    },\n    visitAtRule: function (atRuleNode, visitArgs) {\n        if (atRuleNode.rules && atRuleNode.rules.length) {\n            return this.visitAtRuleWithBody(atRuleNode, visitArgs);\n        }\n        else {\n            return this.visitAtRuleWithoutBody(atRuleNode, visitArgs);\n        }\n    },\n    visitAnonymous: function (anonymousNode, visitArgs) {\n        if (!anonymousNode.blocksVisibility()) {\n            anonymousNode.accept(this._visitor);\n            return anonymousNode;\n        }\n    },\n    visitAtRuleWithBody: function (atRuleNode, visitArgs) {\n        // if there is only one nested ruleset and that one has no path, then it is\n        // just fake ruleset\n        function hasFakeRuleset(atRuleNode) {\n            var bodyRules = atRuleNode.rules;\n            return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);\n        }\n        function getBodyRules(atRuleNode) {\n            var nodeRules = atRuleNode.rules;\n            if (hasFakeRuleset(atRuleNode)) {\n                return nodeRules[0].rules;\n            }\n            return nodeRules;\n        }\n        // it is still true that it is only one ruleset in array\n        // this is last such moment\n        // process childs\n        var originalRules = getBodyRules(atRuleNode);\n        atRuleNode.accept(this._visitor);\n        visitArgs.visitDeeper = false;\n        if (!this.utils.isEmpty(atRuleNode)) {\n            this._mergeRules(atRuleNode.rules[0].rules);\n        }\n        return this.utils.resolveVisibility(atRuleNode, originalRules);\n    },\n    visitAtRuleWithoutBody: function (atRuleNode, visitArgs) {\n        if (atRuleNode.blocksVisibility()) {\n            return;\n        }\n        if (atRuleNode.name === '@charset') {\n            // Only output the debug info together with subsequent @charset definitions\n            // a comment (or @media statement) before the actual @charset atrule would\n            // be considered illegal css as it has to be on the first line\n            if (this.charset) {\n                if (atRuleNode.debugInfo) {\n                    var comment = new tree_1.default.Comment(\"/* \" + atRuleNode.toCSS(this._context).replace(/\\n/g, '') + \" */\\n\");\n                    comment.debugInfo = atRuleNode.debugInfo;\n                    return this._visitor.visit(comment);\n                }\n                return;\n            }\n            this.charset = true;\n        }\n        return atRuleNode;\n    },\n    checkValidNodes: function (rules, isRoot) {\n        if (!rules) {\n            return;\n        }\n        for (var i = 0; i < rules.length; i++) {\n            var ruleNode = rules[i];\n            if (isRoot && ruleNode instanceof tree_1.default.Declaration && !ruleNode.variable) {\n                throw { message: 'Properties must be inside selector blocks. They cannot be in the root',\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };\n            }\n            if (ruleNode instanceof tree_1.default.Call) {\n                throw { message: \"Function '\" + ruleNode.name + \"' did not return a root node\",\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };\n            }\n            if (ruleNode.type && !ruleNode.allowRoot) {\n                throw { message: ruleNode.type + \" node returned by a function is not valid here\",\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename };\n            }\n        }\n    },\n    visitRuleset: function (rulesetNode, visitArgs) {\n        // at this point rulesets are nested into each other\n        var rule;\n        var rulesets = [];\n        this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot);\n        if (!rulesetNode.root) {\n            // remove invisible paths\n            this._compileRulesetPaths(rulesetNode);\n            // remove rulesets from this ruleset body and compile them separately\n            var nodeRules = rulesetNode.rules;\n            var nodeRuleCnt = nodeRules ? nodeRules.length : 0;\n            for (var i = 0; i < nodeRuleCnt;) {\n                rule = nodeRules[i];\n                if (rule && rule.rules) {\n                    // visit because we are moving them out from being a child\n                    rulesets.push(this._visitor.visit(rule));\n                    nodeRules.splice(i, 1);\n                    nodeRuleCnt--;\n                    continue;\n                }\n                i++;\n            }\n            // accept the visitor to remove rules and refactor itself\n            // then we can decide nogw whether we want it or not\n            // compile body\n            if (nodeRuleCnt > 0) {\n                rulesetNode.accept(this._visitor);\n            }\n            else {\n                rulesetNode.rules = null;\n            }\n            visitArgs.visitDeeper = false;\n        }\n        else { // if (! rulesetNode.root) {\n            rulesetNode.accept(this._visitor);\n            visitArgs.visitDeeper = false;\n        }\n        if (rulesetNode.rules) {\n            this._mergeRules(rulesetNode.rules);\n            this._removeDuplicateRules(rulesetNode.rules);\n        }\n        // now decide whether we keep the ruleset\n        if (this.utils.isVisibleRuleset(rulesetNode)) {\n            rulesetNode.ensureVisibility();\n            rulesets.splice(0, 0, rulesetNode);\n        }\n        if (rulesets.length === 1) {\n            return rulesets[0];\n        }\n        return rulesets;\n    },\n    _compileRulesetPaths: function (rulesetNode) {\n        if (rulesetNode.paths) {\n            rulesetNode.paths = rulesetNode.paths\n                .filter(function (p) {\n                var i;\n                if (p[0].elements[0].combinator.value === ' ') {\n                    p[0].elements[0].combinator = new (tree_1.default.Combinator)('');\n                }\n                for (i = 0; i < p.length; i++) {\n                    if (p[i].isVisible() && p[i].getIsOutput()) {\n                        return true;\n                    }\n                }\n                return false;\n            });\n        }\n    },\n    _removeDuplicateRules: function (rules) {\n        if (!rules) {\n            return;\n        }\n        // remove duplicates\n        var ruleCache = {};\n        var ruleList;\n        var rule;\n        var i;\n        for (i = rules.length - 1; i >= 0; i--) {\n            rule = rules[i];\n            if (rule instanceof tree_1.default.Declaration) {\n                if (!ruleCache[rule.name]) {\n                    ruleCache[rule.name] = rule;\n                }\n                else {\n                    ruleList = ruleCache[rule.name];\n                    if (ruleList instanceof tree_1.default.Declaration) {\n                        ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];\n                    }\n                    var ruleCSS = rule.toCSS(this._context);\n                    if (ruleList.indexOf(ruleCSS) !== -1) {\n                        rules.splice(i, 1);\n                    }\n                    else {\n                        ruleList.push(ruleCSS);\n                    }\n                }\n            }\n        }\n    },\n    _mergeRules: function (rules) {\n        if (!rules) {\n            return;\n        }\n        var groups = {};\n        var groupsArr = [];\n        for (var i = 0; i < rules.length; i++) {\n            var rule = rules[i];\n            if (rule.merge) {\n                var key = rule.name;\n                groups[key] ? rules.splice(i--, 1) :\n                    groupsArr.push(groups[key] = []);\n                groups[key].push(rule);\n            }\n        }\n        groupsArr.forEach(function (group) {\n            if (group.length > 0) {\n                var result_1 = group[0];\n                var space_1 = [];\n                var comma_1 = [new tree_1.default.Expression(space_1)];\n                group.forEach(function (rule) {\n                    if ((rule.merge === '+') && (space_1.length > 0)) {\n                        comma_1.push(new tree_1.default.Expression(space_1 = []));\n                    }\n                    space_1.push(rule.value);\n                    result_1.important = result_1.important || rule.important;\n                });\n                result_1.value = new tree_1.default.Value(comma_1);\n            }\n        });\n    }\n};\nexports.default = ToCSSVisitor;\n//# sourceMappingURL=to-css-visitor.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar chunker_1 = tslib_1.__importDefault(require(\"./chunker\"));\nexports.default = (function () {\n    var // Less input string\n    input;\n    var // current chunk\n    j;\n    var // holds state for backtracking\n    saveStack = [];\n    var // furthest index the parser has gone to\n    furthest;\n    var // if this is furthest we got to, this is the probably cause\n    furthestPossibleErrorMessage;\n    var // chunkified input\n    chunks;\n    var // current chunk\n    current;\n    var // index of current chunk, in `input`\n    currentPos;\n    var parserInput = {};\n    var CHARCODE_SPACE = 32;\n    var CHARCODE_TAB = 9;\n    var CHARCODE_LF = 10;\n    var CHARCODE_CR = 13;\n    var CHARCODE_PLUS = 43;\n    var CHARCODE_COMMA = 44;\n    var CHARCODE_FORWARD_SLASH = 47;\n    var CHARCODE_9 = 57;\n    function skipWhitespace(length) {\n        var oldi = parserInput.i;\n        var oldj = j;\n        var curr = parserInput.i - currentPos;\n        var endIndex = parserInput.i + current.length - curr;\n        var mem = (parserInput.i += length);\n        var inp = input;\n        var c;\n        var nextChar;\n        var comment;\n        for (; parserInput.i < endIndex; parserInput.i++) {\n            c = inp.charCodeAt(parserInput.i);\n            if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {\n                nextChar = inp.charAt(parserInput.i + 1);\n                if (nextChar === '/') {\n                    comment = { index: parserInput.i, isLineComment: true };\n                    var nextNewLine = inp.indexOf('\\n', parserInput.i + 2);\n                    if (nextNewLine < 0) {\n                        nextNewLine = endIndex;\n                    }\n                    parserInput.i = nextNewLine;\n                    comment.text = inp.substr(comment.index, parserInput.i - comment.index);\n                    parserInput.commentStore.push(comment);\n                    continue;\n                }\n                else if (nextChar === '*') {\n                    var nextStarSlash = inp.indexOf('*/', parserInput.i + 2);\n                    if (nextStarSlash >= 0) {\n                        comment = {\n                            index: parserInput.i,\n                            text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),\n                            isLineComment: false\n                        };\n                        parserInput.i += comment.text.length - 1;\n                        parserInput.commentStore.push(comment);\n                        continue;\n                    }\n                }\n                break;\n            }\n            if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {\n                break;\n            }\n        }\n        current = current.slice(length + parserInput.i - mem + curr);\n        currentPos = parserInput.i;\n        if (!current.length) {\n            if (j < chunks.length - 1) {\n                current = chunks[++j];\n                skipWhitespace(0); // skip space at the beginning of a chunk\n                return true; // things changed\n            }\n            parserInput.finished = true;\n        }\n        return oldi !== parserInput.i || oldj !== j;\n    }\n    parserInput.save = function () {\n        currentPos = parserInput.i;\n        saveStack.push({ current: current, i: parserInput.i, j: j });\n    };\n    parserInput.restore = function (possibleErrorMessage) {\n        if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {\n            furthest = parserInput.i;\n            furthestPossibleErrorMessage = possibleErrorMessage;\n        }\n        var state = saveStack.pop();\n        current = state.current;\n        currentPos = parserInput.i = state.i;\n        j = state.j;\n    };\n    parserInput.forget = function () {\n        saveStack.pop();\n    };\n    parserInput.isWhitespace = function (offset) {\n        var pos = parserInput.i + (offset || 0);\n        var code = input.charCodeAt(pos);\n        return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);\n    };\n    // Specialization of $(tok)\n    parserInput.$re = function (tok) {\n        if (parserInput.i > currentPos) {\n            current = current.slice(parserInput.i - currentPos);\n            currentPos = parserInput.i;\n        }\n        var m = tok.exec(current);\n        if (!m) {\n            return null;\n        }\n        skipWhitespace(m[0].length);\n        if (typeof m === 'string') {\n            return m;\n        }\n        return m.length === 1 ? m[0] : m;\n    };\n    parserInput.$char = function (tok) {\n        if (input.charAt(parserInput.i) !== tok) {\n            return null;\n        }\n        skipWhitespace(1);\n        return tok;\n    };\n    parserInput.$peekChar = function (tok) {\n        if (input.charAt(parserInput.i) !== tok) {\n            return null;\n        }\n        return tok;\n    };\n    parserInput.$str = function (tok) {\n        var tokLength = tok.length;\n        // https://jsperf.com/string-startswith/21\n        for (var i = 0; i < tokLength; i++) {\n            if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                return null;\n            }\n        }\n        skipWhitespace(tokLength);\n        return tok;\n    };\n    parserInput.$quoted = function (loc) {\n        var pos = loc || parserInput.i;\n        var startChar = input.charAt(pos);\n        if (startChar !== '\\'' && startChar !== '\"') {\n            return;\n        }\n        var length = input.length;\n        var currentPosition = pos;\n        for (var i = 1; i + currentPosition < length; i++) {\n            var nextChar = input.charAt(i + currentPosition);\n            switch (nextChar) {\n                case '\\\\':\n                    i++;\n                    continue;\n                case '\\r':\n                case '\\n':\n                    break;\n                case startChar: {\n                    var str = input.substr(currentPosition, i + 1);\n                    if (!loc && loc !== 0) {\n                        skipWhitespace(i + 1);\n                        return str;\n                    }\n                    return [startChar, str];\n                }\n                default:\n            }\n        }\n        return null;\n    };\n    /**\n     * Permissive parsing. Ignores everything except matching {} [] () and quotes\n     * until matching token (outside of blocks)\n     */\n    parserInput.$parseUntil = function (tok) {\n        var quote = '';\n        var returnVal = null;\n        var inComment = false;\n        var blockDepth = 0;\n        var blockStack = [];\n        var parseGroups = [];\n        var length = input.length;\n        var startPos = parserInput.i;\n        var lastPos = parserInput.i;\n        var i = parserInput.i;\n        var loop = true;\n        var testChar;\n        if (typeof tok === 'string') {\n            testChar = function (char) { return char === tok; };\n        }\n        else {\n            testChar = function (char) { return tok.test(char); };\n        }\n        do {\n            var nextChar = input.charAt(i);\n            if (blockDepth === 0 && testChar(nextChar)) {\n                returnVal = input.substr(lastPos, i - lastPos);\n                if (returnVal) {\n                    parseGroups.push(returnVal);\n                }\n                else {\n                    parseGroups.push(' ');\n                }\n                returnVal = parseGroups;\n                skipWhitespace(i - startPos);\n                loop = false;\n            }\n            else {\n                if (inComment) {\n                    if (nextChar === '*' &&\n                        input.charAt(i + 1) === '/') {\n                        i++;\n                        blockDepth--;\n                        inComment = false;\n                    }\n                    i++;\n                    continue;\n                }\n                switch (nextChar) {\n                    case '\\\\':\n                        i++;\n                        nextChar = input.charAt(i);\n                        parseGroups.push(input.substr(lastPos, i - lastPos + 1));\n                        lastPos = i + 1;\n                        break;\n                    case '/':\n                        if (input.charAt(i + 1) === '*') {\n                            i++;\n                            inComment = true;\n                            blockDepth++;\n                        }\n                        break;\n                    case '\\'':\n                    case '\"':\n                        quote = parserInput.$quoted(i);\n                        if (quote) {\n                            parseGroups.push(input.substr(lastPos, i - lastPos), quote);\n                            i += quote[1].length - 1;\n                            lastPos = i + 1;\n                        }\n                        else {\n                            skipWhitespace(i - startPos);\n                            returnVal = nextChar;\n                            loop = false;\n                        }\n                        break;\n                    case '{':\n                        blockStack.push('}');\n                        blockDepth++;\n                        break;\n                    case '(':\n                        blockStack.push(')');\n                        blockDepth++;\n                        break;\n                    case '[':\n                        blockStack.push(']');\n                        blockDepth++;\n                        break;\n                    case '}':\n                    case ')':\n                    case ']': {\n                        var expected = blockStack.pop();\n                        if (nextChar === expected) {\n                            blockDepth--;\n                        }\n                        else {\n                            // move the parser to the error and return expected\n                            skipWhitespace(i - startPos);\n                            returnVal = expected;\n                            loop = false;\n                        }\n                    }\n                }\n                i++;\n                if (i > length) {\n                    loop = false;\n                }\n            }\n        } while (loop);\n        return returnVal ? returnVal : null;\n    };\n    parserInput.autoCommentAbsorb = true;\n    parserInput.commentStore = [];\n    parserInput.finished = false;\n    // Same as $(), but don't change the state of the parser,\n    // just return the match.\n    parserInput.peek = function (tok) {\n        if (typeof tok === 'string') {\n            // https://jsperf.com/string-startswith/21\n            for (var i = 0; i < tok.length; i++) {\n                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        else {\n            return tok.test(current);\n        }\n    };\n    // Specialization of peek()\n    // TODO remove or change some currentChar calls to peekChar\n    parserInput.peekChar = function (tok) { return input.charAt(parserInput.i) === tok; };\n    parserInput.currentChar = function () { return input.charAt(parserInput.i); };\n    parserInput.prevChar = function () { return input.charAt(parserInput.i - 1); };\n    parserInput.getInput = function () { return input; };\n    parserInput.peekNotNumeric = function () {\n        var c = input.charCodeAt(parserInput.i);\n        // Is the first char of the dimension 0-9, '.', '+' or '-'\n        return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;\n    };\n    parserInput.start = function (str, chunkInput, failFunction) {\n        input = str;\n        parserInput.i = j = currentPos = furthest = 0;\n        // chunking apparently makes things quicker (but my tests indicate\n        // it might actually make things slower in node at least)\n        // and it is a non-perfect parse - it can't recognise\n        // unquoted urls, meaning it can't distinguish comments\n        // meaning comments with quotes or {}() in them get 'counted'\n        // and then lead to parse errors.\n        // In addition if the chunking chunks in the wrong place we might\n        // not be able to parse a parser statement in one go\n        // this is officially deprecated but can be switched on via an option\n        // in the case it causes too much performance issues.\n        if (chunkInput) {\n            chunks = chunker_1.default(str, failFunction);\n        }\n        else {\n            chunks = [str];\n        }\n        current = chunks[0];\n        skipWhitespace(0);\n    };\n    parserInput.end = function () {\n        var message;\n        var isFinished = parserInput.i >= input.length;\n        if (parserInput.i < furthest) {\n            message = furthestPossibleErrorMessage;\n            parserInput.i = furthest;\n        }\n        return {\n            isFinished: isFinished,\n            furthest: parserInput.i,\n            furthestPossibleErrorMessage: message,\n            furthestReachedEnd: parserInput.i >= input.length - 1,\n            furthestChar: input[parserInput.i]\n        };\n    };\n    return parserInput;\n});\n//# sourceMappingURL=parser-input.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Split the input into chunks.\nfunction default_1(input, fail) {\n    var len = input.length;\n    var level = 0;\n    var parenLevel = 0;\n    var lastOpening;\n    var lastOpeningParen;\n    var lastMultiComment;\n    var lastMultiCommentEndBrace;\n    var chunks = [];\n    var emitFrom = 0;\n    var chunkerCurrentIndex;\n    var currentChunkStartIndex;\n    var cc;\n    var cc2;\n    var matched;\n    function emitChunk(force) {\n        var len = chunkerCurrentIndex - emitFrom;\n        if (((len < 512) && !force) || !len) {\n            return;\n        }\n        chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));\n        emitFrom = chunkerCurrentIndex + 1;\n    }\n    for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n        cc = input.charCodeAt(chunkerCurrentIndex);\n        if (((cc >= 97) && (cc <= 122)) || (cc < 34)) {\n            // a-z or whitespace\n            continue;\n        }\n        switch (cc) {\n            case 40: // (\n                parenLevel++;\n                lastOpeningParen = chunkerCurrentIndex;\n                continue;\n            case 41: // )\n                if (--parenLevel < 0) {\n                    return fail('missing opening `(`', chunkerCurrentIndex);\n                }\n                continue;\n            case 59: // ;\n                if (!parenLevel) {\n                    emitChunk();\n                }\n                continue;\n            case 123: // {\n                level++;\n                lastOpening = chunkerCurrentIndex;\n                continue;\n            case 125: // }\n                if (--level < 0) {\n                    return fail('missing opening `{`', chunkerCurrentIndex);\n                }\n                if (!level && !parenLevel) {\n                    emitChunk();\n                }\n                continue;\n            case 92: // \\\n                if (chunkerCurrentIndex < len - 1) {\n                    chunkerCurrentIndex++;\n                    continue;\n                }\n                return fail('unescaped `\\\\`', chunkerCurrentIndex);\n            case 34:\n            case 39:\n            case 96: // \", ' and `\n                matched = 0;\n                currentChunkStartIndex = chunkerCurrentIndex;\n                for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n                    cc2 = input.charCodeAt(chunkerCurrentIndex);\n                    if (cc2 > 96) {\n                        continue;\n                    }\n                    if (cc2 == cc) {\n                        matched = 1;\n                        break;\n                    }\n                    if (cc2 == 92) { // \\\n                        if (chunkerCurrentIndex == len - 1) {\n                            return fail('unescaped `\\\\`', chunkerCurrentIndex);\n                        }\n                        chunkerCurrentIndex++;\n                    }\n                }\n                if (matched) {\n                    continue;\n                }\n                return fail(\"unmatched `\" + String.fromCharCode(cc) + \"`\", currentChunkStartIndex);\n            case 47: // /, check for comment\n                if (parenLevel || (chunkerCurrentIndex == len - 1)) {\n                    continue;\n                }\n                cc2 = input.charCodeAt(chunkerCurrentIndex + 1);\n                if (cc2 == 47) {\n                    // //, find lnfeed\n                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n                        cc2 = input.charCodeAt(chunkerCurrentIndex);\n                        if ((cc2 <= 13) && ((cc2 == 10) || (cc2 == 13))) {\n                            break;\n                        }\n                    }\n                }\n                else if (cc2 == 42) {\n                    // /*, find */\n                    lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;\n                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {\n                        cc2 = input.charCodeAt(chunkerCurrentIndex);\n                        if (cc2 == 125) {\n                            lastMultiCommentEndBrace = chunkerCurrentIndex;\n                        }\n                        if (cc2 != 42) {\n                            continue;\n                        }\n                        if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) {\n                            break;\n                        }\n                    }\n                    if (chunkerCurrentIndex == len - 1) {\n                        return fail('missing closing `*/`', currentChunkStartIndex);\n                    }\n                    chunkerCurrentIndex++;\n                }\n                continue;\n            case 42: // *, check for unmatched */\n                if ((chunkerCurrentIndex < len - 1) && (input.charCodeAt(chunkerCurrentIndex + 1) == 47)) {\n                    return fail('unmatched `/*`', chunkerCurrentIndex);\n                }\n                continue;\n        }\n    }\n    if (level !== 0) {\n        if ((lastMultiComment > lastOpening) && (lastMultiCommentEndBrace > lastMultiComment)) {\n            return fail('missing closing `}` or `*/`', lastOpening);\n        }\n        else {\n            return fail('missing closing `}`', lastOpening);\n        }\n    }\n    else if (parenLevel !== 0) {\n        return fail('missing closing `)`', lastOpeningParen);\n    }\n    emitChunk(true);\n    return chunks;\n}\nexports.default = default_1;\n//# sourceMappingURL=chunker.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction makeRegistry(base) {\n    return {\n        _data: {},\n        add: function (name, func) {\n            // precautionary case conversion, as later querying of\n            // the registry by function-caller uses lower case as well.\n            name = name.toLowerCase();\n            // eslint-disable-next-line no-prototype-builtins\n            if (this._data.hasOwnProperty(name)) {\n                // TODO warn\n            }\n            this._data[name] = func;\n        },\n        addMultiple: function (functions) {\n            var _this = this;\n            Object.keys(functions).forEach(function (name) {\n                _this.add(name, functions[name]);\n            });\n        },\n        get: function (name) {\n            return this._data[name] || (base && base.get(name));\n        },\n        getLocalFunctions: function () {\n            return this._data;\n        },\n        inherit: function () {\n            return makeRegistry(this);\n        },\n        create: function (base) {\n            return makeRegistry(base);\n        }\n    };\n}\nexports.default = makeRegistry(null);\n//# sourceMappingURL=function-registry.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerSyntaxOptions = exports.MediaSyntaxOptions = void 0;\nexports.MediaSyntaxOptions = {\n    queryInParens: true\n};\nexports.ContainerSyntaxOptions = {\n    queryInParens: true\n};\n//# sourceMappingURL=atrule-syntax.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar declaration_1 = tslib_1.__importDefault(require(\"./declaration\"));\nvar keyword_1 = tslib_1.__importDefault(require(\"./keyword\"));\nvar comment_1 = tslib_1.__importDefault(require(\"./comment\"));\nvar paren_1 = tslib_1.__importDefault(require(\"./paren\"));\nvar selector_1 = tslib_1.__importDefault(require(\"./selector\"));\nvar element_1 = tslib_1.__importDefault(require(\"./element\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"./anonymous\"));\nvar contexts_1 = tslib_1.__importDefault(require(\"../contexts\"));\nvar function_registry_1 = tslib_1.__importDefault(require(\"../functions/function-registry\"));\nvar default_1 = tslib_1.__importDefault(require(\"../functions/default\"));\nvar debug_info_1 = tslib_1.__importDefault(require(\"./debug-info\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\nvar parser_1 = tslib_1.__importDefault(require(\"../parser/parser\"));\nvar Ruleset = function (selectors, rules, strictImports, visibilityInfo) {\n    this.selectors = selectors;\n    this.rules = rules;\n    this._lookups = {};\n    this._variables = null;\n    this._properties = null;\n    this.strictImports = strictImports;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n    this.setParent(this.selectors, this);\n    this.setParent(this.rules, this);\n};\nRuleset.prototype = Object.assign(new node_1.default(), {\n    type: 'Ruleset',\n    isRuleset: true,\n    isRulesetLike: function () { return true; },\n    accept: function (visitor) {\n        if (this.paths) {\n            this.paths = visitor.visitArray(this.paths, true);\n        }\n        else if (this.selectors) {\n            this.selectors = visitor.visitArray(this.selectors);\n        }\n        if (this.rules && this.rules.length) {\n            this.rules = visitor.visitArray(this.rules);\n        }\n    },\n    eval: function (context) {\n        var selectors;\n        var selCnt;\n        var selector;\n        var i;\n        var hasVariable;\n        var hasOnePassingSelector = false;\n        if (this.selectors && (selCnt = this.selectors.length)) {\n            selectors = new Array(selCnt);\n            default_1.default.error({\n                type: 'Syntax',\n                message: 'it is currently only allowed in parametric mixin guards,'\n            });\n            for (i = 0; i < selCnt; i++) {\n                selector = this.selectors[i].eval(context);\n                for (var j = 0; j < selector.elements.length; j++) {\n                    if (selector.elements[j].isVariable) {\n                        hasVariable = true;\n                        break;\n                    }\n                }\n                selectors[i] = selector;\n                if (selector.evaldCondition) {\n                    hasOnePassingSelector = true;\n                }\n            }\n            if (hasVariable) {\n                var toParseSelectors = new Array(selCnt);\n                for (i = 0; i < selCnt; i++) {\n                    selector = selectors[i];\n                    toParseSelectors[i] = selector.toCSS(context);\n                }\n                var startingIndex = selectors[0].getIndex();\n                var selectorFileInfo = selectors[0].fileInfo();\n                new parser_1.default(context, this.parse.importManager, selectorFileInfo, startingIndex).parseNode(toParseSelectors.join(','), ['selectors'], function (err, result) {\n                    if (result) {\n                        selectors = utils.flattenArray(result);\n                    }\n                });\n            }\n            default_1.default.reset();\n        }\n        else {\n            hasOnePassingSelector = true;\n        }\n        var rules = this.rules ? utils.copyArray(this.rules) : null;\n        var ruleset = new Ruleset(selectors, rules, this.strictImports, this.visibilityInfo());\n        var rule;\n        var subRule;\n        ruleset.originalRuleset = this;\n        ruleset.root = this.root;\n        ruleset.firstRoot = this.firstRoot;\n        ruleset.allowImports = this.allowImports;\n        if (this.debugInfo) {\n            ruleset.debugInfo = this.debugInfo;\n        }\n        if (!hasOnePassingSelector) {\n            rules.length = 0;\n        }\n        // inherit a function registry from the frames stack when possible;\n        // otherwise from the global registry\n        ruleset.functionRegistry = (function (frames) {\n            var i = 0;\n            var n = frames.length;\n            var found;\n            for (; i !== n; ++i) {\n                found = frames[i].functionRegistry;\n                if (found) {\n                    return found;\n                }\n            }\n            return function_registry_1.default;\n        }(context.frames)).inherit();\n        // push the current ruleset to the frames stack\n        var ctxFrames = context.frames;\n        ctxFrames.unshift(ruleset);\n        // currrent selectors\n        var ctxSelectors = context.selectors;\n        if (!ctxSelectors) {\n            context.selectors = ctxSelectors = [];\n        }\n        ctxSelectors.unshift(this.selectors);\n        // Evaluate imports\n        if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {\n            ruleset.evalImports(context);\n        }\n        // Store the frames around mixin definitions,\n        // so they can be evaluated like closures when the time comes.\n        var rsRules = ruleset.rules;\n        for (i = 0; (rule = rsRules[i]); i++) {\n            if (rule.evalFirst) {\n                rsRules[i] = rule.eval(context);\n            }\n        }\n        var mediaBlockCount = (context.mediaBlocks && context.mediaBlocks.length) || 0;\n        // Evaluate mixin calls.\n        for (i = 0; (rule = rsRules[i]); i++) {\n            if (rule.type === 'MixinCall') {\n                /* jshint loopfunc:true */\n                rules = rule.eval(context).filter(function (r) {\n                    if ((r instanceof declaration_1.default) && r.variable) {\n                        // do not pollute the scope if the variable is\n                        // already there. consider returning false here\n                        // but we need a way to \"return\" variable from mixins\n                        return !(ruleset.variable(r.name));\n                    }\n                    return true;\n                });\n                rsRules.splice.apply(rsRules, [i, 1].concat(rules));\n                i += rules.length - 1;\n                ruleset.resetCache();\n            }\n            else if (rule.type === 'VariableCall') {\n                /* jshint loopfunc:true */\n                rules = rule.eval(context).rules.filter(function (r) {\n                    if ((r instanceof declaration_1.default) && r.variable) {\n                        // do not pollute the scope at all\n                        return false;\n                    }\n                    return true;\n                });\n                rsRules.splice.apply(rsRules, [i, 1].concat(rules));\n                i += rules.length - 1;\n                ruleset.resetCache();\n            }\n        }\n        // Evaluate everything else\n        for (i = 0; (rule = rsRules[i]); i++) {\n            if (!rule.evalFirst) {\n                rsRules[i] = rule = rule.eval ? rule.eval(context) : rule;\n            }\n        }\n        // Evaluate everything else\n        for (i = 0; (rule = rsRules[i]); i++) {\n            // for rulesets, check if it is a css guard and can be removed\n            if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {\n                // check if it can be folded in (e.g. & where)\n                if (rule.selectors[0] && rule.selectors[0].isJustParentSelector()) {\n                    rsRules.splice(i--, 1);\n                    for (var j = 0; (subRule = rule.rules[j]); j++) {\n                        if (subRule instanceof node_1.default) {\n                            subRule.copyVisibilityInfo(rule.visibilityInfo());\n                            if (!(subRule instanceof declaration_1.default) || !subRule.variable) {\n                                rsRules.splice(++i, 0, subRule);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // Pop the stack\n        ctxFrames.shift();\n        ctxSelectors.shift();\n        if (context.mediaBlocks) {\n            for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {\n                context.mediaBlocks[i].bubbleSelectors(selectors);\n            }\n        }\n        return ruleset;\n    },\n    evalImports: function (context) {\n        var rules = this.rules;\n        var i;\n        var importRules;\n        if (!rules) {\n            return;\n        }\n        for (i = 0; i < rules.length; i++) {\n            if (rules[i].type === 'Import') {\n                importRules = rules[i].eval(context);\n                if (importRules && (importRules.length || importRules.length === 0)) {\n                    rules.splice.apply(rules, [i, 1].concat(importRules));\n                    i += importRules.length - 1;\n                }\n                else {\n                    rules.splice(i, 1, importRules);\n                }\n                this.resetCache();\n            }\n        }\n    },\n    makeImportant: function () {\n        var result = new Ruleset(this.selectors, this.rules.map(function (r) {\n            if (r.makeImportant) {\n                return r.makeImportant();\n            }\n            else {\n                return r;\n            }\n        }), this.strictImports, this.visibilityInfo());\n        return result;\n    },\n    matchArgs: function (args) {\n        return !args || args.length === 0;\n    },\n    // lets you call a css selector with a guard\n    matchCondition: function (args, context) {\n        var lastSelector = this.selectors[this.selectors.length - 1];\n        if (!lastSelector.evaldCondition) {\n            return false;\n        }\n        if (lastSelector.condition &&\n            !lastSelector.condition.eval(new contexts_1.default.Eval(context, context.frames))) {\n            return false;\n        }\n        return true;\n    },\n    resetCache: function () {\n        this._rulesets = null;\n        this._variables = null;\n        this._properties = null;\n        this._lookups = {};\n    },\n    variables: function () {\n        if (!this._variables) {\n            this._variables = !this.rules ? {} : this.rules.reduce(function (hash, r) {\n                if (r instanceof declaration_1.default && r.variable === true) {\n                    hash[r.name] = r;\n                }\n                // when evaluating variables in an import statement, imports have not been eval'd\n                // so we need to go inside import statements.\n                // guard against root being a string (in the case of inlined less)\n                if (r.type === 'Import' && r.root && r.root.variables) {\n                    var vars = r.root.variables();\n                    for (var name_1 in vars) {\n                        // eslint-disable-next-line no-prototype-builtins\n                        if (vars.hasOwnProperty(name_1)) {\n                            hash[name_1] = r.root.variable(name_1);\n                        }\n                    }\n                }\n                return hash;\n            }, {});\n        }\n        return this._variables;\n    },\n    properties: function () {\n        if (!this._properties) {\n            this._properties = !this.rules ? {} : this.rules.reduce(function (hash, r) {\n                if (r instanceof declaration_1.default && r.variable !== true) {\n                    var name_2 = (r.name.length === 1) && (r.name[0] instanceof keyword_1.default) ?\n                        r.name[0].value : r.name;\n                    // Properties don't overwrite as they can merge\n                    if (!hash[\"$\" + name_2]) {\n                        hash[\"$\" + name_2] = [r];\n                    }\n                    else {\n                        hash[\"$\" + name_2].push(r);\n                    }\n                }\n                return hash;\n            }, {});\n        }\n        return this._properties;\n    },\n    variable: function (name) {\n        var decl = this.variables()[name];\n        if (decl) {\n            return this.parseValue(decl);\n        }\n    },\n    property: function (name) {\n        var decl = this.properties()[name];\n        if (decl) {\n            return this.parseValue(decl);\n        }\n    },\n    lastDeclaration: function () {\n        for (var i = this.rules.length; i > 0; i--) {\n            var decl = this.rules[i - 1];\n            if (decl instanceof declaration_1.default) {\n                return this.parseValue(decl);\n            }\n        }\n    },\n    parseValue: function (toParse) {\n        var self = this;\n        function transformDeclaration(decl) {\n            if (decl.value instanceof anonymous_1.default && !decl.parsed) {\n                if (typeof decl.value.value === 'string') {\n                    new parser_1.default(this.parse.context, this.parse.importManager, decl.fileInfo(), decl.value.getIndex()).parseNode(decl.value.value, ['value', 'important'], function (err, result) {\n                        if (err) {\n                            decl.parsed = true;\n                        }\n                        if (result) {\n                            decl.value = result[0];\n                            decl.important = result[1] || '';\n                            decl.parsed = true;\n                        }\n                    });\n                }\n                else {\n                    decl.parsed = true;\n                }\n                return decl;\n            }\n            else {\n                return decl;\n            }\n        }\n        if (!Array.isArray(toParse)) {\n            return transformDeclaration.call(self, toParse);\n        }\n        else {\n            var nodes_1 = [];\n            toParse.forEach(function (n) {\n                nodes_1.push(transformDeclaration.call(self, n));\n            });\n            return nodes_1;\n        }\n    },\n    rulesets: function () {\n        if (!this.rules) {\n            return [];\n        }\n        var filtRules = [];\n        var rules = this.rules;\n        var i;\n        var rule;\n        for (i = 0; (rule = rules[i]); i++) {\n            if (rule.isRuleset) {\n                filtRules.push(rule);\n            }\n        }\n        return filtRules;\n    },\n    prependRule: function (rule) {\n        var rules = this.rules;\n        if (rules) {\n            rules.unshift(rule);\n        }\n        else {\n            this.rules = [rule];\n        }\n        this.setParent(rule, this);\n    },\n    find: function (selector, self, filter) {\n        self = self || this;\n        var rules = [];\n        var match;\n        var foundMixins;\n        var key = selector.toCSS();\n        if (key in this._lookups) {\n            return this._lookups[key];\n        }\n        this.rulesets().forEach(function (rule) {\n            if (rule !== self) {\n                for (var j = 0; j < rule.selectors.length; j++) {\n                    match = selector.match(rule.selectors[j]);\n                    if (match) {\n                        if (selector.elements.length > match) {\n                            if (!filter || filter(rule)) {\n                                foundMixins = rule.find(new selector_1.default(selector.elements.slice(match)), self, filter);\n                                for (var i = 0; i < foundMixins.length; ++i) {\n                                    foundMixins[i].path.push(rule);\n                                }\n                                Array.prototype.push.apply(rules, foundMixins);\n                            }\n                        }\n                        else {\n                            rules.push({ rule: rule, path: [] });\n                        }\n                        break;\n                    }\n                }\n            }\n        });\n        this._lookups[key] = rules;\n        return rules;\n    },\n    genCSS: function (context, output) {\n        var i;\n        var j;\n        var charsetRuleNodes = [];\n        var ruleNodes = [];\n        var // Line number debugging\n        debugInfo;\n        var rule;\n        var path;\n        context.tabLevel = (context.tabLevel || 0);\n        if (!this.root) {\n            context.tabLevel++;\n        }\n        var tabRuleStr = context.compress ? '' : Array(context.tabLevel + 1).join('  ');\n        var tabSetStr = context.compress ? '' : Array(context.tabLevel).join('  ');\n        var sep;\n        var charsetNodeIndex = 0;\n        var importNodeIndex = 0;\n        for (i = 0; (rule = this.rules[i]); i++) {\n            if (rule instanceof comment_1.default) {\n                if (importNodeIndex === i) {\n                    importNodeIndex++;\n                }\n                ruleNodes.push(rule);\n            }\n            else if (rule.isCharset && rule.isCharset()) {\n                ruleNodes.splice(charsetNodeIndex, 0, rule);\n                charsetNodeIndex++;\n                importNodeIndex++;\n            }\n            else if (rule.type === 'Import') {\n                ruleNodes.splice(importNodeIndex, 0, rule);\n                importNodeIndex++;\n            }\n            else {\n                ruleNodes.push(rule);\n            }\n        }\n        ruleNodes = charsetRuleNodes.concat(ruleNodes);\n        // If this is the root node, we don't render\n        // a selector, or {}.\n        if (!this.root) {\n            debugInfo = debug_info_1.default(context, this, tabSetStr);\n            if (debugInfo) {\n                output.add(debugInfo);\n                output.add(tabSetStr);\n            }\n            var paths = this.paths;\n            var pathCnt = paths.length;\n            var pathSubCnt = void 0;\n            sep = context.compress ? ',' : (\",\\n\" + tabSetStr);\n            for (i = 0; i < pathCnt; i++) {\n                path = paths[i];\n                if (!(pathSubCnt = path.length)) {\n                    continue;\n                }\n                if (i > 0) {\n                    output.add(sep);\n                }\n                context.firstSelector = true;\n                path[0].genCSS(context, output);\n                context.firstSelector = false;\n                for (j = 1; j < pathSubCnt; j++) {\n                    path[j].genCSS(context, output);\n                }\n            }\n            output.add((context.compress ? '{' : ' {\\n') + tabRuleStr);\n        }\n        // Compile rules and rulesets\n        for (i = 0; (rule = ruleNodes[i]); i++) {\n            if (i + 1 === ruleNodes.length) {\n                context.lastRule = true;\n            }\n            var currentLastRule = context.lastRule;\n            if (rule.isRulesetLike(rule)) {\n                context.lastRule = false;\n            }\n            if (rule.genCSS) {\n                rule.genCSS(context, output);\n            }\n            else if (rule.value) {\n                output.add(rule.value.toString());\n            }\n            context.lastRule = currentLastRule;\n            if (!context.lastRule && rule.isVisible()) {\n                output.add(context.compress ? '' : (\"\\n\" + tabRuleStr));\n            }\n            else {\n                context.lastRule = false;\n            }\n        }\n        if (!this.root) {\n            output.add((context.compress ? '}' : \"\\n\" + tabSetStr + \"}\"));\n            context.tabLevel--;\n        }\n        if (!output.isEmpty() && !context.compress && this.firstRoot) {\n            output.add('\\n');\n        }\n    },\n    joinSelectors: function (paths, context, selectors) {\n        for (var s = 0; s < selectors.length; s++) {\n            this.joinSelector(paths, context, selectors[s]);\n        }\n    },\n    joinSelector: function (paths, context, selector) {\n        function createParenthesis(elementsToPak, originalElement) {\n            var replacementParen, j;\n            if (elementsToPak.length === 0) {\n                replacementParen = new paren_1.default(elementsToPak[0]);\n            }\n            else {\n                var insideParent = new Array(elementsToPak.length);\n                for (j = 0; j < elementsToPak.length; j++) {\n                    insideParent[j] = new element_1.default(null, elementsToPak[j], originalElement.isVariable, originalElement._index, originalElement._fileInfo);\n                }\n                replacementParen = new paren_1.default(new selector_1.default(insideParent));\n            }\n            return replacementParen;\n        }\n        function createSelector(containedElement, originalElement) {\n            var element, selector;\n            element = new element_1.default(null, containedElement, originalElement.isVariable, originalElement._index, originalElement._fileInfo);\n            selector = new selector_1.default([element]);\n            return selector;\n        }\n        // joins selector path from `beginningPath` with selector path in `addPath`\n        // `replacedElement` contains element that is being replaced by `addPath`\n        // returns concatenated path\n        function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {\n            var newSelectorPath, lastSelector, newJoinedSelector;\n            // our new selector path\n            newSelectorPath = [];\n            // construct the joined selector - if & is the first thing this will be empty,\n            // if not newJoinedSelector will be the last set of elements in the selector\n            if (beginningPath.length > 0) {\n                newSelectorPath = utils.copyArray(beginningPath);\n                lastSelector = newSelectorPath.pop();\n                newJoinedSelector = originalSelector.createDerived(utils.copyArray(lastSelector.elements));\n            }\n            else {\n                newJoinedSelector = originalSelector.createDerived([]);\n            }\n            if (addPath.length > 0) {\n                // /deep/ is a CSS4 selector - (removed, so should deprecate)\n                // that is valid without anything in front of it\n                // so if the & does not have a combinator that is \"\" or \" \" then\n                // and there is a combinator on the parent, then grab that.\n                // this also allows + a { & .b { .a & { ... though not sure why you would want to do that\n                var combinator = replacedElement.combinator;\n                var parentEl = addPath[0].elements[0];\n                if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {\n                    combinator = parentEl.combinator;\n                }\n                // join the elements so far with the first part of the parent\n                newJoinedSelector.elements.push(new element_1.default(combinator, parentEl.value, replacedElement.isVariable, replacedElement._index, replacedElement._fileInfo));\n                newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));\n            }\n            // now add the joined selector - but only if it is not empty\n            if (newJoinedSelector.elements.length !== 0) {\n                newSelectorPath.push(newJoinedSelector);\n            }\n            // put together the parent selectors after the join (e.g. the rest of the parent)\n            if (addPath.length > 1) {\n                var restOfPath = addPath.slice(1);\n                restOfPath = restOfPath.map(function (selector) {\n                    return selector.createDerived(selector.elements, []);\n                });\n                newSelectorPath = newSelectorPath.concat(restOfPath);\n            }\n            return newSelectorPath;\n        }\n        // joins selector path from `beginningPath` with every selector path in `addPaths` array\n        // `replacedElement` contains element that is being replaced by `addPath`\n        // returns array with all concatenated paths\n        function addAllReplacementsIntoPath(beginningPath, addPaths, replacedElement, originalSelector, result) {\n            var j;\n            for (j = 0; j < beginningPath.length; j++) {\n                var newSelectorPath = addReplacementIntoPath(beginningPath[j], addPaths, replacedElement, originalSelector);\n                result.push(newSelectorPath);\n            }\n            return result;\n        }\n        function mergeElementsOnToSelectors(elements, selectors) {\n            var i, sel;\n            if (elements.length === 0) {\n                return;\n            }\n            if (selectors.length === 0) {\n                selectors.push([new selector_1.default(elements)]);\n                return;\n            }\n            for (i = 0; (sel = selectors[i]); i++) {\n                // if the previous thing in sel is a parent this needs to join on to it\n                if (sel.length > 0) {\n                    sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));\n                }\n                else {\n                    sel.push(new selector_1.default(elements));\n                }\n            }\n        }\n        // replace all parent selectors inside `inSelector` by content of `context` array\n        // resulting selectors are returned inside `paths` array\n        // returns true if `inSelector` contained at least one parent selector\n        function replaceParentSelector(paths, context, inSelector) {\n            // The paths are [[Selector]]\n            // The first list is a list of comma separated selectors\n            // The inner list is a list of inheritance separated selectors\n            // e.g.\n            // .a, .b {\n            //   .c {\n            //   }\n            // }\n            // == [[.a] [.c]] [[.b] [.c]]\n            //\n            var i, j, k, currentElements, newSelectors, selectorsMultiplied, sel, el, hadParentSelector = false, length, lastSelector;\n            function findNestedSelector(element) {\n                var maybeSelector;\n                if (!(element.value instanceof paren_1.default)) {\n                    return null;\n                }\n                maybeSelector = element.value.value;\n                if (!(maybeSelector instanceof selector_1.default)) {\n                    return null;\n                }\n                return maybeSelector;\n            }\n            // the elements from the current selector so far\n            currentElements = [];\n            // the current list of new selectors to add to the path.\n            // We will build it up. We initiate it with one empty selector as we \"multiply\" the new selectors\n            // by the parents\n            newSelectors = [\n                []\n            ];\n            for (i = 0; (el = inSelector.elements[i]); i++) {\n                // non parent reference elements just get added\n                if (el.value !== '&') {\n                    var nestedSelector = findNestedSelector(el);\n                    if (nestedSelector !== null) {\n                        // merge the current list of non parent selector elements\n                        // on to the current list of selectors to add\n                        mergeElementsOnToSelectors(currentElements, newSelectors);\n                        var nestedPaths = [];\n                        var replaced = void 0;\n                        var replacedNewSelectors = [];\n                        replaced = replaceParentSelector(nestedPaths, context, nestedSelector);\n                        hadParentSelector = hadParentSelector || replaced;\n                        // the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors\n                        for (k = 0; k < nestedPaths.length; k++) {\n                            var replacementSelector = createSelector(createParenthesis(nestedPaths[k], el), el);\n                            addAllReplacementsIntoPath(newSelectors, [replacementSelector], el, inSelector, replacedNewSelectors);\n                        }\n                        newSelectors = replacedNewSelectors;\n                        currentElements = [];\n                    }\n                    else {\n                        currentElements.push(el);\n                    }\n                }\n                else {\n                    hadParentSelector = true;\n                    // the new list of selectors to add\n                    selectorsMultiplied = [];\n                    // merge the current list of non parent selector elements\n                    // on to the current list of selectors to add\n                    mergeElementsOnToSelectors(currentElements, newSelectors);\n                    // loop through our current selectors\n                    for (j = 0; j < newSelectors.length; j++) {\n                        sel = newSelectors[j];\n                        // if we don't have any parent paths, the & might be in a mixin so that it can be used\n                        // whether there are parents or not\n                        if (context.length === 0) {\n                            // the combinator used on el should now be applied to the next element instead so that\n                            // it is not lost\n                            if (sel.length > 0) {\n                                sel[0].elements.push(new element_1.default(el.combinator, '', el.isVariable, el._index, el._fileInfo));\n                            }\n                            selectorsMultiplied.push(sel);\n                        }\n                        else {\n                            // and the parent selectors\n                            for (k = 0; k < context.length; k++) {\n                                // We need to put the current selectors\n                                // then join the last selector's elements on to the parents selectors\n                                var newSelectorPath = addReplacementIntoPath(sel, context[k], el, inSelector);\n                                // add that to our new set of selectors\n                                selectorsMultiplied.push(newSelectorPath);\n                            }\n                        }\n                    }\n                    // our new selectors has been multiplied, so reset the state\n                    newSelectors = selectorsMultiplied;\n                    currentElements = [];\n                }\n            }\n            // if we have any elements left over (e.g. .a& .b == .b)\n            // add them on to all the current selectors\n            mergeElementsOnToSelectors(currentElements, newSelectors);\n            for (i = 0; i < newSelectors.length; i++) {\n                length = newSelectors[i].length;\n                if (length > 0) {\n                    paths.push(newSelectors[i]);\n                    lastSelector = newSelectors[i][length - 1];\n                    newSelectors[i][length - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);\n                }\n            }\n            return hadParentSelector;\n        }\n        function deriveSelector(visibilityInfo, deriveFrom) {\n            var newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);\n            newSelector.copyVisibilityInfo(visibilityInfo);\n            return newSelector;\n        }\n        // joinSelector code follows\n        var i, newPaths, hadParentSelector;\n        newPaths = [];\n        hadParentSelector = replaceParentSelector(newPaths, context, selector);\n        if (!hadParentSelector) {\n            if (context.length > 0) {\n                newPaths = [];\n                for (i = 0; i < context.length; i++) {\n                    var concatenated = context[i].map(deriveSelector.bind(this, selector.visibilityInfo()));\n                    concatenated.push(selector);\n                    newPaths.push(concatenated);\n                }\n            }\n            else {\n                newPaths = [[selector]];\n            }\n        }\n        for (i = 0; i < newPaths.length; i++) {\n            paths.push(newPaths[i]);\n        }\n    }\n});\nexports.default = Ruleset;\n//# sourceMappingURL=ruleset.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar value_1 = tslib_1.__importDefault(require(\"./value\"));\nvar keyword_1 = tslib_1.__importDefault(require(\"./keyword\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"./anonymous\"));\nvar Constants = tslib_1.__importStar(require(\"../constants\"));\nvar MATH = Constants.Math;\nfunction evalName(context, name) {\n    var value = '';\n    var i;\n    var n = name.length;\n    var output = { add: function (s) { value += s; } };\n    for (i = 0; i < n; i++) {\n        name[i].eval(context).genCSS(context, output);\n    }\n    return value;\n}\nvar Declaration = function (name, value, important, merge, index, currentFileInfo, inline, variable) {\n    this.name = name;\n    this.value = (value instanceof node_1.default) ? value : new value_1.default([value ? new anonymous_1.default(value) : null]);\n    this.important = important ? \" \" + important.trim() : '';\n    this.merge = merge;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.inline = inline || false;\n    this.variable = (variable !== undefined) ? variable\n        : (name.charAt && (name.charAt(0) === '@'));\n    this.allowRoot = true;\n    this.setParent(this.value, this);\n};\nDeclaration.prototype = Object.assign(new node_1.default(), {\n    type: 'Declaration',\n    genCSS: function (context, output) {\n        output.add(this.name + (context.compress ? ':' : ': '), this.fileInfo(), this.getIndex());\n        try {\n            this.value.genCSS(context, output);\n        }\n        catch (e) {\n            e.index = this._index;\n            e.filename = this._fileInfo.filename;\n            throw e;\n        }\n        output.add(this.important + ((this.inline || (context.lastRule && context.compress)) ? '' : ';'), this._fileInfo, this._index);\n    },\n    eval: function (context) {\n        var mathBypass = false, prevMath, name = this.name, evaldValue, variable = this.variable;\n        if (typeof name !== 'string') {\n            // expand 'primitive' name directly to get\n            // things faster (~10% for benchmark.less):\n            name = (name.length === 1) && (name[0] instanceof keyword_1.default) ?\n                name[0].value : evalName(context, name);\n            variable = false; // never treat expanded interpolation as new variable name\n        }\n        // @todo remove when parens-division is default\n        if (name === 'font' && context.math === MATH.ALWAYS) {\n            mathBypass = true;\n            prevMath = context.math;\n            context.math = MATH.PARENS_DIVISION;\n        }\n        try {\n            context.importantScope.push({});\n            evaldValue = this.value.eval(context);\n            if (!this.variable && evaldValue.type === 'DetachedRuleset') {\n                throw { message: 'Rulesets cannot be evaluated on a property.',\n                    index: this.getIndex(), filename: this.fileInfo().filename };\n            }\n            var important = this.important;\n            var importantResult = context.importantScope.pop();\n            if (!important && importantResult.important) {\n                important = importantResult.important;\n            }\n            return new Declaration(name, evaldValue, important, this.merge, this.getIndex(), this.fileInfo(), this.inline, variable);\n        }\n        catch (e) {\n            if (typeof e.index !== 'number') {\n                e.index = this.getIndex();\n                e.filename = this.fileInfo().filename;\n            }\n            throw e;\n        }\n        finally {\n            if (mathBypass) {\n                context.math = prevMath;\n            }\n        }\n    },\n    makeImportant: function () {\n        return new Declaration(this.name, this.value, '!important', this.merge, this.getIndex(), this.fileInfo(), this.inline);\n    }\n});\nexports.default = Declaration;\n//# sourceMappingURL=declaration.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar Value = function (value) {\n    if (!value) {\n        throw new Error('Value requires an array argument');\n    }\n    if (!Array.isArray(value)) {\n        this.value = [value];\n    }\n    else {\n        this.value = value;\n    }\n};\nValue.prototype = Object.assign(new node_1.default(), {\n    type: 'Value',\n    accept: function (visitor) {\n        if (this.value) {\n            this.value = visitor.visitArray(this.value);\n        }\n    },\n    eval: function (context) {\n        if (this.value.length === 1) {\n            return this.value[0].eval(context);\n        }\n        else {\n            return new Value(this.value.map(function (v) {\n                return v.eval(context);\n            }));\n        }\n    },\n    genCSS: function (context, output) {\n        var i;\n        for (i = 0; i < this.value.length; i++) {\n            this.value[i].genCSS(context, output);\n            if (i + 1 < this.value.length) {\n                output.add((context && context.compress) ? ',' : ', ');\n            }\n        }\n    }\n});\nexports.default = Value;\n//# sourceMappingURL=value.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar Keyword = function (value) {\n    this.value = value;\n};\nKeyword.prototype = Object.assign(new node_1.default(), {\n    type: 'Keyword',\n    genCSS: function (context, output) {\n        if (this.value === '%') {\n            throw { type: 'Syntax', message: 'Invalid % without number' };\n        }\n        output.add(this.value);\n    }\n});\nKeyword.True = new Keyword('true');\nKeyword.False = new Keyword('false');\nexports.default = Keyword;\n//# sourceMappingURL=keyword.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar Anonymous = function (value, index, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {\n    this.value = value;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.mapLines = mapLines;\n    this.rulesetLike = (typeof rulesetLike === 'undefined') ? false : rulesetLike;\n    this.allowRoot = true;\n    this.copyVisibilityInfo(visibilityInfo);\n};\nAnonymous.prototype = Object.assign(new node_1.default(), {\n    type: 'Anonymous',\n    eval: function () {\n        return new Anonymous(this.value, this._index, this._fileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());\n    },\n    compare: function (other) {\n        return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;\n    },\n    isRulesetLike: function () {\n        return this.rulesetLike;\n    },\n    genCSS: function (context, output) {\n        this.nodeVisible = Boolean(this.value);\n        if (this.nodeVisible) {\n            output.add(this.value, this._fileInfo, this._index, this.mapLines);\n        }\n    }\n});\nexports.default = Anonymous;\n//# sourceMappingURL=anonymous.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar debug_info_1 = tslib_1.__importDefault(require(\"./debug-info\"));\nvar Comment = function (value, isLineComment, index, currentFileInfo) {\n    this.value = value;\n    this.isLineComment = isLineComment;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.allowRoot = true;\n};\nComment.prototype = Object.assign(new node_1.default(), {\n    type: 'Comment',\n    genCSS: function (context, output) {\n        if (this.debugInfo) {\n            output.add(debug_info_1.default(context, this), this.fileInfo(), this.getIndex());\n        }\n        output.add(this.value);\n    },\n    isSilent: function (context) {\n        var isCompressed = context.compress && this.value[2] !== '!';\n        return this.isLineComment || isCompressed;\n    }\n});\nexports.default = Comment;\n//# sourceMappingURL=comment.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction asComment(ctx) {\n    return \"/* line \" + ctx.debugInfo.lineNumber + \", \" + ctx.debugInfo.fileName + \" */\\n\";\n}\nfunction asMediaQuery(ctx) {\n    var filenameWithProtocol = ctx.debugInfo.fileName;\n    if (!/^[a-z]+:\\/\\//i.test(filenameWithProtocol)) {\n        filenameWithProtocol = \"file://\" + filenameWithProtocol;\n    }\n    return \"@media -sass-debug-info{filename{font-family:\" + filenameWithProtocol.replace(/([.:/\\\\])/g, function (a) {\n        if (a == '\\\\') {\n            a = '/';\n        }\n        return \"\\\\\" + a;\n    }) + \"}line{font-family:\\\\00003\" + ctx.debugInfo.lineNumber + \"}}\\n\";\n}\nfunction debugInfo(context, ctx, lineSeparator) {\n    var result = '';\n    if (context.dumpLineNumbers && !context.compress) {\n        switch (context.dumpLineNumbers) {\n            case 'comments':\n                result = asComment(ctx);\n                break;\n            case 'mediaquery':\n                result = asMediaQuery(ctx);\n                break;\n            case 'all':\n                result = asComment(ctx) + (lineSeparator || '') + asMediaQuery(ctx);\n                break;\n        }\n    }\n    return result;\n}\nexports.default = debugInfo;\n//# sourceMappingURL=debug-info.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar keyword_1 = tslib_1.__importDefault(require(\"../tree/keyword\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\nvar defaultFunc = {\n    eval: function () {\n        var v = this.value_;\n        var e = this.error_;\n        if (e) {\n            throw e;\n        }\n        if (!utils.isNullOrUndefined(v)) {\n            return v ? keyword_1.default.True : keyword_1.default.False;\n        }\n    },\n    value: function (v) {\n        this.value_ = v;\n    },\n    error: function (e) {\n        this.error_ = e;\n    },\n    reset: function () {\n        this.value_ = this.error_ = null;\n    }\n};\nexports.default = defaultFunc;\n//# sourceMappingURL=default.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar contexts_1 = tslib_1.__importDefault(require(\"../contexts\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\nvar DetachedRuleset = function (ruleset, frames) {\n    this.ruleset = ruleset;\n    this.frames = frames;\n    this.setParent(this.ruleset, this);\n};\nDetachedRuleset.prototype = Object.assign(new node_1.default(), {\n    type: 'DetachedRuleset',\n    evalFirst: true,\n    accept: function (visitor) {\n        this.ruleset = visitor.visit(this.ruleset);\n    },\n    eval: function (context) {\n        var frames = this.frames || utils.copyArray(context.frames);\n        return new DetachedRuleset(this.ruleset, frames);\n    },\n    callEval: function (context) {\n        return this.ruleset.eval(this.frames ? new contexts_1.default.Eval(context, this.frames.concat(context.frames)) : context);\n    }\n});\nexports.default = DetachedRuleset;\n//# sourceMappingURL=detached-ruleset.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar color_1 = tslib_1.__importDefault(require(\"./color\"));\nvar dimension_1 = tslib_1.__importDefault(require(\"./dimension\"));\nvar Constants = tslib_1.__importStar(require(\"../constants\"));\nvar MATH = Constants.Math;\nvar Operation = function (op, operands, isSpaced) {\n    this.op = op.trim();\n    this.operands = operands;\n    this.isSpaced = isSpaced;\n};\nOperation.prototype = Object.assign(new node_1.default(), {\n    type: 'Operation',\n    accept: function (visitor) {\n        this.operands = visitor.visitArray(this.operands);\n    },\n    eval: function (context) {\n        var a = this.operands[0].eval(context), b = this.operands[1].eval(context), op;\n        if (context.isMathOn(this.op)) {\n            op = this.op === './' ? '/' : this.op;\n            if (a instanceof dimension_1.default && b instanceof color_1.default) {\n                a = a.toColor();\n            }\n            if (b instanceof dimension_1.default && a instanceof color_1.default) {\n                b = b.toColor();\n            }\n            if (!a.operate || !b.operate) {\n                if ((a instanceof Operation || b instanceof Operation)\n                    && a.op === '/' && context.math === MATH.PARENS_DIVISION) {\n                    return new Operation(this.op, [a, b], this.isSpaced);\n                }\n                throw { type: 'Operation',\n                    message: 'Operation on an invalid type' };\n            }\n            return a.operate(context, op, b);\n        }\n        else {\n            return new Operation(this.op, [a, b], this.isSpaced);\n        }\n    },\n    genCSS: function (context, output) {\n        this.operands[0].genCSS(context, output);\n        if (this.isSpaced) {\n            output.add(' ');\n        }\n        output.add(this.op);\n        if (this.isSpaced) {\n            output.add(' ');\n        }\n        this.operands[1].genCSS(context, output);\n    }\n});\nexports.default = Operation;\n//# sourceMappingURL=operation.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/* eslint-disable no-prototype-builtins */\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar unit_conversions_1 = tslib_1.__importDefault(require(\"../data/unit-conversions\"));\nvar unit_1 = tslib_1.__importDefault(require(\"./unit\"));\nvar color_1 = tslib_1.__importDefault(require(\"./color\"));\n//\n// A number with a unit\n//\nvar Dimension = function (value, unit) {\n    this.value = parseFloat(value);\n    if (isNaN(this.value)) {\n        throw new Error('Dimension is not a number.');\n    }\n    this.unit = (unit && unit instanceof unit_1.default) ? unit :\n        new unit_1.default(unit ? [unit] : undefined);\n    this.setParent(this.unit, this);\n};\nDimension.prototype = Object.assign(new node_1.default(), {\n    type: 'Dimension',\n    accept: function (visitor) {\n        this.unit = visitor.visit(this.unit);\n    },\n    // remove when Nodes have JSDoc types\n    // eslint-disable-next-line no-unused-vars\n    eval: function (context) {\n        return this;\n    },\n    toColor: function () {\n        return new color_1.default([this.value, this.value, this.value]);\n    },\n    genCSS: function (context, output) {\n        if ((context && context.strictUnits) && !this.unit.isSingular()) {\n            throw new Error(\"Multiple units in dimension. Correct the units or use the unit function. Bad unit: \" + this.unit.toString());\n        }\n        var value = this.fround(context, this.value);\n        var strValue = String(value);\n        if (value !== 0 && value < 0.000001 && value > -0.000001) {\n            // would be output 1e-6 etc.\n            strValue = value.toFixed(20).replace(/0+$/, '');\n        }\n        if (context && context.compress) {\n            // Zero values doesn't need a unit\n            if (value === 0 && this.unit.isLength()) {\n                output.add(strValue);\n                return;\n            }\n            // Float values doesn't need a leading zero\n            if (value > 0 && value < 1) {\n                strValue = (strValue).substr(1);\n            }\n        }\n        output.add(strValue);\n        this.unit.genCSS(context, output);\n    },\n    // In an operation between two Dimensions,\n    // we default to the first Dimension's unit,\n    // so `1px + 2` will yield `3px`.\n    operate: function (context, op, other) {\n        /* jshint noempty:false */\n        var value = this._operate(context, op, this.value, other.value);\n        var unit = this.unit.clone();\n        if (op === '+' || op === '-') {\n            if (unit.numerator.length === 0 && unit.denominator.length === 0) {\n                unit = other.unit.clone();\n                if (this.unit.backupUnit) {\n                    unit.backupUnit = this.unit.backupUnit;\n                }\n            }\n            else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) {\n                // do nothing\n            }\n            else {\n                other = other.convertTo(this.unit.usedUnits());\n                if (context.strictUnits && other.unit.toString() !== unit.toString()) {\n                    throw new Error('Incompatible units. Change the units or use the unit function. '\n                        + (\"Bad units: '\" + unit.toString() + \"' and '\" + other.unit.toString() + \"'.\"));\n                }\n                value = this._operate(context, op, this.value, other.value);\n            }\n        }\n        else if (op === '*') {\n            unit.numerator = unit.numerator.concat(other.unit.numerator).sort();\n            unit.denominator = unit.denominator.concat(other.unit.denominator).sort();\n            unit.cancel();\n        }\n        else if (op === '/') {\n            unit.numerator = unit.numerator.concat(other.unit.denominator).sort();\n            unit.denominator = unit.denominator.concat(other.unit.numerator).sort();\n            unit.cancel();\n        }\n        return new Dimension(value, unit);\n    },\n    compare: function (other) {\n        var a, b;\n        if (!(other instanceof Dimension)) {\n            return undefined;\n        }\n        if (this.unit.isEmpty() || other.unit.isEmpty()) {\n            a = this;\n            b = other;\n        }\n        else {\n            a = this.unify();\n            b = other.unify();\n            if (a.unit.compare(b.unit) !== 0) {\n                return undefined;\n            }\n        }\n        return node_1.default.numericCompare(a.value, b.value);\n    },\n    unify: function () {\n        return this.convertTo({ length: 'px', duration: 's', angle: 'rad' });\n    },\n    convertTo: function (conversions) {\n        var value = this.value;\n        var unit = this.unit.clone();\n        var i;\n        var groupName;\n        var group;\n        var targetUnit;\n        var derivedConversions = {};\n        var applyUnit;\n        if (typeof conversions === 'string') {\n            for (i in unit_conversions_1.default) {\n                if (unit_conversions_1.default[i].hasOwnProperty(conversions)) {\n                    derivedConversions = {};\n                    derivedConversions[i] = conversions;\n                }\n            }\n            conversions = derivedConversions;\n        }\n        applyUnit = function (atomicUnit, denominator) {\n            if (group.hasOwnProperty(atomicUnit)) {\n                if (denominator) {\n                    value = value / (group[atomicUnit] / group[targetUnit]);\n                }\n                else {\n                    value = value * (group[atomicUnit] / group[targetUnit]);\n                }\n                return targetUnit;\n            }\n            return atomicUnit;\n        };\n        for (groupName in conversions) {\n            if (conversions.hasOwnProperty(groupName)) {\n                targetUnit = conversions[groupName];\n                group = unit_conversions_1.default[groupName];\n                unit.map(applyUnit);\n            }\n        }\n        unit.cancel();\n        return new Dimension(value, unit);\n    }\n});\nexports.default = Dimension;\n//# sourceMappingURL=dimension.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar unit_conversions_1 = tslib_1.__importDefault(require(\"../data/unit-conversions\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\nvar Unit = function (numerator, denominator, backupUnit) {\n    this.numerator = numerator ? utils.copyArray(numerator).sort() : [];\n    this.denominator = denominator ? utils.copyArray(denominator).sort() : [];\n    if (backupUnit) {\n        this.backupUnit = backupUnit;\n    }\n    else if (numerator && numerator.length) {\n        this.backupUnit = numerator[0];\n    }\n};\nUnit.prototype = Object.assign(new node_1.default(), {\n    type: 'Unit',\n    clone: function () {\n        return new Unit(utils.copyArray(this.numerator), utils.copyArray(this.denominator), this.backupUnit);\n    },\n    genCSS: function (context, output) {\n        // Dimension checks the unit is singular and throws an error if in strict math mode.\n        var strictUnits = context && context.strictUnits;\n        if (this.numerator.length === 1) {\n            output.add(this.numerator[0]); // the ideal situation\n        }\n        else if (!strictUnits && this.backupUnit) {\n            output.add(this.backupUnit);\n        }\n        else if (!strictUnits && this.denominator.length) {\n            output.add(this.denominator[0]);\n        }\n    },\n    toString: function () {\n        var i, returnStr = this.numerator.join('*');\n        for (i = 0; i < this.denominator.length; i++) {\n            returnStr += \"/\" + this.denominator[i];\n        }\n        return returnStr;\n    },\n    compare: function (other) {\n        return this.is(other.toString()) ? 0 : undefined;\n    },\n    is: function (unitString) {\n        return this.toString().toUpperCase() === unitString.toUpperCase();\n    },\n    isLength: function () {\n        return RegExp('^(px|em|ex|ch|rem|in|cm|mm|pc|pt|ex|vw|vh|vmin|vmax)$', 'gi').test(this.toCSS());\n    },\n    isEmpty: function () {\n        return this.numerator.length === 0 && this.denominator.length === 0;\n    },\n    isSingular: function () {\n        return this.numerator.length <= 1 && this.denominator.length === 0;\n    },\n    map: function (callback) {\n        var i;\n        for (i = 0; i < this.numerator.length; i++) {\n            this.numerator[i] = callback(this.numerator[i], false);\n        }\n        for (i = 0; i < this.denominator.length; i++) {\n            this.denominator[i] = callback(this.denominator[i], true);\n        }\n    },\n    usedUnits: function () {\n        var group;\n        var result = {};\n        var mapUnit;\n        var groupName;\n        mapUnit = function (atomicUnit) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {\n                result[groupName] = atomicUnit;\n            }\n            return atomicUnit;\n        };\n        for (groupName in unit_conversions_1.default) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (unit_conversions_1.default.hasOwnProperty(groupName)) {\n                group = unit_conversions_1.default[groupName];\n                this.map(mapUnit);\n            }\n        }\n        return result;\n    },\n    cancel: function () {\n        var counter = {};\n        var atomicUnit;\n        var i;\n        for (i = 0; i < this.numerator.length; i++) {\n            atomicUnit = this.numerator[i];\n            counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;\n        }\n        for (i = 0; i < this.denominator.length; i++) {\n            atomicUnit = this.denominator[i];\n            counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;\n        }\n        this.numerator = [];\n        this.denominator = [];\n        for (atomicUnit in counter) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (counter.hasOwnProperty(atomicUnit)) {\n                var count = counter[atomicUnit];\n                if (count > 0) {\n                    for (i = 0; i < count; i++) {\n                        this.numerator.push(atomicUnit);\n                    }\n                }\n                else if (count < 0) {\n                    for (i = 0; i < -count; i++) {\n                        this.denominator.push(atomicUnit);\n                    }\n                }\n            }\n        }\n        this.numerator.sort();\n        this.denominator.sort();\n    }\n});\nexports.default = Unit;\n//# sourceMappingURL=unit.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar call_1 = tslib_1.__importDefault(require(\"./call\"));\nvar Variable = function (name, index, currentFileInfo) {\n    this.name = name;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n};\nVariable.prototype = Object.assign(new node_1.default(), {\n    type: 'Variable',\n    eval: function (context) {\n        var variable, name = this.name;\n        if (name.indexOf('@@') === 0) {\n            name = \"@\" + new Variable(name.slice(1), this.getIndex(), this.fileInfo()).eval(context).value;\n        }\n        if (this.evaluating) {\n            throw { type: 'Name',\n                message: \"Recursive variable definition for \" + name,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n        this.evaluating = true;\n        variable = this.find(context.frames, function (frame) {\n            var v = frame.variable(name);\n            if (v) {\n                if (v.important) {\n                    var importantScope = context.importantScope[context.importantScope.length - 1];\n                    importantScope.important = v.important;\n                }\n                // If in calc, wrap vars in a function call to cascade evaluate args first\n                if (context.inCalc) {\n                    return (new call_1.default('_SELF', [v.value])).eval(context);\n                }\n                else {\n                    return v.value.eval(context);\n                }\n            }\n        });\n        if (variable) {\n            this.evaluating = false;\n            return variable;\n        }\n        else {\n            throw { type: 'Name',\n                message: \"variable \" + name + \" is undefined\",\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n    },\n    find: function (obj, fun) {\n        for (var i = 0, r = void 0; i < obj.length; i++) {\n            r = fun.call(obj, obj[i]);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n});\nexports.default = Variable;\n//# sourceMappingURL=variable.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"./anonymous\"));\nvar function_caller_1 = tslib_1.__importDefault(require(\"../functions/function-caller\"));\n//\n// A function call node.\n//\nvar Call = function (name, args, index, currentFileInfo) {\n    this.name = name;\n    this.args = args;\n    this.calc = name === 'calc';\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n};\nCall.prototype = Object.assign(new node_1.default(), {\n    type: 'Call',\n    accept: function (visitor) {\n        if (this.args) {\n            this.args = visitor.visitArray(this.args);\n        }\n    },\n    //\n    // When evaluating a function call,\n    // we either find the function in the functionRegistry,\n    // in which case we call it, passing the  evaluated arguments,\n    // if this returns null or we cannot find the function, we\n    // simply print it out as it appeared originally [2].\n    //\n    // The reason why we evaluate the arguments, is in the case where\n    // we try to pass a variable to a function, like: `saturate(@color)`.\n    // The function should receive the value, not the variable.\n    //\n    eval: function (context) {\n        var _this = this;\n        /**\n         * Turn off math for calc(), and switch back on for evaluating nested functions\n         */\n        var currentMathContext = context.mathOn;\n        context.mathOn = !this.calc;\n        if (this.calc || context.inCalc) {\n            context.enterCalc();\n        }\n        var exitCalc = function () {\n            if (_this.calc || context.inCalc) {\n                context.exitCalc();\n            }\n            context.mathOn = currentMathContext;\n        };\n        var result;\n        var funcCaller = new function_caller_1.default(this.name, context, this.getIndex(), this.fileInfo());\n        if (funcCaller.isValid()) {\n            try {\n                result = funcCaller.call(this.args);\n                exitCalc();\n            }\n            catch (e) {\n                // eslint-disable-next-line no-prototype-builtins\n                if (e.hasOwnProperty('line') && e.hasOwnProperty('column')) {\n                    throw e;\n                }\n                throw {\n                    type: e.type || 'Runtime',\n                    message: \"Error evaluating function `\" + this.name + \"`\" + (e.message ? \": \" + e.message : ''),\n                    index: this.getIndex(),\n                    filename: this.fileInfo().filename,\n                    line: e.lineNumber,\n                    column: e.columnNumber\n                };\n            }\n        }\n        if (result !== null && result !== undefined) {\n            // Results that that are not nodes are cast as Anonymous nodes\n            // Falsy values or booleans are returned as empty nodes\n            if (!(result instanceof node_1.default)) {\n                if (!result || result === true) {\n                    result = new anonymous_1.default(null);\n                }\n                else {\n                    result = new anonymous_1.default(result.toString());\n                }\n            }\n            result._index = this._index;\n            result._fileInfo = this._fileInfo;\n            return result;\n        }\n        var args = this.args.map(function (a) { return a.eval(context); });\n        exitCalc();\n        return new Call(this.name, args, this.getIndex(), this.fileInfo());\n    },\n    genCSS: function (context, output) {\n        output.add(this.name + \"(\", this.fileInfo(), this.getIndex());\n        for (var i = 0; i < this.args.length; i++) {\n            this.args[i].genCSS(context, output);\n            if (i + 1 < this.args.length) {\n                output.add(', ');\n            }\n        }\n        output.add(')');\n    }\n});\nexports.default = Call;\n//# sourceMappingURL=call.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar expression_1 = tslib_1.__importDefault(require(\"../tree/expression\"));\nvar functionCaller = /** @class */ (function () {\n    function functionCaller(name, context, index, currentFileInfo) {\n        this.name = name.toLowerCase();\n        this.index = index;\n        this.context = context;\n        this.currentFileInfo = currentFileInfo;\n        this.func = context.frames[0].functionRegistry.get(this.name);\n    }\n    functionCaller.prototype.isValid = function () {\n        return Boolean(this.func);\n    };\n    functionCaller.prototype.call = function (args) {\n        var _this = this;\n        if (!(Array.isArray(args))) {\n            args = [args];\n        }\n        var evalArgs = this.func.evalArgs;\n        if (evalArgs !== false) {\n            args = args.map(function (a) { return a.eval(_this.context); });\n        }\n        var commentFilter = function (item) { return !(item.type === 'Comment'); };\n        // This code is terrible and should be replaced as per this issue...\n        // https://github.com/less/less.js/issues/2477\n        args = args\n            .filter(commentFilter)\n            .map(function (item) {\n            if (item.type === 'Expression') {\n                var subNodes = item.value.filter(commentFilter);\n                if (subNodes.length === 1) {\n                    // https://github.com/less/less.js/issues/3616\n                    if (item.parens && subNodes[0].op === '/') {\n                        return item;\n                    }\n                    return subNodes[0];\n                }\n                else {\n                    return new expression_1.default(subNodes);\n                }\n            }\n            return item;\n        });\n        if (evalArgs === false) {\n            return this.func.apply(this, tslib_1.__spreadArray([this.context], args));\n        }\n        return this.func.apply(this, args);\n    };\n    return functionCaller;\n}());\nexports.default = functionCaller;\n//# sourceMappingURL=function-caller.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar paren_1 = tslib_1.__importDefault(require(\"./paren\"));\nvar comment_1 = tslib_1.__importDefault(require(\"./comment\"));\nvar dimension_1 = tslib_1.__importDefault(require(\"./dimension\"));\nvar Expression = function (value, noSpacing) {\n    this.value = value;\n    this.noSpacing = noSpacing;\n    if (!value) {\n        throw new Error('Expression requires an array parameter');\n    }\n};\nExpression.prototype = Object.assign(new node_1.default(), {\n    type: 'Expression',\n    accept: function (visitor) {\n        this.value = visitor.visitArray(this.value);\n    },\n    eval: function (context) {\n        var returnValue;\n        var mathOn = context.isMathOn();\n        var inParenthesis = this.parens;\n        var doubleParen = false;\n        if (inParenthesis) {\n            context.inParenthesis();\n        }\n        if (this.value.length > 1) {\n            returnValue = new Expression(this.value.map(function (e) {\n                if (!e.eval) {\n                    return e;\n                }\n                return e.eval(context);\n            }), this.noSpacing);\n        }\n        else if (this.value.length === 1) {\n            if (this.value[0].parens && !this.value[0].parensInOp && !context.inCalc) {\n                doubleParen = true;\n            }\n            returnValue = this.value[0].eval(context);\n        }\n        else {\n            returnValue = this;\n        }\n        if (inParenthesis) {\n            context.outOfParenthesis();\n        }\n        if (this.parens && this.parensInOp && !mathOn && !doubleParen\n            && (!(returnValue instanceof dimension_1.default))) {\n            returnValue = new paren_1.default(returnValue);\n        }\n        return returnValue;\n    },\n    genCSS: function (context, output) {\n        for (var i = 0; i < this.value.length; i++) {\n            this.value[i].genCSS(context, output);\n            if (!this.noSpacing && i + 1 < this.value.length) {\n                output.add(' ');\n            }\n        }\n    },\n    throwAwayComments: function () {\n        this.value = this.value.filter(function (v) {\n            return !(v instanceof comment_1.default);\n        });\n    }\n});\nexports.default = Expression;\n//# sourceMappingURL=expression.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar declaration_1 = tslib_1.__importDefault(require(\"./declaration\"));\nvar Property = function (name, index, currentFileInfo) {\n    this.name = name;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n};\nProperty.prototype = Object.assign(new node_1.default(), {\n    type: 'Property',\n    eval: function (context) {\n        var property;\n        var name = this.name;\n        // TODO: shorten this reference\n        var mergeRules = context.pluginManager.less.visitors.ToCSSVisitor.prototype._mergeRules;\n        if (this.evaluating) {\n            throw { type: 'Name',\n                message: \"Recursive property reference for \" + name,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n        this.evaluating = true;\n        property = this.find(context.frames, function (frame) {\n            var v;\n            var vArr = frame.property(name);\n            if (vArr) {\n                for (var i = 0; i < vArr.length; i++) {\n                    v = vArr[i];\n                    vArr[i] = new declaration_1.default(v.name, v.value, v.important, v.merge, v.index, v.currentFileInfo, v.inline, v.variable);\n                }\n                mergeRules(vArr);\n                v = vArr[vArr.length - 1];\n                if (v.important) {\n                    var importantScope = context.importantScope[context.importantScope.length - 1];\n                    importantScope.important = v.important;\n                }\n                v = v.value.eval(context);\n                return v;\n            }\n        });\n        if (property) {\n            this.evaluating = false;\n            return property;\n        }\n        else {\n            throw { type: 'Name',\n                message: \"Property '\" + name + \"' is undefined\",\n                filename: this.currentFileInfo.filename,\n                index: this.index };\n        }\n    },\n    find: function (obj, fun) {\n        for (var i = 0, r = void 0; i < obj.length; i++) {\n            r = fun.call(obj, obj[i]);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n});\nexports.default = Property;\n//# sourceMappingURL=property.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar Attribute = function (key, op, value, cif) {\n    this.key = key;\n    this.op = op;\n    this.value = value;\n    this.cif = cif;\n};\nAttribute.prototype = Object.assign(new node_1.default(), {\n    type: 'Attribute',\n    eval: function (context) {\n        return new Attribute(this.key.eval ? this.key.eval(context) : this.key, this.op, (this.value && this.value.eval) ? this.value.eval(context) : this.value, this.cif);\n    },\n    genCSS: function (context, output) {\n        output.add(this.toCSS(context));\n    },\n    toCSS: function (context) {\n        var value = this.key.toCSS ? this.key.toCSS(context) : this.key;\n        if (this.op) {\n            value += this.op;\n            value += (this.value.toCSS ? this.value.toCSS(context) : this.value);\n        }\n        if (this.cif) {\n            value = value + ' ' + this.cif;\n        }\n        return \"[\" + value + \"]\";\n    }\n});\nexports.default = Attribute;\n//# sourceMappingURL=attribute.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar variable_1 = tslib_1.__importDefault(require(\"./variable\"));\nvar property_1 = tslib_1.__importDefault(require(\"./property\"));\nvar Quoted = function (str, content, escaped, index, currentFileInfo) {\n    this.escaped = (escaped === undefined) ? true : escaped;\n    this.value = content || '';\n    this.quote = str.charAt(0);\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.variableRegex = /@\\{([\\w-]+)\\}/g;\n    this.propRegex = /\\$\\{([\\w-]+)\\}/g;\n    this.allowRoot = escaped;\n};\nQuoted.prototype = Object.assign(new node_1.default(), {\n    type: 'Quoted',\n    genCSS: function (context, output) {\n        if (!this.escaped) {\n            output.add(this.quote, this.fileInfo(), this.getIndex());\n        }\n        output.add(this.value);\n        if (!this.escaped) {\n            output.add(this.quote);\n        }\n    },\n    containsVariables: function () {\n        return this.value.match(this.variableRegex);\n    },\n    eval: function (context) {\n        var that = this;\n        var value = this.value;\n        var variableReplacement = function (_, name) {\n            var v = new variable_1.default(\"@\" + name, that.getIndex(), that.fileInfo()).eval(context, true);\n            return (v instanceof Quoted) ? v.value : v.toCSS();\n        };\n        var propertyReplacement = function (_, name) {\n            var v = new property_1.default(\"$\" + name, that.getIndex(), that.fileInfo()).eval(context, true);\n            return (v instanceof Quoted) ? v.value : v.toCSS();\n        };\n        function iterativeReplace(value, regexp, replacementFnc) {\n            var evaluatedValue = value;\n            do {\n                value = evaluatedValue.toString();\n                evaluatedValue = value.replace(regexp, replacementFnc);\n            } while (value !== evaluatedValue);\n            return evaluatedValue;\n        }\n        value = iterativeReplace(value, this.variableRegex, variableReplacement);\n        value = iterativeReplace(value, this.propRegex, propertyReplacement);\n        return new Quoted(this.quote + value + this.quote, value, this.escaped, this.getIndex(), this.fileInfo());\n    },\n    compare: function (other) {\n        // when comparing quoted strings allow the quote to differ\n        if (other.type === 'Quoted' && !this.escaped && !other.escaped) {\n            return node_1.default.numericCompare(this.value, other.value);\n        }\n        else {\n            return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;\n        }\n    }\n});\nexports.default = Quoted;\n//# sourceMappingURL=quoted.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nfunction escapePath(path) {\n    return path.replace(/[()'\"\\s]/g, function (match) { return \"\\\\\" + match; });\n}\nvar URL = function (val, index, currentFileInfo, isEvald) {\n    this.value = val;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.isEvald = isEvald;\n};\nURL.prototype = Object.assign(new node_1.default(), {\n    type: 'Url',\n    accept: function (visitor) {\n        this.value = visitor.visit(this.value);\n    },\n    genCSS: function (context, output) {\n        output.add('url(');\n        this.value.genCSS(context, output);\n        output.add(')');\n    },\n    eval: function (context) {\n        var val = this.value.eval(context);\n        var rootpath;\n        if (!this.isEvald) {\n            // Add the rootpath if the URL requires a rewrite\n            rootpath = this.fileInfo() && this.fileInfo().rootpath;\n            if (typeof rootpath === 'string' &&\n                typeof val.value === 'string' &&\n                context.pathRequiresRewrite(val.value)) {\n                if (!val.quote) {\n                    rootpath = escapePath(rootpath);\n                }\n                val.value = context.rewritePath(val.value, rootpath);\n            }\n            else {\n                val.value = context.normalizePath(val.value);\n            }\n            // Add url args if enabled\n            if (context.urlArgs) {\n                if (!val.value.match(/^\\s*data:/)) {\n                    var delimiter = val.value.indexOf('?') === -1 ? '?' : '&';\n                    var urlArgs = delimiter + context.urlArgs;\n                    if (val.value.indexOf('#') !== -1) {\n                        val.value = val.value.replace('#', urlArgs + \"#\");\n                    }\n                    else {\n                        val.value += urlArgs;\n                    }\n                }\n            }\n        }\n        return new URL(val, this.getIndex(), this.fileInfo(), true);\n    }\n});\nexports.default = URL;\n//# sourceMappingURL=url.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar media_1 = tslib_1.__importDefault(require(\"./media\"));\nvar url_1 = tslib_1.__importDefault(require(\"./url\"));\nvar quoted_1 = tslib_1.__importDefault(require(\"./quoted\"));\nvar ruleset_1 = tslib_1.__importDefault(require(\"./ruleset\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"./anonymous\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\nvar less_error_1 = tslib_1.__importDefault(require(\"../less-error\"));\n//\n// CSS @import node\n//\n// The general strategy here is that we don't want to wait\n// for the parsing to be completed, before we start importing\n// the file. That's because in the context of a browser,\n// most of the time will be spent waiting for the server to respond.\n//\n// On creation, we push the import path to our import queue, though\n// `import,push`, we also pass it a callback, which it'll call once\n// the file has been fetched, and parsed.\n//\nvar Import = function (path, features, options, index, currentFileInfo, visibilityInfo) {\n    this.options = options;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.path = path;\n    this.features = features;\n    this.allowRoot = true;\n    if (this.options.less !== undefined || this.options.inline) {\n        this.css = !this.options.less || this.options.inline;\n    }\n    else {\n        var pathValue = this.getPath();\n        if (pathValue && /[#.&?]css([?;].*)?$/.test(pathValue)) {\n            this.css = true;\n        }\n    }\n    this.copyVisibilityInfo(visibilityInfo);\n    this.setParent(this.features, this);\n    this.setParent(this.path, this);\n};\nImport.prototype = Object.assign(new node_1.default(), {\n    type: 'Import',\n    accept: function (visitor) {\n        if (this.features) {\n            this.features = visitor.visit(this.features);\n        }\n        this.path = visitor.visit(this.path);\n        if (!this.options.isPlugin && !this.options.inline && this.root) {\n            this.root = visitor.visit(this.root);\n        }\n    },\n    genCSS: function (context, output) {\n        if (this.css && this.path._fileInfo.reference === undefined) {\n            output.add('@import ', this._fileInfo, this._index);\n            this.path.genCSS(context, output);\n            if (this.features) {\n                output.add(' ');\n                this.features.genCSS(context, output);\n            }\n            output.add(';');\n        }\n    },\n    getPath: function () {\n        return (this.path instanceof url_1.default) ?\n            this.path.value.value : this.path.value;\n    },\n    isVariableImport: function () {\n        var path = this.path;\n        if (path instanceof url_1.default) {\n            path = path.value;\n        }\n        if (path instanceof quoted_1.default) {\n            return path.containsVariables();\n        }\n        return true;\n    },\n    evalForImport: function (context) {\n        var path = this.path;\n        if (path instanceof url_1.default) {\n            path = path.value;\n        }\n        return new Import(path.eval(context), this.features, this.options, this._index, this._fileInfo, this.visibilityInfo());\n    },\n    evalPath: function (context) {\n        var path = this.path.eval(context);\n        var fileInfo = this._fileInfo;\n        if (!(path instanceof url_1.default)) {\n            // Add the rootpath if the URL requires a rewrite\n            var pathValue = path.value;\n            if (fileInfo &&\n                pathValue &&\n                context.pathRequiresRewrite(pathValue)) {\n                path.value = context.rewritePath(pathValue, fileInfo.rootpath);\n            }\n            else {\n                path.value = context.normalizePath(path.value);\n            }\n        }\n        return path;\n    },\n    eval: function (context) {\n        var result = this.doEval(context);\n        if (this.options.reference || this.blocksVisibility()) {\n            if (result.length || result.length === 0) {\n                result.forEach(function (node) {\n                    node.addVisibilityBlock();\n                });\n            }\n            else {\n                result.addVisibilityBlock();\n            }\n        }\n        return result;\n    },\n    doEval: function (context) {\n        var ruleset;\n        var registry;\n        var features = this.features && this.features.eval(context);\n        if (this.options.isPlugin) {\n            if (this.root && this.root.eval) {\n                try {\n                    this.root.eval(context);\n                }\n                catch (e) {\n                    e.message = 'Plugin error during evaluation';\n                    throw new less_error_1.default(e, this.root.imports, this.root.filename);\n                }\n            }\n            registry = context.frames[0] && context.frames[0].functionRegistry;\n            if (registry && this.root && this.root.functions) {\n                registry.addMultiple(this.root.functions);\n            }\n            return [];\n        }\n        if (this.skip) {\n            if (typeof this.skip === 'function') {\n                this.skip = this.skip();\n            }\n            if (this.skip) {\n                return [];\n            }\n        }\n        if (this.options.inline) {\n            var contents = new anonymous_1.default(this.root, 0, {\n                filename: this.importedFilename,\n                reference: this.path._fileInfo && this.path._fileInfo.reference\n            }, true, true);\n            return this.features ? new media_1.default([contents], this.features.value) : [contents];\n        }\n        else if (this.css) {\n            var newImport = new Import(this.evalPath(context), features, this.options, this._index);\n            if (!newImport.css && this.error) {\n                throw this.error;\n            }\n            return newImport;\n        }\n        else if (this.root) {\n            ruleset = new ruleset_1.default(null, utils.copyArray(this.root.rules));\n            ruleset.evalImports(context);\n            return this.features ? new media_1.default(ruleset.rules, this.features.value) : ruleset.rules;\n        }\n        else {\n            return [];\n        }\n    }\n});\nexports.default = Import;\n//# sourceMappingURL=import.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar ruleset_1 = tslib_1.__importDefault(require(\"./ruleset\"));\nvar value_1 = tslib_1.__importDefault(require(\"./value\"));\nvar selector_1 = tslib_1.__importDefault(require(\"./selector\"));\nvar atrule_1 = tslib_1.__importDefault(require(\"./atrule\"));\nvar nested_at_rule_1 = tslib_1.__importDefault(require(\"./nested-at-rule\"));\nvar Media = function (value, features, index, currentFileInfo, visibilityInfo) {\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    var selectors = (new selector_1.default([], null, null, this._index, this._fileInfo)).createEmptySelectors();\n    this.features = new value_1.default(features);\n    this.rules = [new ruleset_1.default(selectors, value)];\n    this.rules[0].allowImports = true;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n    this.setParent(selectors, this);\n    this.setParent(this.features, this);\n    this.setParent(this.rules, this);\n};\nMedia.prototype = Object.assign(new atrule_1.default(), tslib_1.__assign(tslib_1.__assign({ type: 'Media' }, nested_at_rule_1.default), { genCSS: function (context, output) {\n        output.add('@media ', this._fileInfo, this._index);\n        this.features.genCSS(context, output);\n        this.outputRuleset(context, output, this.rules);\n    }, eval: function (context) {\n        if (!context.mediaBlocks) {\n            context.mediaBlocks = [];\n            context.mediaPath = [];\n        }\n        var media = new Media(null, [], this._index, this._fileInfo, this.visibilityInfo());\n        if (this.debugInfo) {\n            this.rules[0].debugInfo = this.debugInfo;\n            media.debugInfo = this.debugInfo;\n        }\n        media.features = this.features.eval(context);\n        context.mediaPath.push(media);\n        context.mediaBlocks.push(media);\n        this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();\n        context.frames.unshift(this.rules[0]);\n        media.rules = [this.rules[0].eval(context)];\n        context.frames.shift();\n        context.mediaPath.pop();\n        return context.mediaPath.length === 0 ? media.evalTop(context) :\n            media.evalNested(context);\n    } }));\nexports.default = Media;\n//# sourceMappingURL=media.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar ruleset_1 = tslib_1.__importDefault(require(\"./ruleset\"));\nvar value_1 = tslib_1.__importDefault(require(\"./value\"));\nvar selector_1 = tslib_1.__importDefault(require(\"./selector\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"./anonymous\"));\nvar expression_1 = tslib_1.__importDefault(require(\"./expression\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\nvar NestableAtRulePrototype = {\n    isRulesetLike: function () {\n        return true;\n    },\n    accept: function (visitor) {\n        if (this.features) {\n            this.features = visitor.visit(this.features);\n        }\n        if (this.rules) {\n            this.rules = visitor.visitArray(this.rules);\n        }\n    },\n    evalTop: function (context) {\n        var result = this;\n        // Render all dependent Media blocks.\n        if (context.mediaBlocks.length > 1) {\n            var selectors = (new selector_1.default([], null, null, this.getIndex(), this.fileInfo())).createEmptySelectors();\n            result = new ruleset_1.default(selectors, context.mediaBlocks);\n            result.multiMedia = true;\n            result.copyVisibilityInfo(this.visibilityInfo());\n            this.setParent(result, this);\n        }\n        delete context.mediaBlocks;\n        delete context.mediaPath;\n        return result;\n    },\n    evalNested: function (context) {\n        var i;\n        var value;\n        var path = context.mediaPath.concat([this]);\n        // Extract the media-query conditions separated with `,` (OR).\n        for (i = 0; i < path.length; i++) {\n            value = path[i].features instanceof value_1.default ?\n                path[i].features.value : path[i].features;\n            path[i] = Array.isArray(value) ? value : [value];\n        }\n        // Trace all permutations to generate the resulting media-query.\n        //\n        // (a, b and c) with nested (d, e) ->\n        //    a and d\n        //    a and e\n        //    b and c and d\n        //    b and c and e\n        this.features = new value_1.default(this.permute(path).map(function (path) {\n            path = path.map(function (fragment) { return fragment.toCSS ? fragment : new anonymous_1.default(fragment); });\n            for (i = path.length - 1; i > 0; i--) {\n                path.splice(i, 0, new anonymous_1.default('and'));\n            }\n            return new expression_1.default(path);\n        }));\n        this.setParent(this.features, this);\n        // Fake a tree-node that doesn't output anything.\n        return new ruleset_1.default([], []);\n    },\n    permute: function (arr) {\n        if (arr.length === 0) {\n            return [];\n        }\n        else if (arr.length === 1) {\n            return arr[0];\n        }\n        else {\n            var result = [];\n            var rest = this.permute(arr.slice(1));\n            for (var i = 0; i < rest.length; i++) {\n                for (var j = 0; j < arr[0].length; j++) {\n                    result.push([arr[0][j]].concat(rest[i]));\n                }\n            }\n            return result;\n        }\n    },\n    bubbleSelectors: function (selectors) {\n        if (!selectors) {\n            return;\n        }\n        this.rules = [new ruleset_1.default(utils.copyArray(selectors), [this.rules[0]])];\n        this.setParent(this.rules, this);\n    }\n};\nexports.default = NestableAtRulePrototype;\n//# sourceMappingURL=nested-at-rule.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar js_eval_node_1 = tslib_1.__importDefault(require(\"./js-eval-node\"));\nvar dimension_1 = tslib_1.__importDefault(require(\"./dimension\"));\nvar quoted_1 = tslib_1.__importDefault(require(\"./quoted\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"./anonymous\"));\nvar JavaScript = function (string, escaped, index, currentFileInfo) {\n    this.escaped = escaped;\n    this.expression = string;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n};\nJavaScript.prototype = Object.assign(new js_eval_node_1.default(), {\n    type: 'JavaScript',\n    eval: function (context) {\n        var result = this.evaluateJavaScript(this.expression, context);\n        var type = typeof result;\n        if (type === 'number' && !isNaN(result)) {\n            return new dimension_1.default(result);\n        }\n        else if (type === 'string') {\n            return new quoted_1.default(\"\\\"\" + result + \"\\\"\", result, this.escaped, this._index);\n        }\n        else if (Array.isArray(result)) {\n            return new anonymous_1.default(result.join(', '));\n        }\n        else {\n            return new anonymous_1.default(result);\n        }\n    }\n});\nexports.default = JavaScript;\n//# sourceMappingURL=javascript.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar variable_1 = tslib_1.__importDefault(require(\"./variable\"));\nvar JsEvalNode = function () { };\nJsEvalNode.prototype = Object.assign(new node_1.default(), {\n    evaluateJavaScript: function (expression, context) {\n        var result;\n        var that = this;\n        var evalContext = {};\n        if (!context.javascriptEnabled) {\n            throw { message: 'Inline JavaScript is not enabled. Is it set in your options?',\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n        expression = expression.replace(/@\\{([\\w-]+)\\}/g, function (_, name) {\n            return that.jsify(new variable_1.default(\"@\" + name, that.getIndex(), that.fileInfo()).eval(context));\n        });\n        try {\n            expression = new Function(\"return (\" + expression + \")\");\n        }\n        catch (e) {\n            throw { message: \"JavaScript evaluation error: \" + e.message + \" from `\" + expression + \"`\",\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n        var variables = context.frames[0].variables();\n        for (var k in variables) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (variables.hasOwnProperty(k)) {\n                evalContext[k.slice(1)] = {\n                    value: variables[k].value,\n                    toJS: function () {\n                        return this.value.eval(context).toCSS();\n                    }\n                };\n            }\n        }\n        try {\n            result = expression.call(evalContext);\n        }\n        catch (e) {\n            throw { message: \"JavaScript evaluation error: '\" + e.name + \": \" + e.message.replace(/[\"]/g, '\\'') + \"'\",\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n        return result;\n    },\n    jsify: function (obj) {\n        if (Array.isArray(obj.value) && (obj.value.length > 1)) {\n            return \"[\" + obj.value.map(function (v) { return v.toCSS(); }).join(', ') + \"]\";\n        }\n        else {\n            return obj.toCSS();\n        }\n    }\n});\nexports.default = JsEvalNode;\n//# sourceMappingURL=js-eval-node.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar Assignment = function (key, val) {\n    this.key = key;\n    this.value = val;\n};\nAssignment.prototype = Object.assign(new node_1.default(), {\n    type: 'Assignment',\n    accept: function (visitor) {\n        this.value = visitor.visit(this.value);\n    },\n    eval: function (context) {\n        if (this.value.eval) {\n            return new Assignment(this.key, this.value.eval(context));\n        }\n        return this;\n    },\n    genCSS: function (context, output) {\n        output.add(this.key + \"=\");\n        if (this.value.genCSS) {\n            this.value.genCSS(context, output);\n        }\n        else {\n            output.add(this.value);\n        }\n    }\n});\nexports.default = Assignment;\n//# sourceMappingURL=assignment.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar Condition = function (op, l, r, i, negate) {\n    this.op = op.trim();\n    this.lvalue = l;\n    this.rvalue = r;\n    this._index = i;\n    this.negate = negate;\n};\nCondition.prototype = Object.assign(new node_1.default(), {\n    type: 'Condition',\n    accept: function (visitor) {\n        this.lvalue = visitor.visit(this.lvalue);\n        this.rvalue = visitor.visit(this.rvalue);\n    },\n    eval: function (context) {\n        var result = (function (op, a, b) {\n            switch (op) {\n                case 'and': return a && b;\n                case 'or': return a || b;\n                default:\n                    switch (node_1.default.compare(a, b)) {\n                        case -1:\n                            return op === '<' || op === '=<' || op === '<=';\n                        case 0:\n                            return op === '=' || op === '>=' || op === '=<' || op === '<=';\n                        case 1:\n                            return op === '>' || op === '>=';\n                        default:\n                            return false;\n                    }\n            }\n        })(this.op, this.lvalue.eval(context), this.rvalue.eval(context));\n        return this.negate ? !result : result;\n    }\n});\nexports.default = Condition;\n//# sourceMappingURL=condition.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar QueryInParens = function (op, l, m, op2, r, i) {\n    this.op = op.trim();\n    this.lvalue = l;\n    this.mvalue = m;\n    this.op2 = op2 ? op2.trim() : null;\n    this.rvalue = r;\n    this._index = i;\n};\nQueryInParens.prototype = Object.assign(new node_1.default(), {\n    type: 'QueryInParens',\n    accept: function (visitor) {\n        this.lvalue = visitor.visit(this.lvalue);\n        this.mvalue = visitor.visit(this.mvalue);\n        if (this.rvalue) {\n            this.rvalue = visitor.visit(this.rvalue);\n        }\n    },\n    eval: function (context) {\n        this.lvalue = this.lvalue.eval(context);\n        this.mvalue = this.mvalue.eval(context);\n        if (this.rvalue) {\n            this.rvalue = this.rvalue.eval(context);\n        }\n        return this;\n    },\n    genCSS: function (context, output) {\n        this.lvalue.genCSS(context, output);\n        output.add(' ' + this.op + ' ');\n        this.mvalue.genCSS(context, output);\n        if (this.rvalue) {\n            output.add(' ' + this.op2 + ' ');\n            this.rvalue.genCSS(context, output);\n        }\n    },\n});\nexports.default = QueryInParens;\n//# sourceMappingURL=query-in-parens.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar ruleset_1 = tslib_1.__importDefault(require(\"./ruleset\"));\nvar value_1 = tslib_1.__importDefault(require(\"./value\"));\nvar selector_1 = tslib_1.__importDefault(require(\"./selector\"));\nvar atrule_1 = tslib_1.__importDefault(require(\"./atrule\"));\nvar nested_at_rule_1 = tslib_1.__importDefault(require(\"./nested-at-rule\"));\nvar Container = function (value, features, index, currentFileInfo, visibilityInfo) {\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    var selectors = (new selector_1.default([], null, null, this._index, this._fileInfo)).createEmptySelectors();\n    this.features = new value_1.default(features);\n    this.rules = [new ruleset_1.default(selectors, value)];\n    this.rules[0].allowImports = true;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n    this.setParent(selectors, this);\n    this.setParent(this.features, this);\n    this.setParent(this.rules, this);\n};\nContainer.prototype = Object.assign(new atrule_1.default(), tslib_1.__assign(tslib_1.__assign({ type: 'Container' }, nested_at_rule_1.default), { genCSS: function (context, output) {\n        output.add('@container ', this._fileInfo, this._index);\n        this.features.genCSS(context, output);\n        this.outputRuleset(context, output, this.rules);\n    }, eval: function (context) {\n        if (!context.mediaBlocks) {\n            context.mediaBlocks = [];\n            context.mediaPath = [];\n        }\n        var media = new Container(null, [], this._index, this._fileInfo, this.visibilityInfo());\n        if (this.debugInfo) {\n            this.rules[0].debugInfo = this.debugInfo;\n            media.debugInfo = this.debugInfo;\n        }\n        media.features = this.features.eval(context);\n        context.mediaPath.push(media);\n        context.mediaBlocks.push(media);\n        this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();\n        context.frames.unshift(this.rules[0]);\n        media.rules = [this.rules[0].eval(context)];\n        context.frames.shift();\n        context.mediaPath.pop();\n        return context.mediaPath.length === 0 ? media.evalTop(context) :\n            media.evalNested(context);\n    } }));\nexports.default = Container;\n//# sourceMappingURL=container.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar UnicodeDescriptor = function (value) {\n    this.value = value;\n};\nUnicodeDescriptor.prototype = Object.assign(new node_1.default(), {\n    type: 'UnicodeDescriptor'\n});\nexports.default = UnicodeDescriptor;\n//# sourceMappingURL=unicode-descriptor.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar operation_1 = tslib_1.__importDefault(require(\"./operation\"));\nvar dimension_1 = tslib_1.__importDefault(require(\"./dimension\"));\nvar Negative = function (node) {\n    this.value = node;\n};\nNegative.prototype = Object.assign(new node_1.default(), {\n    type: 'Negative',\n    genCSS: function (context, output) {\n        output.add('-');\n        this.value.genCSS(context, output);\n    },\n    eval: function (context) {\n        if (context.isMathOn()) {\n            return (new operation_1.default('*', [new dimension_1.default(-1), this.value])).eval(context);\n        }\n        return new Negative(this.value.eval(context));\n    }\n});\nexports.default = Negative;\n//# sourceMappingURL=negative.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar selector_1 = tslib_1.__importDefault(require(\"./selector\"));\nvar Extend = function (selector, option, index, currentFileInfo, visibilityInfo) {\n    this.selector = selector;\n    this.option = option;\n    this.object_id = Extend.next_id++;\n    this.parent_ids = [this.object_id];\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n    switch (option) {\n        case 'all':\n            this.allowBefore = true;\n            this.allowAfter = true;\n            break;\n        default:\n            this.allowBefore = false;\n            this.allowAfter = false;\n            break;\n    }\n    this.setParent(this.selector, this);\n};\nExtend.prototype = Object.assign(new node_1.default(), {\n    type: 'Extend',\n    accept: function (visitor) {\n        this.selector = visitor.visit(this.selector);\n    },\n    eval: function (context) {\n        return new Extend(this.selector.eval(context), this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n    },\n    // remove when Nodes have JSDoc types\n    // eslint-disable-next-line no-unused-vars\n    clone: function (context) {\n        return new Extend(this.selector, this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n    },\n    // it concatenates (joins) all selectors in selector array\n    findSelfSelectors: function (selectors) {\n        var selfElements = [], i, selectorElements;\n        for (i = 0; i < selectors.length; i++) {\n            selectorElements = selectors[i].elements;\n            // duplicate the logic in genCSS function inside the selector node.\n            // future TODO - move both logics into the selector joiner visitor\n            if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === '') {\n                selectorElements[0].combinator.value = ' ';\n            }\n            selfElements = selfElements.concat(selectors[i].elements);\n        }\n        this.selfSelectors = [new selector_1.default(selfElements)];\n        this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());\n    }\n});\nExtend.next_id = 0;\nexports.default = Extend;\n//# sourceMappingURL=extend.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar variable_1 = tslib_1.__importDefault(require(\"./variable\"));\nvar ruleset_1 = tslib_1.__importDefault(require(\"./ruleset\"));\nvar detached_ruleset_1 = tslib_1.__importDefault(require(\"./detached-ruleset\"));\nvar less_error_1 = tslib_1.__importDefault(require(\"../less-error\"));\nvar VariableCall = function (variable, index, currentFileInfo) {\n    this.variable = variable;\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.allowRoot = true;\n};\nVariableCall.prototype = Object.assign(new node_1.default(), {\n    type: 'VariableCall',\n    eval: function (context) {\n        var rules;\n        var detachedRuleset = new variable_1.default(this.variable, this.getIndex(), this.fileInfo()).eval(context);\n        var error = new less_error_1.default({ message: \"Could not evaluate variable call \" + this.variable });\n        if (!detachedRuleset.ruleset) {\n            if (detachedRuleset.rules) {\n                rules = detachedRuleset;\n            }\n            else if (Array.isArray(detachedRuleset)) {\n                rules = new ruleset_1.default('', detachedRuleset);\n            }\n            else if (Array.isArray(detachedRuleset.value)) {\n                rules = new ruleset_1.default('', detachedRuleset.value);\n            }\n            else {\n                throw error;\n            }\n            detachedRuleset = new detached_ruleset_1.default(rules);\n        }\n        if (detachedRuleset.ruleset) {\n            return detachedRuleset.callEval(context);\n        }\n        throw error;\n    }\n});\nexports.default = VariableCall;\n//# sourceMappingURL=variable-call.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar variable_1 = tslib_1.__importDefault(require(\"./variable\"));\nvar ruleset_1 = tslib_1.__importDefault(require(\"./ruleset\"));\nvar selector_1 = tslib_1.__importDefault(require(\"./selector\"));\nvar NamespaceValue = function (ruleCall, lookups, index, fileInfo) {\n    this.value = ruleCall;\n    this.lookups = lookups;\n    this._index = index;\n    this._fileInfo = fileInfo;\n};\nNamespaceValue.prototype = Object.assign(new node_1.default(), {\n    type: 'NamespaceValue',\n    eval: function (context) {\n        var i, name, rules = this.value.eval(context);\n        for (i = 0; i < this.lookups.length; i++) {\n            name = this.lookups[i];\n            /**\n             * Eval'd DRs return rulesets.\n             * Eval'd mixins return rules, so let's make a ruleset if we need it.\n             * We need to do this because of late parsing of values\n             */\n            if (Array.isArray(rules)) {\n                rules = new ruleset_1.default([new selector_1.default()], rules);\n            }\n            if (name === '') {\n                rules = rules.lastDeclaration();\n            }\n            else if (name.charAt(0) === '@') {\n                if (name.charAt(1) === '@') {\n                    name = \"@\" + new variable_1.default(name.substr(1)).eval(context).value;\n                }\n                if (rules.variables) {\n                    rules = rules.variable(name);\n                }\n                if (!rules) {\n                    throw { type: 'Name',\n                        message: \"variable \" + name + \" not found\",\n                        filename: this.fileInfo().filename,\n                        index: this.getIndex() };\n                }\n            }\n            else {\n                if (name.substring(0, 2) === '$@') {\n                    name = \"$\" + new variable_1.default(name.substr(1)).eval(context).value;\n                }\n                else {\n                    name = name.charAt(0) === '$' ? name : \"$\" + name;\n                }\n                if (rules.properties) {\n                    rules = rules.property(name);\n                }\n                if (!rules) {\n                    throw { type: 'Name',\n                        message: \"property \\\"\" + name.substr(1) + \"\\\" not found\",\n                        filename: this.fileInfo().filename,\n                        index: this.getIndex() };\n                }\n                // Properties are an array of values, since a ruleset can have multiple props.\n                // We pick the last one (the \"cascaded\" value)\n                rules = rules[rules.length - 1];\n            }\n            if (rules.value) {\n                rules = rules.eval(context).value;\n            }\n            if (rules.ruleset) {\n                rules = rules.ruleset.eval(context);\n            }\n        }\n        return rules;\n    }\n});\nexports.default = NamespaceValue;\n//# sourceMappingURL=namespace-value.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar node_1 = tslib_1.__importDefault(require(\"./node\"));\nvar selector_1 = tslib_1.__importDefault(require(\"./selector\"));\nvar mixin_definition_1 = tslib_1.__importDefault(require(\"./mixin-definition\"));\nvar default_1 = tslib_1.__importDefault(require(\"../functions/default\"));\nvar MixinCall = function (elements, args, index, currentFileInfo, important) {\n    this.selector = new selector_1.default(elements);\n    this.arguments = args || [];\n    this._index = index;\n    this._fileInfo = currentFileInfo;\n    this.important = important;\n    this.allowRoot = true;\n    this.setParent(this.selector, this);\n};\nMixinCall.prototype = Object.assign(new node_1.default(), {\n    type: 'MixinCall',\n    accept: function (visitor) {\n        if (this.selector) {\n            this.selector = visitor.visit(this.selector);\n        }\n        if (this.arguments.length) {\n            this.arguments = visitor.visitArray(this.arguments);\n        }\n    },\n    eval: function (context) {\n        var mixins;\n        var mixin;\n        var mixinPath;\n        var args = [];\n        var arg;\n        var argValue;\n        var rules = [];\n        var match = false;\n        var i;\n        var m;\n        var f;\n        var isRecursive;\n        var isOneFound;\n        var candidates = [];\n        var candidate;\n        var conditionResult = [];\n        var defaultResult;\n        var defFalseEitherCase = -1;\n        var defNone = 0;\n        var defTrue = 1;\n        var defFalse = 2;\n        var count;\n        var originalRuleset;\n        var noArgumentsFilter;\n        this.selector = this.selector.eval(context);\n        function calcDefGroup(mixin, mixinPath) {\n            var f, p, namespace;\n            for (f = 0; f < 2; f++) {\n                conditionResult[f] = true;\n                default_1.default.value(f);\n                for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {\n                    namespace = mixinPath[p];\n                    if (namespace.matchCondition) {\n                        conditionResult[f] = conditionResult[f] && namespace.matchCondition(null, context);\n                    }\n                }\n                if (mixin.matchCondition) {\n                    conditionResult[f] = conditionResult[f] && mixin.matchCondition(args, context);\n                }\n            }\n            if (conditionResult[0] || conditionResult[1]) {\n                if (conditionResult[0] != conditionResult[1]) {\n                    return conditionResult[1] ?\n                        defTrue : defFalse;\n                }\n                return defNone;\n            }\n            return defFalseEitherCase;\n        }\n        for (i = 0; i < this.arguments.length; i++) {\n            arg = this.arguments[i];\n            argValue = arg.value.eval(context);\n            if (arg.expand && Array.isArray(argValue.value)) {\n                argValue = argValue.value;\n                for (m = 0; m < argValue.length; m++) {\n                    args.push({ value: argValue[m] });\n                }\n            }\n            else {\n                args.push({ name: arg.name, value: argValue });\n            }\n        }\n        noArgumentsFilter = function (rule) { return rule.matchArgs(null, context); };\n        for (i = 0; i < context.frames.length; i++) {\n            if ((mixins = context.frames[i].find(this.selector, null, noArgumentsFilter)).length > 0) {\n                isOneFound = true;\n                // To make `default()` function independent of definition order we have two \"subpasses\" here.\n                // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),\n                // and build candidate list with corresponding flags. Then, when we know all possible matches,\n                // we make a final decision.\n                for (m = 0; m < mixins.length; m++) {\n                    mixin = mixins[m].rule;\n                    mixinPath = mixins[m].path;\n                    isRecursive = false;\n                    for (f = 0; f < context.frames.length; f++) {\n                        if ((!(mixin instanceof mixin_definition_1.default)) && mixin === (context.frames[f].originalRuleset || context.frames[f])) {\n                            isRecursive = true;\n                            break;\n                        }\n                    }\n                    if (isRecursive) {\n                        continue;\n                    }\n                    if (mixin.matchArgs(args, context)) {\n                        candidate = { mixin: mixin, group: calcDefGroup(mixin, mixinPath) };\n                        if (candidate.group !== defFalseEitherCase) {\n                            candidates.push(candidate);\n                        }\n                        match = true;\n                    }\n                }\n                default_1.default.reset();\n                count = [0, 0, 0];\n                for (m = 0; m < candidates.length; m++) {\n                    count[candidates[m].group]++;\n                }\n                if (count[defNone] > 0) {\n                    defaultResult = defFalse;\n                }\n                else {\n                    defaultResult = defTrue;\n                    if ((count[defTrue] + count[defFalse]) > 1) {\n                        throw { type: 'Runtime',\n                            message: \"Ambiguous use of `default()` found when matching for `\" + this.format(args) + \"`\",\n                            index: this.getIndex(), filename: this.fileInfo().filename };\n                    }\n                }\n                for (m = 0; m < candidates.length; m++) {\n                    candidate = candidates[m].group;\n                    if ((candidate === defNone) || (candidate === defaultResult)) {\n                        try {\n                            mixin = candidates[m].mixin;\n                            if (!(mixin instanceof mixin_definition_1.default)) {\n                                originalRuleset = mixin.originalRuleset || mixin;\n                                mixin = new mixin_definition_1.default('', [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());\n                                mixin.originalRuleset = originalRuleset;\n                            }\n                            var newRules = mixin.evalCall(context, args, this.important).rules;\n                            this._setVisibilityToReplacement(newRules);\n                            Array.prototype.push.apply(rules, newRules);\n                        }\n                        catch (e) {\n                            throw { message: e.message, index: this.getIndex(), filename: this.fileInfo().filename, stack: e.stack };\n                        }\n                    }\n                }\n                if (match) {\n                    return rules;\n                }\n            }\n        }\n        if (isOneFound) {\n            throw { type: 'Runtime',\n                message: \"No matching definition was found for `\" + this.format(args) + \"`\",\n                index: this.getIndex(), filename: this.fileInfo().filename };\n        }\n        else {\n            throw { type: 'Name',\n                message: this.selector.toCSS().trim() + \" is undefined\",\n                index: this.getIndex(), filename: this.fileInfo().filename };\n        }\n    },\n    _setVisibilityToReplacement: function (replacement) {\n        var i, rule;\n        if (this.blocksVisibility()) {\n            for (i = 0; i < replacement.length; i++) {\n                rule = replacement[i];\n                rule.addVisibilityBlock();\n            }\n        }\n    },\n    format: function (args) {\n        return this.selector.toCSS().trim() + \"(\" + (args ? args.map(function (a) {\n            var argValue = '';\n            if (a.name) {\n                argValue += a.name + \":\";\n            }\n            if (a.value.toCSS) {\n                argValue += a.value.toCSS();\n            }\n            else {\n                argValue += '???';\n            }\n            return argValue;\n        }).join(', ') : '') + \")\";\n    }\n});\nexports.default = MixinCall;\n//# sourceMappingURL=mixin-call.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar selector_1 = tslib_1.__importDefault(require(\"./selector\"));\nvar element_1 = tslib_1.__importDefault(require(\"./element\"));\nvar ruleset_1 = tslib_1.__importDefault(require(\"./ruleset\"));\nvar declaration_1 = tslib_1.__importDefault(require(\"./declaration\"));\nvar detached_ruleset_1 = tslib_1.__importDefault(require(\"./detached-ruleset\"));\nvar expression_1 = tslib_1.__importDefault(require(\"./expression\"));\nvar contexts_1 = tslib_1.__importDefault(require(\"../contexts\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\nvar Definition = function (name, params, rules, condition, variadic, frames, visibilityInfo) {\n    this.name = name || 'anonymous mixin';\n    this.selectors = [new selector_1.default([new element_1.default(null, name, false, this._index, this._fileInfo)])];\n    this.params = params;\n    this.condition = condition;\n    this.variadic = variadic;\n    this.arity = params.length;\n    this.rules = rules;\n    this._lookups = {};\n    var optionalParameters = [];\n    this.required = params.reduce(function (count, p) {\n        if (!p.name || (p.name && !p.value)) {\n            return count + 1;\n        }\n        else {\n            optionalParameters.push(p.name);\n            return count;\n        }\n    }, 0);\n    this.optionalParameters = optionalParameters;\n    this.frames = frames;\n    this.copyVisibilityInfo(visibilityInfo);\n    this.allowRoot = true;\n};\nDefinition.prototype = Object.assign(new ruleset_1.default(), {\n    type: 'MixinDefinition',\n    evalFirst: true,\n    accept: function (visitor) {\n        if (this.params && this.params.length) {\n            this.params = visitor.visitArray(this.params);\n        }\n        this.rules = visitor.visitArray(this.rules);\n        if (this.condition) {\n            this.condition = visitor.visit(this.condition);\n        }\n    },\n    evalParams: function (context, mixinEnv, args, evaldArguments) {\n        /* jshint boss:true */\n        var frame = new ruleset_1.default(null, null);\n        var varargs;\n        var arg;\n        var params = utils.copyArray(this.params);\n        var i;\n        var j;\n        var val;\n        var name;\n        var isNamedFound;\n        var argIndex;\n        var argsLength = 0;\n        if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {\n            frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();\n        }\n        mixinEnv = new contexts_1.default.Eval(mixinEnv, [frame].concat(mixinEnv.frames));\n        if (args) {\n            args = utils.copyArray(args);\n            argsLength = args.length;\n            for (i = 0; i < argsLength; i++) {\n                arg = args[i];\n                if (name = (arg && arg.name)) {\n                    isNamedFound = false;\n                    for (j = 0; j < params.length; j++) {\n                        if (!evaldArguments[j] && name === params[j].name) {\n                            evaldArguments[j] = arg.value.eval(context);\n                            frame.prependRule(new declaration_1.default(name, arg.value.eval(context)));\n                            isNamedFound = true;\n                            break;\n                        }\n                    }\n                    if (isNamedFound) {\n                        args.splice(i, 1);\n                        i--;\n                        continue;\n                    }\n                    else {\n                        throw { type: 'Runtime', message: \"Named argument for \" + this.name + \" \" + args[i].name + \" not found\" };\n                    }\n                }\n            }\n        }\n        argIndex = 0;\n        for (i = 0; i < params.length; i++) {\n            if (evaldArguments[i]) {\n                continue;\n            }\n            arg = args && args[argIndex];\n            if (name = params[i].name) {\n                if (params[i].variadic) {\n                    varargs = [];\n                    for (j = argIndex; j < argsLength; j++) {\n                        varargs.push(args[j].value.eval(context));\n                    }\n                    frame.prependRule(new declaration_1.default(name, new expression_1.default(varargs).eval(context)));\n                }\n                else {\n                    val = arg && arg.value;\n                    if (val) {\n                        // This was a mixin call, pass in a detached ruleset of it's eval'd rules\n                        if (Array.isArray(val)) {\n                            val = new detached_ruleset_1.default(new ruleset_1.default('', val));\n                        }\n                        else {\n                            val = val.eval(context);\n                        }\n                    }\n                    else if (params[i].value) {\n                        val = params[i].value.eval(mixinEnv);\n                        frame.resetCache();\n                    }\n                    else {\n                        throw { type: 'Runtime', message: \"wrong number of arguments for \" + this.name + \" (\" + argsLength + \" for \" + this.arity + \")\" };\n                    }\n                    frame.prependRule(new declaration_1.default(name, val));\n                    evaldArguments[i] = val;\n                }\n            }\n            if (params[i].variadic && args) {\n                for (j = argIndex; j < argsLength; j++) {\n                    evaldArguments[j] = args[j].value.eval(context);\n                }\n            }\n            argIndex++;\n        }\n        return frame;\n    },\n    makeImportant: function () {\n        var rules = !this.rules ? this.rules : this.rules.map(function (r) {\n            if (r.makeImportant) {\n                return r.makeImportant(true);\n            }\n            else {\n                return r;\n            }\n        });\n        var result = new Definition(this.name, this.params, rules, this.condition, this.variadic, this.frames);\n        return result;\n    },\n    eval: function (context) {\n        return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || utils.copyArray(context.frames));\n    },\n    evalCall: function (context, args, important) {\n        var _arguments = [];\n        var mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames;\n        var frame = this.evalParams(context, new contexts_1.default.Eval(context, mixinFrames), args, _arguments);\n        var rules;\n        var ruleset;\n        frame.prependRule(new declaration_1.default('@arguments', new expression_1.default(_arguments).eval(context)));\n        rules = utils.copyArray(this.rules);\n        ruleset = new ruleset_1.default(null, rules);\n        ruleset.originalRuleset = this;\n        ruleset = ruleset.eval(new contexts_1.default.Eval(context, [this, frame].concat(mixinFrames)));\n        if (important) {\n            ruleset = ruleset.makeImportant();\n        }\n        return ruleset;\n    },\n    matchCondition: function (args, context) {\n        if (this.condition && !this.condition.eval(new contexts_1.default.Eval(context, [this.evalParams(context, /* the parameter variables */ new contexts_1.default.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])]\n            .concat(this.frames || []) // the parent namespace/mixin frames\n            .concat(context.frames)))) { // the current environment frames\n            return false;\n        }\n        return true;\n    },\n    matchArgs: function (args, context) {\n        var allArgsCnt = (args && args.length) || 0;\n        var len;\n        var optionalParameters = this.optionalParameters;\n        var requiredArgsCnt = !args ? 0 : args.reduce(function (count, p) {\n            if (optionalParameters.indexOf(p.name) < 0) {\n                return count + 1;\n            }\n            else {\n                return count;\n            }\n        }, 0);\n        if (!this.variadic) {\n            if (requiredArgsCnt < this.required) {\n                return false;\n            }\n            if (allArgsCnt > this.params.length) {\n                return false;\n            }\n        }\n        else {\n            if (requiredArgsCnt < (this.required - 1)) {\n                return false;\n            }\n        }\n        // check patterns\n        len = Math.min(requiredArgsCnt, this.arity);\n        for (var i = 0; i < len; i++) {\n            if (!this.params[i].name && !this.params[i].variadic) {\n                if (args[i].value.eval(context).toCSS() != this.params[i].value.eval(context).toCSS()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n});\nexports.default = Definition;\n//# sourceMappingURL=mixin-definition.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar function_registry_1 = tslib_1.__importDefault(require(\"../functions/function-registry\"));\nvar less_error_1 = tslib_1.__importDefault(require(\"../less-error\"));\nvar AbstractPluginLoader = /** @class */ (function () {\n    function AbstractPluginLoader() {\n        // Implemented by Node.js plugin loader\n        this.require = function () {\n            return null;\n        };\n    }\n    AbstractPluginLoader.prototype.evalPlugin = function (contents, context, imports, pluginOptions, fileInfo) {\n        var loader, registry, pluginObj, localModule, pluginManager, filename, result;\n        pluginManager = context.pluginManager;\n        if (fileInfo) {\n            if (typeof fileInfo === 'string') {\n                filename = fileInfo;\n            }\n            else {\n                filename = fileInfo.filename;\n            }\n        }\n        var shortname = (new this.less.FileManager()).extractUrlParts(filename).filename;\n        if (filename) {\n            pluginObj = pluginManager.get(filename);\n            if (pluginObj) {\n                result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n                if (result) {\n                    return result;\n                }\n                try {\n                    if (pluginObj.use) {\n                        pluginObj.use.call(this.context, pluginObj);\n                    }\n                }\n                catch (e) {\n                    e.message = e.message || 'Error during @plugin call';\n                    return new less_error_1.default(e, imports, filename);\n                }\n                return pluginObj;\n            }\n        }\n        localModule = {\n            exports: {},\n            pluginManager: pluginManager,\n            fileInfo: fileInfo\n        };\n        registry = function_registry_1.default.create();\n        var registerPlugin = function (obj) {\n            pluginObj = obj;\n        };\n        try {\n            loader = new Function('module', 'require', 'registerPlugin', 'functions', 'tree', 'less', 'fileInfo', contents);\n            loader(localModule, this.require(filename), registerPlugin, registry, this.less.tree, this.less, fileInfo);\n        }\n        catch (e) {\n            return new less_error_1.default(e, imports, filename);\n        }\n        if (!pluginObj) {\n            pluginObj = localModule.exports;\n        }\n        pluginObj = this.validatePlugin(pluginObj, filename, shortname);\n        if (pluginObj instanceof less_error_1.default) {\n            return pluginObj;\n        }\n        if (pluginObj) {\n            pluginObj.imports = imports;\n            pluginObj.filename = filename;\n            // For < 3.x (or unspecified minVersion) - setOptions() before install()\n            if (!pluginObj.minVersion || this.compareVersion('3.0.0', pluginObj.minVersion) < 0) {\n                result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n                if (result) {\n                    return result;\n                }\n            }\n            // Run on first load\n            pluginManager.addPlugin(pluginObj, fileInfo.filename, registry);\n            pluginObj.functions = registry.getLocalFunctions();\n            // Need to call setOptions again because the pluginObj might have functions\n            result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n            if (result) {\n                return result;\n            }\n            // Run every @plugin call\n            try {\n                if (pluginObj.use) {\n                    pluginObj.use.call(this.context, pluginObj);\n                }\n            }\n            catch (e) {\n                e.message = e.message || 'Error during @plugin call';\n                return new less_error_1.default(e, imports, filename);\n            }\n        }\n        else {\n            return new less_error_1.default({ message: 'Not a valid plugin' }, imports, filename);\n        }\n        return pluginObj;\n    };\n    AbstractPluginLoader.prototype.trySetOptions = function (plugin, filename, name, options) {\n        if (options && !plugin.setOptions) {\n            return new less_error_1.default({\n                message: \"Options have been provided but the plugin \" + name + \" does not support any options.\"\n            });\n        }\n        try {\n            plugin.setOptions && plugin.setOptions(options);\n        }\n        catch (e) {\n            return new less_error_1.default(e);\n        }\n    };\n    AbstractPluginLoader.prototype.validatePlugin = function (plugin, filename, name) {\n        if (plugin) {\n            // support plugins being a function\n            // so that the plugin can be more usable programmatically\n            if (typeof plugin === 'function') {\n                plugin = new plugin();\n            }\n            if (plugin.minVersion) {\n                if (this.compareVersion(plugin.minVersion, this.less.version) < 0) {\n                    return new less_error_1.default({\n                        message: \"Plugin \" + name + \" requires version \" + this.versionToString(plugin.minVersion)\n                    });\n                }\n            }\n            return plugin;\n        }\n        return null;\n    };\n    AbstractPluginLoader.prototype.compareVersion = function (aVersion, bVersion) {\n        if (typeof aVersion === 'string') {\n            aVersion = aVersion.match(/^(\\d+)\\.?(\\d+)?\\.?(\\d+)?/);\n            aVersion.shift();\n        }\n        for (var i = 0; i < aVersion.length; i++) {\n            if (aVersion[i] !== bVersion[i]) {\n                return parseInt(aVersion[i]) > parseInt(bVersion[i]) ? -1 : 1;\n            }\n        }\n        return 0;\n    };\n    AbstractPluginLoader.prototype.versionToString = function (version) {\n        var versionString = '';\n        for (var i = 0; i < version.length; i++) {\n            versionString += (versionString ? '.' : '') + version[i];\n        }\n        return versionString;\n    };\n    AbstractPluginLoader.prototype.printUsage = function (plugins) {\n        for (var i = 0; i < plugins.length; i++) {\n            var plugin = plugins[i];\n            if (plugin.printUsage) {\n                plugin.printUsage();\n            }\n        }\n    };\n    return AbstractPluginLoader;\n}());\nexports.default = AbstractPluginLoader;\n//# sourceMappingURL=abstract-plugin-loader.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar function_registry_1 = tslib_1.__importDefault(require(\"./function-registry\"));\nvar function_caller_1 = tslib_1.__importDefault(require(\"./function-caller\"));\nvar boolean_1 = tslib_1.__importDefault(require(\"./boolean\"));\nvar default_1 = tslib_1.__importDefault(require(\"./default\"));\nvar color_1 = tslib_1.__importDefault(require(\"./color\"));\nvar color_blending_1 = tslib_1.__importDefault(require(\"./color-blending\"));\nvar data_uri_1 = tslib_1.__importDefault(require(\"./data-uri\"));\nvar list_1 = tslib_1.__importDefault(require(\"./list\"));\nvar math_1 = tslib_1.__importDefault(require(\"./math\"));\nvar number_1 = tslib_1.__importDefault(require(\"./number\"));\nvar string_1 = tslib_1.__importDefault(require(\"./string\"));\nvar svg_1 = tslib_1.__importDefault(require(\"./svg\"));\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nexports.default = (function (environment) {\n    var functions = { functionRegistry: function_registry_1.default, functionCaller: function_caller_1.default };\n    // register functions\n    function_registry_1.default.addMultiple(boolean_1.default);\n    function_registry_1.default.add('default', default_1.default.eval.bind(default_1.default));\n    function_registry_1.default.addMultiple(color_1.default);\n    function_registry_1.default.addMultiple(color_blending_1.default);\n    function_registry_1.default.addMultiple(data_uri_1.default(environment));\n    function_registry_1.default.addMultiple(list_1.default);\n    function_registry_1.default.addMultiple(math_1.default);\n    function_registry_1.default.addMultiple(number_1.default);\n    function_registry_1.default.addMultiple(string_1.default);\n    function_registry_1.default.addMultiple(svg_1.default(environment));\n    function_registry_1.default.addMultiple(types_1.default);\n    return functions;\n});\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar anonymous_1 = tslib_1.__importDefault(require(\"../tree/anonymous\"));\nvar keyword_1 = tslib_1.__importDefault(require(\"../tree/keyword\"));\nfunction boolean(condition) {\n    return condition ? keyword_1.default.True : keyword_1.default.False;\n}\n/**\n * Functions with evalArgs set to false are sent context\n * as the first argument.\n */\nfunction If(context, condition, trueValue, falseValue) {\n    return condition.eval(context) ? trueValue.eval(context)\n        : (falseValue ? falseValue.eval(context) : new anonymous_1.default);\n}\nIf.evalArgs = false;\nfunction isdefined(context, variable) {\n    try {\n        variable.eval(context);\n        return keyword_1.default.True;\n    }\n    catch (e) {\n        return keyword_1.default.False;\n    }\n}\nisdefined.evalArgs = false;\nexports.default = { isdefined: isdefined, boolean: boolean, 'if': If };\n//# sourceMappingURL=boolean.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar dimension_1 = tslib_1.__importDefault(require(\"../tree/dimension\"));\nvar color_1 = tslib_1.__importDefault(require(\"../tree/color\"));\nvar quoted_1 = tslib_1.__importDefault(require(\"../tree/quoted\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"../tree/anonymous\"));\nvar expression_1 = tslib_1.__importDefault(require(\"../tree/expression\"));\nvar operation_1 = tslib_1.__importDefault(require(\"../tree/operation\"));\nvar colorFunctions;\nfunction clamp(val) {\n    return Math.min(1, Math.max(0, val));\n}\nfunction hsla(origColor, hsl) {\n    var color = colorFunctions.hsla(hsl.h, hsl.s, hsl.l, hsl.a);\n    if (color) {\n        if (origColor.value &&\n            /^(rgb|hsl)/.test(origColor.value)) {\n            color.value = origColor.value;\n        }\n        else {\n            color.value = 'rgb';\n        }\n        return color;\n    }\n}\nfunction toHSL(color) {\n    if (color.toHSL) {\n        return color.toHSL();\n    }\n    else {\n        throw new Error('Argument cannot be evaluated to a color');\n    }\n}\nfunction toHSV(color) {\n    if (color.toHSV) {\n        return color.toHSV();\n    }\n    else {\n        throw new Error('Argument cannot be evaluated to a color');\n    }\n}\nfunction number(n) {\n    if (n instanceof dimension_1.default) {\n        return parseFloat(n.unit.is('%') ? n.value / 100 : n.value);\n    }\n    else if (typeof n === 'number') {\n        return n;\n    }\n    else {\n        throw {\n            type: 'Argument',\n            message: 'color functions take numbers as parameters'\n        };\n    }\n}\nfunction scaled(n, size) {\n    if (n instanceof dimension_1.default && n.unit.is('%')) {\n        return parseFloat(n.value * size / 100);\n    }\n    else {\n        return number(n);\n    }\n}\ncolorFunctions = {\n    rgb: function (r, g, b) {\n        var a = 1;\n        /**\n         * Comma-less syntax\n         *   e.g. rgb(0 128 255 / 50%)\n         */\n        if (r instanceof expression_1.default) {\n            var val = r.value;\n            r = val[0];\n            g = val[1];\n            b = val[2];\n            /**\n             * @todo - should this be normalized in\n             *   function caller? Or parsed differently?\n             */\n            if (b instanceof operation_1.default) {\n                var op = b;\n                b = op.operands[0];\n                a = op.operands[1];\n            }\n        }\n        var color = colorFunctions.rgba(r, g, b, a);\n        if (color) {\n            color.value = 'rgb';\n            return color;\n        }\n    },\n    rgba: function (r, g, b, a) {\n        try {\n            if (r instanceof color_1.default) {\n                if (g) {\n                    a = number(g);\n                }\n                else {\n                    a = r.alpha;\n                }\n                return new color_1.default(r.rgb, a, 'rgba');\n            }\n            var rgb = [r, g, b].map(function (c) { return scaled(c, 255); });\n            a = number(a);\n            return new color_1.default(rgb, a, 'rgba');\n        }\n        catch (e) { }\n    },\n    hsl: function (h, s, l) {\n        var a = 1;\n        if (h instanceof expression_1.default) {\n            var val = h.value;\n            h = val[0];\n            s = val[1];\n            l = val[2];\n            if (l instanceof operation_1.default) {\n                var op = l;\n                l = op.operands[0];\n                a = op.operands[1];\n            }\n        }\n        var color = colorFunctions.hsla(h, s, l, a);\n        if (color) {\n            color.value = 'hsl';\n            return color;\n        }\n    },\n    hsla: function (h, s, l, a) {\n        var m1;\n        var m2;\n        function hue(h) {\n            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);\n            if (h * 6 < 1) {\n                return m1 + (m2 - m1) * h * 6;\n            }\n            else if (h * 2 < 1) {\n                return m2;\n            }\n            else if (h * 3 < 2) {\n                return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n            }\n            else {\n                return m1;\n            }\n        }\n        try {\n            if (h instanceof color_1.default) {\n                if (s) {\n                    a = number(s);\n                }\n                else {\n                    a = h.alpha;\n                }\n                return new color_1.default(h.rgb, a, 'hsla');\n            }\n            h = (number(h) % 360) / 360;\n            s = clamp(number(s));\n            l = clamp(number(l));\n            a = clamp(number(a));\n            m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n            m1 = l * 2 - m2;\n            var rgb = [\n                hue(h + 1 / 3) * 255,\n                hue(h) * 255,\n                hue(h - 1 / 3) * 255\n            ];\n            a = number(a);\n            return new color_1.default(rgb, a, 'hsla');\n        }\n        catch (e) { }\n    },\n    hsv: function (h, s, v) {\n        return colorFunctions.hsva(h, s, v, 1.0);\n    },\n    hsva: function (h, s, v, a) {\n        h = ((number(h) % 360) / 360) * 360;\n        s = number(s);\n        v = number(v);\n        a = number(a);\n        var i;\n        var f;\n        i = Math.floor((h / 60) % 6);\n        f = (h / 60) - i;\n        var vs = [v,\n            v * (1 - s),\n            v * (1 - f * s),\n            v * (1 - (1 - f) * s)];\n        var perm = [[0, 3, 1],\n            [2, 0, 1],\n            [1, 0, 3],\n            [1, 2, 0],\n            [3, 1, 0],\n            [0, 1, 2]];\n        return colorFunctions.rgba(vs[perm[i][0]] * 255, vs[perm[i][1]] * 255, vs[perm[i][2]] * 255, a);\n    },\n    hue: function (color) {\n        return new dimension_1.default(toHSL(color).h);\n    },\n    saturation: function (color) {\n        return new dimension_1.default(toHSL(color).s * 100, '%');\n    },\n    lightness: function (color) {\n        return new dimension_1.default(toHSL(color).l * 100, '%');\n    },\n    hsvhue: function (color) {\n        return new dimension_1.default(toHSV(color).h);\n    },\n    hsvsaturation: function (color) {\n        return new dimension_1.default(toHSV(color).s * 100, '%');\n    },\n    hsvvalue: function (color) {\n        return new dimension_1.default(toHSV(color).v * 100, '%');\n    },\n    red: function (color) {\n        return new dimension_1.default(color.rgb[0]);\n    },\n    green: function (color) {\n        return new dimension_1.default(color.rgb[1]);\n    },\n    blue: function (color) {\n        return new dimension_1.default(color.rgb[2]);\n    },\n    alpha: function (color) {\n        return new dimension_1.default(toHSL(color).a);\n    },\n    luma: function (color) {\n        return new dimension_1.default(color.luma() * color.alpha * 100, '%');\n    },\n    luminance: function (color) {\n        var luminance = (0.2126 * color.rgb[0] / 255) +\n            (0.7152 * color.rgb[1] / 255) +\n            (0.0722 * color.rgb[2] / 255);\n        return new dimension_1.default(luminance * color.alpha * 100, '%');\n    },\n    saturate: function (color, amount, method) {\n        // filter: saturate(3.2);\n        // should be kept as is, so check for color\n        if (!color.rgb) {\n            return null;\n        }\n        var hsl = toHSL(color);\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.s += hsl.s * amount.value / 100;\n        }\n        else {\n            hsl.s += amount.value / 100;\n        }\n        hsl.s = clamp(hsl.s);\n        return hsla(color, hsl);\n    },\n    desaturate: function (color, amount, method) {\n        var hsl = toHSL(color);\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.s -= hsl.s * amount.value / 100;\n        }\n        else {\n            hsl.s -= amount.value / 100;\n        }\n        hsl.s = clamp(hsl.s);\n        return hsla(color, hsl);\n    },\n    lighten: function (color, amount, method) {\n        var hsl = toHSL(color);\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.l += hsl.l * amount.value / 100;\n        }\n        else {\n            hsl.l += amount.value / 100;\n        }\n        hsl.l = clamp(hsl.l);\n        return hsla(color, hsl);\n    },\n    darken: function (color, amount, method) {\n        var hsl = toHSL(color);\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.l -= hsl.l * amount.value / 100;\n        }\n        else {\n            hsl.l -= amount.value / 100;\n        }\n        hsl.l = clamp(hsl.l);\n        return hsla(color, hsl);\n    },\n    fadein: function (color, amount, method) {\n        var hsl = toHSL(color);\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.a += hsl.a * amount.value / 100;\n        }\n        else {\n            hsl.a += amount.value / 100;\n        }\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    fadeout: function (color, amount, method) {\n        var hsl = toHSL(color);\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.a -= hsl.a * amount.value / 100;\n        }\n        else {\n            hsl.a -= amount.value / 100;\n        }\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    fade: function (color, amount) {\n        var hsl = toHSL(color);\n        hsl.a = amount.value / 100;\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    spin: function (color, amount) {\n        var hsl = toHSL(color);\n        var hue = (hsl.h + amount.value) % 360;\n        hsl.h = hue < 0 ? 360 + hue : hue;\n        return hsla(color, hsl);\n    },\n    //\n    // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein\n    // http://sass-lang.com\n    //\n    mix: function (color1, color2, weight) {\n        if (!weight) {\n            weight = new dimension_1.default(50);\n        }\n        var p = weight.value / 100.0;\n        var w = p * 2 - 1;\n        var a = toHSL(color1).a - toHSL(color2).a;\n        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2];\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n        return new color_1.default(rgb, alpha);\n    },\n    greyscale: function (color) {\n        return colorFunctions.desaturate(color, new dimension_1.default(100));\n    },\n    contrast: function (color, dark, light, threshold) {\n        // filter: contrast(3.2);\n        // should be kept as is, so check for color\n        if (!color.rgb) {\n            return null;\n        }\n        if (typeof light === 'undefined') {\n            light = colorFunctions.rgba(255, 255, 255, 1.0);\n        }\n        if (typeof dark === 'undefined') {\n            dark = colorFunctions.rgba(0, 0, 0, 1.0);\n        }\n        // Figure out which is actually light and dark:\n        if (dark.luma() > light.luma()) {\n            var t = light;\n            light = dark;\n            dark = t;\n        }\n        if (typeof threshold === 'undefined') {\n            threshold = 0.43;\n        }\n        else {\n            threshold = number(threshold);\n        }\n        if (color.luma() < threshold) {\n            return light;\n        }\n        else {\n            return dark;\n        }\n    },\n    // Changes made in 2.7.0 - Reverted in 3.0.0\n    // contrast: function (color, color1, color2, threshold) {\n    //     // Return which of `color1` and `color2` has the greatest contrast with `color`\n    //     // according to the standard WCAG contrast ratio calculation.\n    //     // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n    //     // The threshold param is no longer used, in line with SASS.\n    //     // filter: contrast(3.2);\n    //     // should be kept as is, so check for color\n    //     if (!color.rgb) {\n    //         return null;\n    //     }\n    //     if (typeof color1 === 'undefined') {\n    //         color1 = colorFunctions.rgba(0, 0, 0, 1.0);\n    //     }\n    //     if (typeof color2 === 'undefined') {\n    //         color2 = colorFunctions.rgba(255, 255, 255, 1.0);\n    //     }\n    //     var contrast1, contrast2;\n    //     var luma = color.luma();\n    //     var luma1 = color1.luma();\n    //     var luma2 = color2.luma();\n    //     // Calculate contrast ratios for each color\n    //     if (luma > luma1) {\n    //         contrast1 = (luma + 0.05) / (luma1 + 0.05);\n    //     } else {\n    //         contrast1 = (luma1 + 0.05) / (luma + 0.05);\n    //     }\n    //     if (luma > luma2) {\n    //         contrast2 = (luma + 0.05) / (luma2 + 0.05);\n    //     } else {\n    //         contrast2 = (luma2 + 0.05) / (luma + 0.05);\n    //     }\n    //     if (contrast1 > contrast2) {\n    //         return color1;\n    //     } else {\n    //         return color2;\n    //     }\n    // },\n    argb: function (color) {\n        return new anonymous_1.default(color.toARGB());\n    },\n    color: function (c) {\n        if ((c instanceof quoted_1.default) &&\n            (/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})$/i.test(c.value))) {\n            var val = c.value.slice(1);\n            return new color_1.default(val, undefined, \"#\" + val);\n        }\n        if ((c instanceof color_1.default) || (c = color_1.default.fromKeyword(c.value))) {\n            c.value = undefined;\n            return c;\n        }\n        throw {\n            type: 'Argument',\n            message: 'argument must be a color keyword or 3|4|6|8 digit hex e.g. #FFF'\n        };\n    },\n    tint: function (color, amount) {\n        return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount);\n    },\n    shade: function (color, amount) {\n        return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount);\n    }\n};\nexports.default = colorFunctions;\n//# sourceMappingURL=color.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar color_1 = tslib_1.__importDefault(require(\"../tree/color\"));\n// Color Blending\n// ref: http://www.w3.org/TR/compositing-1\nfunction colorBlend(mode, color1, color2) {\n    var ab = color1.alpha; // result\n    var // backdrop\n    cb;\n    var as = color2.alpha;\n    var // source\n    cs;\n    var ar;\n    var cr;\n    var r = [];\n    ar = as + ab * (1 - as);\n    for (var i = 0; i < 3; i++) {\n        cb = color1.rgb[i] / 255;\n        cs = color2.rgb[i] / 255;\n        cr = mode(cb, cs);\n        if (ar) {\n            cr = (as * cs + ab * (cb -\n                as * (cb + cs - cr))) / ar;\n        }\n        r[i] = cr * 255;\n    }\n    return new color_1.default(r, ar);\n}\nvar colorBlendModeFunctions = {\n    multiply: function (cb, cs) {\n        return cb * cs;\n    },\n    screen: function (cb, cs) {\n        return cb + cs - cb * cs;\n    },\n    overlay: function (cb, cs) {\n        cb *= 2;\n        return (cb <= 1) ?\n            colorBlendModeFunctions.multiply(cb, cs) :\n            colorBlendModeFunctions.screen(cb - 1, cs);\n    },\n    softlight: function (cb, cs) {\n        var d = 1;\n        var e = cb;\n        if (cs > 0.5) {\n            e = 1;\n            d = (cb > 0.25) ? Math.sqrt(cb)\n                : ((16 * cb - 12) * cb + 4) * cb;\n        }\n        return cb - (1 - 2 * cs) * e * (d - cb);\n    },\n    hardlight: function (cb, cs) {\n        return colorBlendModeFunctions.overlay(cs, cb);\n    },\n    difference: function (cb, cs) {\n        return Math.abs(cb - cs);\n    },\n    exclusion: function (cb, cs) {\n        return cb + cs - 2 * cb * cs;\n    },\n    // non-w3c functions:\n    average: function (cb, cs) {\n        return (cb + cs) / 2;\n    },\n    negation: function (cb, cs) {\n        return 1 - Math.abs(cb + cs - 1);\n    }\n};\nfor (var f in colorBlendModeFunctions) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (colorBlendModeFunctions.hasOwnProperty(f)) {\n        colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f]);\n    }\n}\nexports.default = colorBlend;\n//# sourceMappingURL=color-blending.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar quoted_1 = tslib_1.__importDefault(require(\"../tree/quoted\"));\nvar url_1 = tslib_1.__importDefault(require(\"../tree/url\"));\nvar utils = tslib_1.__importStar(require(\"../utils\"));\nvar logger_1 = tslib_1.__importDefault(require(\"../logger\"));\nexports.default = (function (environment) {\n    var fallback = function (functionThis, node) { return new url_1.default(node, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context); };\n    return { 'data-uri': function (mimetypeNode, filePathNode) {\n            if (!filePathNode) {\n                filePathNode = mimetypeNode;\n                mimetypeNode = null;\n            }\n            var mimetype = mimetypeNode && mimetypeNode.value;\n            var filePath = filePathNode.value;\n            var currentFileInfo = this.currentFileInfo;\n            var currentDirectory = currentFileInfo.rewriteUrls ?\n                currentFileInfo.currentDirectory : currentFileInfo.entryPath;\n            var fragmentStart = filePath.indexOf('#');\n            var fragment = '';\n            if (fragmentStart !== -1) {\n                fragment = filePath.slice(fragmentStart);\n                filePath = filePath.slice(0, fragmentStart);\n            }\n            var context = utils.clone(this.context);\n            context.rawBuffer = true;\n            var fileManager = environment.getFileManager(filePath, currentDirectory, context, environment, true);\n            if (!fileManager) {\n                return fallback(this, filePathNode);\n            }\n            var useBase64 = false;\n            // detect the mimetype if not given\n            if (!mimetypeNode) {\n                mimetype = environment.mimeLookup(filePath);\n                if (mimetype === 'image/svg+xml') {\n                    useBase64 = false;\n                }\n                else {\n                    // use base 64 unless it's an ASCII or UTF-8 format\n                    var charset = environment.charsetLookup(mimetype);\n                    useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0;\n                }\n                if (useBase64) {\n                    mimetype += ';base64';\n                }\n            }\n            else {\n                useBase64 = /;base64$/.test(mimetype);\n            }\n            var fileSync = fileManager.loadFileSync(filePath, currentDirectory, context, environment);\n            if (!fileSync.contents) {\n                logger_1.default.warn(\"Skipped data-uri embedding of \" + filePath + \" because file not found\");\n                return fallback(this, filePathNode || mimetypeNode);\n            }\n            var buf = fileSync.contents;\n            if (useBase64 && !environment.encodeBase64) {\n                return fallback(this, filePathNode);\n            }\n            buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);\n            var uri = \"data:\" + mimetype + \",\" + buf + fragment;\n            return new url_1.default(new quoted_1.default(\"\\\"\" + uri + \"\\\"\", uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);\n        } };\n});\n//# sourceMappingURL=data-uri.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar comment_1 = tslib_1.__importDefault(require(\"../tree/comment\"));\nvar node_1 = tslib_1.__importDefault(require(\"../tree/node\"));\nvar dimension_1 = tslib_1.__importDefault(require(\"../tree/dimension\"));\nvar declaration_1 = tslib_1.__importDefault(require(\"../tree/declaration\"));\nvar expression_1 = tslib_1.__importDefault(require(\"../tree/expression\"));\nvar ruleset_1 = tslib_1.__importDefault(require(\"../tree/ruleset\"));\nvar selector_1 = tslib_1.__importDefault(require(\"../tree/selector\"));\nvar element_1 = tslib_1.__importDefault(require(\"../tree/element\"));\nvar quoted_1 = tslib_1.__importDefault(require(\"../tree/quoted\"));\nvar value_1 = tslib_1.__importDefault(require(\"../tree/value\"));\nvar getItemsFromNode = function (node) {\n    // handle non-array values as an array of length 1\n    // return 'undefined' if index is invalid\n    var items = Array.isArray(node.value) ?\n        node.value : Array(node);\n    return items;\n};\nexports.default = {\n    _SELF: function (n) {\n        return n;\n    },\n    '~': function () {\n        var expr = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            expr[_i] = arguments[_i];\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        return new value_1.default(expr);\n    },\n    extract: function (values, index) {\n        // (1-based index)\n        index = index.value - 1;\n        return getItemsFromNode(values)[index];\n    },\n    length: function (values) {\n        return new dimension_1.default(getItemsFromNode(values).length);\n    },\n    /**\n     * Creates a Less list of incremental values.\n     * Modeled after Lodash's range function, also exists natively in PHP\n     *\n     * @param {Dimension} [start=1]\n     * @param {Dimension} end  - e.g. 10 or 10px - unit is added to output\n     * @param {Dimension} [step=1]\n     */\n    range: function (start, end, step) {\n        var from;\n        var to;\n        var stepValue = 1;\n        var list = [];\n        if (end) {\n            to = end;\n            from = start.value;\n            if (step) {\n                stepValue = step.value;\n            }\n        }\n        else {\n            from = 1;\n            to = start;\n        }\n        for (var i = from; i <= to.value; i += stepValue) {\n            list.push(new dimension_1.default(i, to.unit));\n        }\n        return new expression_1.default(list);\n    },\n    each: function (list, rs) {\n        var _this = this;\n        var rules = [];\n        var newRules;\n        var iterator;\n        var tryEval = function (val) {\n            if (val instanceof node_1.default) {\n                return val.eval(_this.context);\n            }\n            return val;\n        };\n        if (list.value && !(list instanceof quoted_1.default)) {\n            if (Array.isArray(list.value)) {\n                iterator = list.value.map(tryEval);\n            }\n            else {\n                iterator = [tryEval(list.value)];\n            }\n        }\n        else if (list.ruleset) {\n            iterator = tryEval(list.ruleset).rules;\n        }\n        else if (list.rules) {\n            iterator = list.rules.map(tryEval);\n        }\n        else if (Array.isArray(list)) {\n            iterator = list.map(tryEval);\n        }\n        else {\n            iterator = [tryEval(list)];\n        }\n        var valueName = '@value';\n        var keyName = '@key';\n        var indexName = '@index';\n        if (rs.params) {\n            valueName = rs.params[0] && rs.params[0].name;\n            keyName = rs.params[1] && rs.params[1].name;\n            indexName = rs.params[2] && rs.params[2].name;\n            rs = rs.rules;\n        }\n        else {\n            rs = rs.ruleset;\n        }\n        for (var i = 0; i < iterator.length; i++) {\n            var key = void 0;\n            var value = void 0;\n            var item = iterator[i];\n            if (item instanceof declaration_1.default) {\n                key = typeof item.name === 'string' ? item.name : item.name[0].value;\n                value = item.value;\n            }\n            else {\n                key = new dimension_1.default(i + 1);\n                value = item;\n            }\n            if (item instanceof comment_1.default) {\n                continue;\n            }\n            newRules = rs.rules.slice(0);\n            if (valueName) {\n                newRules.push(new declaration_1.default(valueName, value, false, false, this.index, this.currentFileInfo));\n            }\n            if (indexName) {\n                newRules.push(new declaration_1.default(indexName, new dimension_1.default(i + 1), false, false, this.index, this.currentFileInfo));\n            }\n            if (keyName) {\n                newRules.push(new declaration_1.default(keyName, key, false, false, this.index, this.currentFileInfo));\n            }\n            rules.push(new ruleset_1.default([new (selector_1.default)([new element_1.default('', '&')])], newRules, rs.strictImports, rs.visibilityInfo()));\n        }\n        return new ruleset_1.default([new (selector_1.default)([new element_1.default('', '&')])], rules, rs.strictImports, rs.visibilityInfo()).eval(this.context);\n    }\n};\n//# sourceMappingURL=list.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar math_helper_js_1 = tslib_1.__importDefault(require(\"./math-helper.js\"));\nvar mathFunctions = {\n    // name,  unit\n    ceil: null,\n    floor: null,\n    sqrt: null,\n    abs: null,\n    tan: '',\n    sin: '',\n    cos: '',\n    atan: 'rad',\n    asin: 'rad',\n    acos: 'rad'\n};\nfor (var f in mathFunctions) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (mathFunctions.hasOwnProperty(f)) {\n        mathFunctions[f] = math_helper_js_1.default.bind(null, Math[f], mathFunctions[f]);\n    }\n}\nmathFunctions.round = function (n, f) {\n    var fraction = typeof f === 'undefined' ? 0 : f.value;\n    return math_helper_js_1.default(function (num) { return num.toFixed(fraction); }, null, n);\n};\nexports.default = mathFunctions;\n//# sourceMappingURL=math.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar dimension_1 = tslib_1.__importDefault(require(\"../tree/dimension\"));\nvar MathHelper = function (fn, unit, n) {\n    if (!(n instanceof dimension_1.default)) {\n        throw { type: 'Argument', message: 'argument must be a number' };\n    }\n    if (unit === null) {\n        unit = n.unit;\n    }\n    else {\n        n = n.unify();\n    }\n    return new dimension_1.default(fn(parseFloat(n.value)), unit);\n};\nexports.default = MathHelper;\n//# sourceMappingURL=math-helper.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar dimension_1 = tslib_1.__importDefault(require(\"../tree/dimension\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"../tree/anonymous\"));\nvar math_helper_js_1 = tslib_1.__importDefault(require(\"./math-helper.js\"));\nvar minMax = function (isMin, args) {\n    var _this = this;\n    args = Array.prototype.slice.call(args);\n    switch (args.length) {\n        case 0: throw { type: 'Argument', message: 'one or more arguments required' };\n    }\n    var i; // key is the unit.toString() for unified Dimension values,\n    var j;\n    var current;\n    var currentUnified;\n    var referenceUnified;\n    var unit;\n    var unitStatic;\n    var unitClone;\n    var // elems only contains original argument values.\n    order = [];\n    var values = {};\n    // value is the index into the order array.\n    for (i = 0; i < args.length; i++) {\n        current = args[i];\n        if (!(current instanceof dimension_1.default)) {\n            if (Array.isArray(args[i].value)) {\n                Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));\n            }\n            continue;\n        }\n        currentUnified = current.unit.toString() === '' && unitClone !== undefined ? new dimension_1.default(current.value, unitClone).unify() : current.unify();\n        unit = currentUnified.unit.toString() === '' && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();\n        unitStatic = unit !== '' && unitStatic === undefined || unit !== '' && order[0].unify().unit.toString() === '' ? unit : unitStatic;\n        unitClone = unit !== '' && unitClone === undefined ? current.unit.toString() : unitClone;\n        j = values[''] !== undefined && unit !== '' && unit === unitStatic ? values[''] : values[unit];\n        if (j === undefined) {\n            if (unitStatic !== undefined && unit !== unitStatic) {\n                throw { type: 'Argument', message: 'incompatible types' };\n            }\n            values[unit] = order.length;\n            order.push(current);\n            continue;\n        }\n        referenceUnified = order[j].unit.toString() === '' && unitClone !== undefined ? new dimension_1.default(order[j].value, unitClone).unify() : order[j].unify();\n        if (isMin && currentUnified.value < referenceUnified.value ||\n            !isMin && currentUnified.value > referenceUnified.value) {\n            order[j] = current;\n        }\n    }\n    if (order.length == 1) {\n        return order[0];\n    }\n    args = order.map(function (a) { return a.toCSS(_this.context); }).join(this.context.compress ? ',' : ', ');\n    return new anonymous_1.default((isMin ? 'min' : 'max') + \"(\" + args + \")\");\n};\nexports.default = {\n    min: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        try {\n            return minMax.call(this, true, args);\n        }\n        catch (e) { }\n    },\n    max: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        try {\n            return minMax.call(this, false, args);\n        }\n        catch (e) { }\n    },\n    convert: function (val, unit) {\n        return val.convertTo(unit.value);\n    },\n    pi: function () {\n        return new dimension_1.default(Math.PI);\n    },\n    mod: function (a, b) {\n        return new dimension_1.default(a.value % b.value, a.unit);\n    },\n    pow: function (x, y) {\n        if (typeof x === 'number' && typeof y === 'number') {\n            x = new dimension_1.default(x);\n            y = new dimension_1.default(y);\n        }\n        else if (!(x instanceof dimension_1.default) || !(y instanceof dimension_1.default)) {\n            throw { type: 'Argument', message: 'arguments must be numbers' };\n        }\n        return new dimension_1.default(Math.pow(x.value, y.value), x.unit);\n    },\n    percentage: function (n) {\n        var result = math_helper_js_1.default(function (num) { return num * 100; }, '%', n);\n        return result;\n    }\n};\n//# sourceMappingURL=number.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar quoted_1 = tslib_1.__importDefault(require(\"../tree/quoted\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"../tree/anonymous\"));\nvar javascript_1 = tslib_1.__importDefault(require(\"../tree/javascript\"));\nexports.default = {\n    e: function (str) {\n        return new quoted_1.default('\"', str instanceof javascript_1.default ? str.evaluated : str.value, true);\n    },\n    escape: function (str) {\n        return new anonymous_1.default(encodeURI(str.value).replace(/=/g, '%3D').replace(/:/g, '%3A').replace(/#/g, '%23').replace(/;/g, '%3B')\n            .replace(/\\(/g, '%28').replace(/\\)/g, '%29'));\n    },\n    replace: function (string, pattern, replacement, flags) {\n        var result = string.value;\n        replacement = (replacement.type === 'Quoted') ?\n            replacement.value : replacement.toCSS();\n        result = result.replace(new RegExp(pattern.value, flags ? flags.value : ''), replacement);\n        return new quoted_1.default(string.quote || '', result, string.escaped);\n    },\n    '%': function (string /* arg, arg, ... */) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        var result = string.value;\n        var _loop_1 = function (i) {\n            /* jshint loopfunc:true */\n            result = result.replace(/%[sda]/i, function (token) {\n                var value = ((args[i].type === 'Quoted') &&\n                    token.match(/s/i)) ? args[i].value : args[i].toCSS();\n                return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;\n            });\n        };\n        for (var i = 0; i < args.length; i++) {\n            _loop_1(i);\n        }\n        result = result.replace(/%%/g, '%');\n        return new quoted_1.default(string.quote || '', result, string.escaped);\n    }\n};\n//# sourceMappingURL=string.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar dimension_1 = tslib_1.__importDefault(require(\"../tree/dimension\"));\nvar color_1 = tslib_1.__importDefault(require(\"../tree/color\"));\nvar expression_1 = tslib_1.__importDefault(require(\"../tree/expression\"));\nvar quoted_1 = tslib_1.__importDefault(require(\"../tree/quoted\"));\nvar url_1 = tslib_1.__importDefault(require(\"../tree/url\"));\nexports.default = (function () {\n    return { 'svg-gradient': function (direction) {\n            var stops;\n            var gradientDirectionSvg;\n            var gradientType = 'linear';\n            var rectangleDimension = 'x=\"0\" y=\"0\" width=\"1\" height=\"1\"';\n            var renderEnv = { compress: false };\n            var returner;\n            var directionValue = direction.toCSS(renderEnv);\n            var i;\n            var color;\n            var position;\n            var positionValue;\n            var alpha;\n            function throwArgumentDescriptor() {\n                throw { type: 'Argument',\n                    message: 'svg-gradient expects direction, start_color [start_position], [color position,]...,' +\n                        ' end_color [end_position] or direction, color list' };\n            }\n            if (arguments.length == 2) {\n                if (arguments[1].value.length < 2) {\n                    throwArgumentDescriptor();\n                }\n                stops = arguments[1].value;\n            }\n            else if (arguments.length < 3) {\n                throwArgumentDescriptor();\n            }\n            else {\n                stops = Array.prototype.slice.call(arguments, 1);\n            }\n            switch (directionValue) {\n                case 'to bottom':\n                    gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"';\n                    break;\n                case 'to right':\n                    gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"';\n                    break;\n                case 'to bottom right':\n                    gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\"';\n                    break;\n                case 'to top right':\n                    gradientDirectionSvg = 'x1=\"0%\" y1=\"100%\" x2=\"100%\" y2=\"0%\"';\n                    break;\n                case 'ellipse':\n                case 'ellipse at center':\n                    gradientType = 'radial';\n                    gradientDirectionSvg = 'cx=\"50%\" cy=\"50%\" r=\"75%\"';\n                    rectangleDimension = 'x=\"-50\" y=\"-50\" width=\"101\" height=\"101\"';\n                    break;\n                default:\n                    throw { type: 'Argument', message: 'svg-gradient direction must be \\'to bottom\\', \\'to right\\',' +\n                            ' \\'to bottom right\\', \\'to top right\\' or \\'ellipse at center\\'' };\n            }\n            returner = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 1 1\\\"><\" + gradientType + \"Gradient id=\\\"g\\\" \" + gradientDirectionSvg + \">\";\n            for (i = 0; i < stops.length; i += 1) {\n                if (stops[i] instanceof expression_1.default) {\n                    color = stops[i].value[0];\n                    position = stops[i].value[1];\n                }\n                else {\n                    color = stops[i];\n                    position = undefined;\n                }\n                if (!(color instanceof color_1.default) || (!((i === 0 || i + 1 === stops.length) && position === undefined) && !(position instanceof dimension_1.default))) {\n                    throwArgumentDescriptor();\n                }\n                positionValue = position ? position.toCSS(renderEnv) : i === 0 ? '0%' : '100%';\n                alpha = color.alpha;\n                returner += \"<stop offset=\\\"\" + positionValue + \"\\\" stop-color=\\\"\" + color.toRGB() + \"\\\"\" + (alpha < 1 ? \" stop-opacity=\\\"\" + alpha + \"\\\"\" : '') + \"/>\";\n            }\n            returner += \"</\" + gradientType + \"Gradient><rect \" + rectangleDimension + \" fill=\\\"url(#g)\\\" /></svg>\";\n            returner = encodeURIComponent(returner);\n            returner = \"data:image/svg+xml,\" + returner;\n            return new url_1.default(new quoted_1.default(\"'\" + returner + \"'\", returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);\n        } };\n});\n//# sourceMappingURL=svg.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar keyword_1 = tslib_1.__importDefault(require(\"../tree/keyword\"));\nvar detached_ruleset_1 = tslib_1.__importDefault(require(\"../tree/detached-ruleset\"));\nvar dimension_1 = tslib_1.__importDefault(require(\"../tree/dimension\"));\nvar color_1 = tslib_1.__importDefault(require(\"../tree/color\"));\nvar quoted_1 = tslib_1.__importDefault(require(\"../tree/quoted\"));\nvar anonymous_1 = tslib_1.__importDefault(require(\"../tree/anonymous\"));\nvar url_1 = tslib_1.__importDefault(require(\"../tree/url\"));\nvar operation_1 = tslib_1.__importDefault(require(\"../tree/operation\"));\nvar isa = function (n, Type) { return (n instanceof Type) ? keyword_1.default.True : keyword_1.default.False; };\nvar isunit = function (n, unit) {\n    if (unit === undefined) {\n        throw { type: 'Argument', message: 'missing the required second argument to isunit.' };\n    }\n    unit = typeof unit.value === 'string' ? unit.value : unit;\n    if (typeof unit !== 'string') {\n        throw { type: 'Argument', message: 'Second argument to isunit should be a unit or a string.' };\n    }\n    return (n instanceof dimension_1.default) && n.unit.is(unit) ? keyword_1.default.True : keyword_1.default.False;\n};\nexports.default = {\n    isruleset: function (n) {\n        return isa(n, detached_ruleset_1.default);\n    },\n    iscolor: function (n) {\n        return isa(n, color_1.default);\n    },\n    isnumber: function (n) {\n        return isa(n, dimension_1.default);\n    },\n    isstring: function (n) {\n        return isa(n, quoted_1.default);\n    },\n    iskeyword: function (n) {\n        return isa(n, keyword_1.default);\n    },\n    isurl: function (n) {\n        return isa(n, url_1.default);\n    },\n    ispixel: function (n) {\n        return isunit(n, 'px');\n    },\n    ispercentage: function (n) {\n        return isunit(n, '%');\n    },\n    isem: function (n) {\n        return isunit(n, 'em');\n    },\n    isunit: isunit,\n    unit: function (val, unit) {\n        if (!(val instanceof dimension_1.default)) {\n            throw { type: 'Argument',\n                message: \"the first argument to unit must be a number\" + (val instanceof operation_1.default ? '. Have you forgotten parenthesis?' : '') };\n        }\n        if (unit) {\n            if (unit instanceof keyword_1.default) {\n                unit = unit.value;\n            }\n            else {\n                unit = unit.toCSS();\n            }\n        }\n        else {\n            unit = '';\n        }\n        return new dimension_1.default(val.value, unit);\n    },\n    'get-unit': function (n) {\n        return new anonymous_1.default(n.unit);\n    }\n};\n//# sourceMappingURL=types.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar contexts_1 = tslib_1.__importDefault(require(\"./contexts\"));\nvar visitors_1 = tslib_1.__importDefault(require(\"./visitors\"));\nvar tree_1 = tslib_1.__importDefault(require(\"./tree\"));\nfunction default_1(root, options) {\n    options = options || {};\n    var evaldRoot;\n    var variables = options.variables;\n    var evalEnv = new contexts_1.default.Eval(options);\n    //\n    // Allows setting variables with a hash, so:\n    //\n    //   `{ color: new tree.Color('#f01') }` will become:\n    //\n    //   new tree.Declaration('@color',\n    //     new tree.Value([\n    //       new tree.Expression([\n    //         new tree.Color('#f01')\n    //       ])\n    //     ])\n    //   )\n    //\n    if (typeof variables === 'object' && !Array.isArray(variables)) {\n        variables = Object.keys(variables).map(function (k) {\n            var value = variables[k];\n            if (!(value instanceof tree_1.default.Value)) {\n                if (!(value instanceof tree_1.default.Expression)) {\n                    value = new tree_1.default.Expression([value]);\n                }\n                value = new tree_1.default.Value([value]);\n            }\n            return new tree_1.default.Declaration(\"@\" + k, value, false, null, 0);\n        });\n        evalEnv.frames = [new tree_1.default.Ruleset(null, variables)];\n    }\n    var visitors = [\n        new visitors_1.default.JoinSelectorVisitor(),\n        new visitors_1.default.MarkVisibleSelectorsVisitor(true),\n        new visitors_1.default.ExtendVisitor(),\n        new visitors_1.default.ToCSSVisitor({ compress: Boolean(options.compress) })\n    ];\n    var preEvalVisitors = [];\n    var v;\n    var visitorIterator;\n    /**\n     * first() / get() allows visitors to be added while visiting\n     *\n     * @todo Add scoping for visitors just like functions for @plugin; right now they're global\n     */\n    if (options.pluginManager) {\n        visitorIterator = options.pluginManager.visitor();\n        for (var i = 0; i < 2; i++) {\n            visitorIterator.first();\n            while ((v = visitorIterator.get())) {\n                if (v.isPreEvalVisitor) {\n                    if (i === 0 || preEvalVisitors.indexOf(v) === -1) {\n                        preEvalVisitors.push(v);\n                        v.run(root);\n                    }\n                }\n                else {\n                    if (i === 0 || visitors.indexOf(v) === -1) {\n                        if (v.isPreVisitor) {\n                            visitors.unshift(v);\n                        }\n                        else {\n                            visitors.push(v);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    evaldRoot = root.eval(evalEnv);\n    for (var i = 0; i < visitors.length; i++) {\n        visitors[i].run(evaldRoot);\n    }\n    // Run any remaining visitors added after eval pass\n    if (options.pluginManager) {\n        visitorIterator.first();\n        while ((v = visitorIterator.get())) {\n            if (visitors.indexOf(v) === -1 && preEvalVisitors.indexOf(v) === -1) {\n                v.run(evaldRoot);\n            }\n        }\n    }\n    return evaldRoot;\n}\nexports.default = default_1;\n//# sourceMappingURL=transform-tree.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Plugin Manager\n */\nvar PluginManager = /** @class */ (function () {\n    function PluginManager(less) {\n        this.less = less;\n        this.visitors = [];\n        this.preProcessors = [];\n        this.postProcessors = [];\n        this.installedPlugins = [];\n        this.fileManagers = [];\n        this.iterator = -1;\n        this.pluginCache = {};\n        this.Loader = new less.PluginLoader(less);\n    }\n    /**\n     * Adds all the plugins in the array\n     * @param {Array} plugins\n     */\n    PluginManager.prototype.addPlugins = function (plugins) {\n        if (plugins) {\n            for (var i = 0; i < plugins.length; i++) {\n                this.addPlugin(plugins[i]);\n            }\n        }\n    };\n    /**\n     *\n     * @param plugin\n     * @param {String} filename\n     */\n    PluginManager.prototype.addPlugin = function (plugin, filename, functionRegistry) {\n        this.installedPlugins.push(plugin);\n        if (filename) {\n            this.pluginCache[filename] = plugin;\n        }\n        if (plugin.install) {\n            plugin.install(this.less, this, functionRegistry || this.less.functions.functionRegistry);\n        }\n    };\n    /**\n     *\n     * @param filename\n     */\n    PluginManager.prototype.get = function (filename) {\n        return this.pluginCache[filename];\n    };\n    /**\n     * Adds a visitor. The visitor object has options on itself to determine\n     * when it should run.\n     * @param visitor\n     */\n    PluginManager.prototype.addVisitor = function (visitor) {\n        this.visitors.push(visitor);\n    };\n    /**\n     * Adds a pre processor object\n     * @param {object} preProcessor\n     * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import\n     */\n    PluginManager.prototype.addPreProcessor = function (preProcessor, priority) {\n        var indexToInsertAt;\n        for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {\n            if (this.preProcessors[indexToInsertAt].priority >= priority) {\n                break;\n            }\n        }\n        this.preProcessors.splice(indexToInsertAt, 0, { preProcessor: preProcessor, priority: priority });\n    };\n    /**\n     * Adds a post processor object\n     * @param {object} postProcessor\n     * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression\n     */\n    PluginManager.prototype.addPostProcessor = function (postProcessor, priority) {\n        var indexToInsertAt;\n        for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {\n            if (this.postProcessors[indexToInsertAt].priority >= priority) {\n                break;\n            }\n        }\n        this.postProcessors.splice(indexToInsertAt, 0, { postProcessor: postProcessor, priority: priority });\n    };\n    /**\n     *\n     * @param manager\n     */\n    PluginManager.prototype.addFileManager = function (manager) {\n        this.fileManagers.push(manager);\n    };\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    PluginManager.prototype.getPreProcessors = function () {\n        var preProcessors = [];\n        for (var i = 0; i < this.preProcessors.length; i++) {\n            preProcessors.push(this.preProcessors[i].preProcessor);\n        }\n        return preProcessors;\n    };\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    PluginManager.prototype.getPostProcessors = function () {\n        var postProcessors = [];\n        for (var i = 0; i < this.postProcessors.length; i++) {\n            postProcessors.push(this.postProcessors[i].postProcessor);\n        }\n        return postProcessors;\n    };\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    PluginManager.prototype.getVisitors = function () {\n        return this.visitors;\n    };\n    PluginManager.prototype.visitor = function () {\n        var self = this;\n        return {\n            first: function () {\n                self.iterator = -1;\n                return self.visitors[self.iterator];\n            },\n            get: function () {\n                self.iterator += 1;\n                return self.visitors[self.iterator];\n            }\n        };\n    };\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    PluginManager.prototype.getFileManagers = function () {\n        return this.fileManagers;\n    };\n    return PluginManager;\n}());\nvar pm;\nvar PluginManagerFactory = function (less, newFactory) {\n    if (newFactory || !pm) {\n        pm = new PluginManager(less);\n    }\n    return pm;\n};\n//\nexports.default = PluginManagerFactory;\n//# sourceMappingURL=plugin-manager.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction default_1(environment) {\n    var SourceMapOutput = /** @class */ (function () {\n        function SourceMapOutput(options) {\n            this._css = [];\n            this._rootNode = options.rootNode;\n            this._contentsMap = options.contentsMap;\n            this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap;\n            if (options.sourceMapFilename) {\n                this._sourceMapFilename = options.sourceMapFilename.replace(/\\\\/g, '/');\n            }\n            this._outputFilename = options.outputFilename;\n            this.sourceMapURL = options.sourceMapURL;\n            if (options.sourceMapBasepath) {\n                this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\\\/g, '/');\n            }\n            if (options.sourceMapRootpath) {\n                this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\\\/g, '/');\n                if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== '/') {\n                    this._sourceMapRootpath += '/';\n                }\n            }\n            else {\n                this._sourceMapRootpath = '';\n            }\n            this._outputSourceFiles = options.outputSourceFiles;\n            this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();\n            this._lineNumber = 0;\n            this._column = 0;\n        }\n        SourceMapOutput.prototype.removeBasepath = function (path) {\n            if (this._sourceMapBasepath && path.indexOf(this._sourceMapBasepath) === 0) {\n                path = path.substring(this._sourceMapBasepath.length);\n                if (path.charAt(0) === '\\\\' || path.charAt(0) === '/') {\n                    path = path.substring(1);\n                }\n            }\n            return path;\n        };\n        SourceMapOutput.prototype.normalizeFilename = function (filename) {\n            filename = filename.replace(/\\\\/g, '/');\n            filename = this.removeBasepath(filename);\n            return (this._sourceMapRootpath || '') + filename;\n        };\n        SourceMapOutput.prototype.add = function (chunk, fileInfo, index, mapLines) {\n            // ignore adding empty strings\n            if (!chunk) {\n                return;\n            }\n            var lines, sourceLines, columns, sourceColumns, i;\n            if (fileInfo && fileInfo.filename) {\n                var inputSource = this._contentsMap[fileInfo.filename];\n                // remove vars/banner added to the top of the file\n                if (this._contentsIgnoredCharsMap[fileInfo.filename]) {\n                    // adjust the index\n                    index -= this._contentsIgnoredCharsMap[fileInfo.filename];\n                    if (index < 0) {\n                        index = 0;\n                    }\n                    // adjust the source\n                    inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);\n                }\n                /**\n                 * ignore empty content, or failsafe\n                 * if contents map is incorrect\n                 */\n                if (inputSource === undefined) {\n                    this._css.push(chunk);\n                    return;\n                }\n                inputSource = inputSource.substring(0, index);\n                sourceLines = inputSource.split('\\n');\n                sourceColumns = sourceLines[sourceLines.length - 1];\n            }\n            lines = chunk.split('\\n');\n            columns = lines[lines.length - 1];\n            if (fileInfo && fileInfo.filename) {\n                if (!mapLines) {\n                    this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + 1, column: this._column },\n                        original: { line: sourceLines.length, column: sourceColumns.length },\n                        source: this.normalizeFilename(fileInfo.filename) });\n                }\n                else {\n                    for (i = 0; i < lines.length; i++) {\n                        this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + i + 1, column: i === 0 ? this._column : 0 },\n                            original: { line: sourceLines.length + i, column: i === 0 ? sourceColumns.length : 0 },\n                            source: this.normalizeFilename(fileInfo.filename) });\n                    }\n                }\n            }\n            if (lines.length === 1) {\n                this._column += columns.length;\n            }\n            else {\n                this._lineNumber += lines.length - 1;\n                this._column = columns.length;\n            }\n            this._css.push(chunk);\n        };\n        SourceMapOutput.prototype.isEmpty = function () {\n            return this._css.length === 0;\n        };\n        SourceMapOutput.prototype.toCSS = function (context) {\n            this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });\n            if (this._outputSourceFiles) {\n                for (var filename in this._contentsMap) {\n                    // eslint-disable-next-line no-prototype-builtins\n                    if (this._contentsMap.hasOwnProperty(filename)) {\n                        var source = this._contentsMap[filename];\n                        if (this._contentsIgnoredCharsMap[filename]) {\n                            source = source.slice(this._contentsIgnoredCharsMap[filename]);\n                        }\n                        this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);\n                    }\n                }\n            }\n            this._rootNode.genCSS(context, this);\n            if (this._css.length > 0) {\n                var sourceMapURL = void 0;\n                var sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());\n                if (this.sourceMapURL) {\n                    sourceMapURL = this.sourceMapURL;\n                }\n                else if (this._sourceMapFilename) {\n                    sourceMapURL = this._sourceMapFilename;\n                }\n                this.sourceMapURL = sourceMapURL;\n                this.sourceMap = sourceMapContent;\n            }\n            return this._css.join('');\n        };\n        return SourceMapOutput;\n    }());\n    return SourceMapOutput;\n}\nexports.default = default_1;\n//# sourceMappingURL=source-map-output.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction default_1(SourceMapOutput, environment) {\n    var SourceMapBuilder = /** @class */ (function () {\n        function SourceMapBuilder(options) {\n            this.options = options;\n        }\n        SourceMapBuilder.prototype.toCSS = function (rootNode, options, imports) {\n            var sourceMapOutput = new SourceMapOutput({\n                contentsIgnoredCharsMap: imports.contentsIgnoredChars,\n                rootNode: rootNode,\n                contentsMap: imports.contents,\n                sourceMapFilename: this.options.sourceMapFilename,\n                sourceMapURL: this.options.sourceMapURL,\n                outputFilename: this.options.sourceMapOutputFilename,\n                sourceMapBasepath: this.options.sourceMapBasepath,\n                sourceMapRootpath: this.options.sourceMapRootpath,\n                outputSourceFiles: this.options.outputSourceFiles,\n                sourceMapGenerator: this.options.sourceMapGenerator,\n                sourceMapFileInline: this.options.sourceMapFileInline,\n                disableSourcemapAnnotation: this.options.disableSourcemapAnnotation\n            });\n            var css = sourceMapOutput.toCSS(options);\n            this.sourceMap = sourceMapOutput.sourceMap;\n            this.sourceMapURL = sourceMapOutput.sourceMapURL;\n            if (this.options.sourceMapInputFilename) {\n                this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);\n            }\n            if (this.options.sourceMapBasepath !== undefined && this.sourceMapURL !== undefined) {\n                this.sourceMapURL = sourceMapOutput.removeBasepath(this.sourceMapURL);\n            }\n            return css + this.getCSSAppendage();\n        };\n        SourceMapBuilder.prototype.getCSSAppendage = function () {\n            var sourceMapURL = this.sourceMapURL;\n            if (this.options.sourceMapFileInline) {\n                if (this.sourceMap === undefined) {\n                    return '';\n                }\n                sourceMapURL = \"data:application/json;base64,\" + environment.encodeBase64(this.sourceMap);\n            }\n            if (this.options.disableSourcemapAnnotation) {\n                return '';\n            }\n            if (sourceMapURL) {\n                return \"/*# sourceMappingURL=\" + sourceMapURL + \" */\";\n            }\n            return '';\n        };\n        SourceMapBuilder.prototype.getExternalSourceMap = function () {\n            return this.sourceMap;\n        };\n        SourceMapBuilder.prototype.setExternalSourceMap = function (sourceMap) {\n            this.sourceMap = sourceMap;\n        };\n        SourceMapBuilder.prototype.isInline = function () {\n            return this.options.sourceMapFileInline;\n        };\n        SourceMapBuilder.prototype.getSourceMapURL = function () {\n            return this.sourceMapURL;\n        };\n        SourceMapBuilder.prototype.getOutputFilename = function () {\n            return this.options.sourceMapOutputFilename;\n        };\n        SourceMapBuilder.prototype.getInputFilename = function () {\n            return this.sourceMapInputFilename;\n        };\n        return SourceMapBuilder;\n    }());\n    return SourceMapBuilder;\n}\nexports.default = default_1;\n//# sourceMappingURL=source-map-builder.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar less_error_1 = tslib_1.__importDefault(require(\"./less-error\"));\nvar transform_tree_1 = tslib_1.__importDefault(require(\"./transform-tree\"));\nvar logger_1 = tslib_1.__importDefault(require(\"./logger\"));\nfunction default_1(SourceMapBuilder) {\n    var ParseTree = /** @class */ (function () {\n        function ParseTree(root, imports) {\n            this.root = root;\n            this.imports = imports;\n        }\n        ParseTree.prototype.toCSS = function (options) {\n            var evaldRoot;\n            var result = {};\n            var sourceMapBuilder;\n            try {\n                evaldRoot = transform_tree_1.default(this.root, options);\n            }\n            catch (e) {\n                throw new less_error_1.default(e, this.imports);\n            }\n            try {\n                var compress = Boolean(options.compress);\n                if (compress) {\n                    logger_1.default.warn('The compress option has been deprecated. ' +\n                        'We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.');\n                }\n                var toCSSOptions = {\n                    compress: compress,\n                    dumpLineNumbers: options.dumpLineNumbers,\n                    strictUnits: Boolean(options.strictUnits),\n                    numPrecision: 8\n                };\n                if (options.sourceMap) {\n                    sourceMapBuilder = new SourceMapBuilder(options.sourceMap);\n                    result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);\n                }\n                else {\n                    result.css = evaldRoot.toCSS(toCSSOptions);\n                }\n            }\n            catch (e) {\n                throw new less_error_1.default(e, this.imports);\n            }\n            if (options.pluginManager) {\n                var postProcessors = options.pluginManager.getPostProcessors();\n                for (var i = 0; i < postProcessors.length; i++) {\n                    result.css = postProcessors[i].process(result.css, { sourceMap: sourceMapBuilder, options: options, imports: this.imports });\n                }\n            }\n            if (options.sourceMap) {\n                result.map = sourceMapBuilder.getExternalSourceMap();\n            }\n            result.imports = [];\n            for (var file in this.imports.files) {\n                if (Object.prototype.hasOwnProperty.call(this.imports.files, file) && file !== this.imports.rootFilename) {\n                    result.imports.push(file);\n                }\n            }\n            return result;\n        };\n        return ParseTree;\n    }());\n    return ParseTree;\n}\nexports.default = default_1;\n//# sourceMappingURL=parse-tree.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar contexts_1 = tslib_1.__importDefault(require(\"./contexts\"));\nvar parser_1 = tslib_1.__importDefault(require(\"./parser/parser\"));\nvar less_error_1 = tslib_1.__importDefault(require(\"./less-error\"));\nvar utils = tslib_1.__importStar(require(\"./utils\"));\nvar logger_1 = tslib_1.__importDefault(require(\"./logger\"));\nfunction default_1(environment) {\n    // FileInfo = {\n    //  'rewriteUrls' - option - whether to adjust URL's to be relative\n    //  'filename' - full resolved filename of current file\n    //  'rootpath' - path to append to normal URLs for this node\n    //  'currentDirectory' - path to the current file, absolute\n    //  'rootFilename' - filename of the base file\n    //  'entryPath' - absolute path to the entry file\n    //  'reference' - whether the file should not be output and only output parts that are referenced\n    var ImportManager = /** @class */ (function () {\n        function ImportManager(less, context, rootFileInfo) {\n            this.less = less;\n            this.rootFilename = rootFileInfo.filename;\n            this.paths = context.paths || []; // Search paths, when importing\n            this.contents = {}; // map - filename to contents of all the files\n            this.contentsIgnoredChars = {}; // map - filename to lines at the beginning of each file to ignore\n            this.mime = context.mime;\n            this.error = null;\n            this.context = context;\n            // Deprecated? Unused outside of here, could be useful.\n            this.queue = []; // Files which haven't been imported yet\n            this.files = {}; // Holds the imported parse trees.\n        }\n        /**\n         * Add an import to be imported\n         * @param path - the raw path\n         * @param tryAppendExtension - whether to try appending a file extension (.less or .js if the path has no extension)\n         * @param currentFileInfo - the current file info (used for instance to work out relative paths)\n         * @param importOptions - import options\n         * @param callback - callback for when it is imported\n         */\n        ImportManager.prototype.push = function (path, tryAppendExtension, currentFileInfo, importOptions, callback) {\n            var importManager = this, pluginLoader = this.context.pluginManager.Loader;\n            this.queue.push(path);\n            var fileParsedFunc = function (e, root, fullPath) {\n                importManager.queue.splice(importManager.queue.indexOf(path), 1); // Remove the path from the queue\n                var importedEqualsRoot = fullPath === importManager.rootFilename;\n                if (importOptions.optional && e) {\n                    callback(null, { rules: [] }, false, null);\n                    logger_1.default.info(\"The file \" + fullPath + \" was skipped because it was not found and the import was marked optional.\");\n                }\n                else {\n                    // Inline imports aren't cached here.\n                    // If we start to cache them, please make sure they won't conflict with non-inline imports of the\n                    // same name as they used to do before this comment and the condition below have been added.\n                    if (!importManager.files[fullPath] && !importOptions.inline) {\n                        importManager.files[fullPath] = { root: root, options: importOptions };\n                    }\n                    if (e && !importManager.error) {\n                        importManager.error = e;\n                    }\n                    callback(e, root, importedEqualsRoot, fullPath);\n                }\n            };\n            var newFileInfo = {\n                rewriteUrls: this.context.rewriteUrls,\n                entryPath: currentFileInfo.entryPath,\n                rootpath: currentFileInfo.rootpath,\n                rootFilename: currentFileInfo.rootFilename\n            };\n            var fileManager = environment.getFileManager(path, currentFileInfo.currentDirectory, this.context, environment);\n            if (!fileManager) {\n                fileParsedFunc({ message: \"Could not find a file-manager for \" + path });\n                return;\n            }\n            var loadFileCallback = function (loadedFile) {\n                var plugin;\n                var resolvedFilename = loadedFile.filename;\n                var contents = loadedFile.contents.replace(/^\\uFEFF/, '');\n                // Pass on an updated rootpath if path of imported file is relative and file\n                // is in a (sub|sup) directory\n                //\n                // Examples:\n                // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',\n                //   then rootpath should become 'less/module/nav/'\n                // - If path of imported file is '../mixins.less' and rootpath is 'less/',\n                //   then rootpath should become 'less/../'\n                newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);\n                if (newFileInfo.rewriteUrls) {\n                    newFileInfo.rootpath = fileManager.join((importManager.context.rootpath || ''), fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));\n                    if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {\n                        newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);\n                    }\n                }\n                newFileInfo.filename = resolvedFilename;\n                var newEnv = new contexts_1.default.Parse(importManager.context);\n                newEnv.processImports = false;\n                importManager.contents[resolvedFilename] = contents;\n                if (currentFileInfo.reference || importOptions.reference) {\n                    newFileInfo.reference = true;\n                }\n                if (importOptions.isPlugin) {\n                    plugin = pluginLoader.evalPlugin(contents, newEnv, importManager, importOptions.pluginArgs, newFileInfo);\n                    if (plugin instanceof less_error_1.default) {\n                        fileParsedFunc(plugin, null, resolvedFilename);\n                    }\n                    else {\n                        fileParsedFunc(null, plugin, resolvedFilename);\n                    }\n                }\n                else if (importOptions.inline) {\n                    fileParsedFunc(null, contents, resolvedFilename);\n                }\n                else {\n                    // import (multiple) parse trees apparently get altered and can't be cached.\n                    // TODO: investigate why this is\n                    if (importManager.files[resolvedFilename]\n                        && !importManager.files[resolvedFilename].options.multiple\n                        && !importOptions.multiple) {\n                        fileParsedFunc(null, importManager.files[resolvedFilename].root, resolvedFilename);\n                    }\n                    else {\n                        new parser_1.default(newEnv, importManager, newFileInfo).parse(contents, function (e, root) {\n                            fileParsedFunc(e, root, resolvedFilename);\n                        });\n                    }\n                }\n            };\n            var loadedFile;\n            var promise;\n            var context = utils.clone(this.context);\n            if (tryAppendExtension) {\n                context.ext = importOptions.isPlugin ? '.js' : '.less';\n            }\n            if (importOptions.isPlugin) {\n                context.mime = 'application/javascript';\n                if (context.syncImport) {\n                    loadedFile = pluginLoader.loadPluginSync(path, currentFileInfo.currentDirectory, context, environment, fileManager);\n                }\n                else {\n                    promise = pluginLoader.loadPlugin(path, currentFileInfo.currentDirectory, context, environment, fileManager);\n                }\n            }\n            else {\n                if (context.syncImport) {\n                    loadedFile = fileManager.loadFileSync(path, currentFileInfo.currentDirectory, context, environment);\n                }\n                else {\n                    promise = fileManager.loadFile(path, currentFileInfo.currentDirectory, context, environment, function (err, loadedFile) {\n                        if (err) {\n                            fileParsedFunc(err);\n                        }\n                        else {\n                            loadFileCallback(loadedFile);\n                        }\n                    });\n                }\n            }\n            if (loadedFile) {\n                if (!loadedFile.filename) {\n                    fileParsedFunc(loadedFile);\n                }\n                else {\n                    loadFileCallback(loadedFile);\n                }\n            }\n            else if (promise) {\n                promise.then(loadFileCallback, fileParsedFunc);\n            }\n        };\n        return ImportManager;\n    }());\n    return ImportManager;\n}\nexports.default = default_1;\n//# sourceMappingURL=import-manager.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar contexts_1 = tslib_1.__importDefault(require(\"./contexts\"));\nvar parser_1 = tslib_1.__importDefault(require(\"./parser/parser\"));\nvar plugin_manager_1 = tslib_1.__importDefault(require(\"./plugin-manager\"));\nvar less_error_1 = tslib_1.__importDefault(require(\"./less-error\"));\nvar utils = tslib_1.__importStar(require(\"./utils\"));\nfunction default_1(environment, ParseTree, ImportManager) {\n    var parse = function (input, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = utils.copyOptions(this.options, {});\n        }\n        else {\n            options = utils.copyOptions(this.options, options || {});\n        }\n        if (!callback) {\n            var self_1 = this;\n            return new Promise(function (resolve, reject) {\n                parse.call(self_1, input, options, function (err, output) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(output);\n                    }\n                });\n            });\n        }\n        else {\n            var context_1;\n            var rootFileInfo = void 0;\n            var pluginManager_1 = new plugin_manager_1.default(this, !options.reUsePluginManager);\n            options.pluginManager = pluginManager_1;\n            context_1 = new contexts_1.default.Parse(options);\n            if (options.rootFileInfo) {\n                rootFileInfo = options.rootFileInfo;\n            }\n            else {\n                var filename = options.filename || 'input';\n                var entryPath = filename.replace(/[^/\\\\]*$/, '');\n                rootFileInfo = {\n                    filename: filename,\n                    rewriteUrls: context_1.rewriteUrls,\n                    rootpath: context_1.rootpath || '',\n                    currentDirectory: entryPath,\n                    entryPath: entryPath,\n                    rootFilename: filename\n                };\n                // add in a missing trailing slash\n                if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== '/') {\n                    rootFileInfo.rootpath += '/';\n                }\n            }\n            var imports_1 = new ImportManager(this, context_1, rootFileInfo);\n            this.importManager = imports_1;\n            // TODO: allow the plugins to be just a list of paths or names\n            // Do an async plugin queue like lessc\n            if (options.plugins) {\n                options.plugins.forEach(function (plugin) {\n                    var evalResult, contents;\n                    if (plugin.fileContent) {\n                        contents = plugin.fileContent.replace(/^\\uFEFF/, '');\n                        evalResult = pluginManager_1.Loader.evalPlugin(contents, context_1, imports_1, plugin.options, plugin.filename);\n                        if (evalResult instanceof less_error_1.default) {\n                            return callback(evalResult);\n                        }\n                    }\n                    else {\n                        pluginManager_1.addPlugin(plugin);\n                    }\n                });\n            }\n            new parser_1.default(context_1, imports_1, rootFileInfo)\n                .parse(input, function (e, root) {\n                if (e) {\n                    return callback(e);\n                }\n                callback(null, root, imports_1, options);\n            }, options);\n        }\n    };\n    return parse;\n}\nexports.default = default_1;\n//# sourceMappingURL=parse.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils = tslib_1.__importStar(require(\"./utils\"));\nfunction default_1(environment, ParseTree) {\n    var render = function (input, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = utils.copyOptions(this.options, {});\n        }\n        else {\n            options = utils.copyOptions(this.options, options || {});\n        }\n        if (!callback) {\n            var self_1 = this;\n            return new Promise(function (resolve, reject) {\n                render.call(self_1, input, options, function (err, output) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(output);\n                    }\n                });\n            });\n        }\n        else {\n            this.parse(input, options, function (err, root, imports, options) {\n                if (err) {\n                    return callback(err);\n                }\n                var result;\n                try {\n                    var parseTree = new ParseTree(root, imports);\n                    result = parseTree.toCSS(options);\n                }\n                catch (err) {\n                    return callback(err);\n                }\n                callback(null, result);\n            });\n        }\n    };\n    return render;\n}\nexports.default = default_1;\n//# sourceMappingURL=render.js.map","module.exports = {\n\t\"name\": \"less\",\n\t\"version\": \"4.2.0\",\n\t\"description\": \"Leaner CSS\",\n\t\"homepage\": \"http://lesscss.org\",\n\t\"author\": {\n\t\t\"name\": \"Alexis Sellier\",\n\t\t\"email\": \"self@cloudhead.net\"\n\t},\n\t\"contributors\": [\n\t\t\"The Core Less Team\"\n\t],\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/less/less.js/issues\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"https://github.com/less/less.js.git\"\n\t},\n\t\"master\": {\n\t\t\"url\": \"https://github.com/less/less.js/blob/master/\",\n\t\t\"raw\": \"https://raw.githubusercontent.com/less/less.js/master/\"\n\t},\n\t\"license\": \"Apache-2.0\",\n\t\"bin\": {\n\t\t\"lessc\": \"./bin/lessc\"\n\t},\n\t\"main\": \"index\",\n\t\"module\": \"./lib/less-node/index\",\n\t\"directories\": {\n\t\t\"test\": \"./test\"\n\t},\n\t\"browser\": \"./dist/less.js\",\n\t\"engines\": {\n\t\t\"node\": \">=6\"\n\t},\n\t\"scripts\": {\n\t\t\"test\": \"grunt test\",\n\t\t\"grunt\": \"grunt\",\n\t\t\"lint\": \"eslint '**/*.{ts,js}'\",\n\t\t\"lint:fix\": \"eslint '**/*.{ts,js}' --fix\",\n\t\t\"build\": \"npm-run-all clean compile\",\n\t\t\"clean\": \"shx rm -rf ./lib tsconfig.tsbuildinfo\",\n\t\t\"compile\": \"tsc -p tsconfig.build.json\",\n\t\t\"copy:root\": \"shx cp -rf ./dist ../../\",\n\t\t\"dev\": \"tsc -p tsconfig.build.json -w\",\n\t\t\"prepublishOnly\": \"grunt dist\"\n\t},\n\t\"optionalDependencies\": {\n\t\t\"errno\": \"^0.1.1\",\n\t\t\"graceful-fs\": \"^4.1.2\",\n\t\t\"image-size\": \"~0.5.0\",\n\t\t\"make-dir\": \"^2.1.0\",\n\t\t\"mime\": \"^1.4.1\",\n\t\t\"needle\": \"^3.1.0\",\n\t\t\"source-map\": \"~0.6.0\"\n\t},\n\t\"devDependencies\": {\n\t\t\"@less/test-data\": \"^4.2.0\",\n\t\t\"@less/test-import-module\": \"^4.0.0\",\n\t\t\"@rollup/plugin-commonjs\": \"^17.0.0\",\n\t\t\"@rollup/plugin-json\": \"^4.1.0\",\n\t\t\"@rollup/plugin-node-resolve\": \"^11.0.0\",\n\t\t\"@typescript-eslint/eslint-plugin\": \"^4.28.0\",\n\t\t\"@typescript-eslint/parser\": \"^4.28.0\",\n\t\t\"benny\": \"^3.6.12\",\n\t\t\"bootstrap-less-port\": \"0.3.0\",\n\t\t\"chai\": \"^4.2.0\",\n\t\t\"cross-env\": \"^7.0.3\",\n\t\t\"diff\": \"^3.2.0\",\n\t\t\"eslint\": \"^7.29.0\",\n\t\t\"fs-extra\": \"^8.1.0\",\n\t\t\"git-rev\": \"^0.2.1\",\n\t\t\"globby\": \"^10.0.1\",\n\t\t\"grunt\": \"^1.0.4\",\n\t\t\"grunt-cli\": \"^1.3.2\",\n\t\t\"grunt-contrib-clean\": \"^1.0.0\",\n\t\t\"grunt-contrib-connect\": \"^1.0.2\",\n\t\t\"grunt-eslint\": \"^23.0.0\",\n\t\t\"grunt-saucelabs\": \"^9.0.1\",\n\t\t\"grunt-shell\": \"^1.3.0\",\n\t\t\"html-template-tag\": \"^3.2.0\",\n\t\t\"jit-grunt\": \"^0.10.0\",\n\t\t\"less-plugin-autoprefix\": \"^1.5.1\",\n\t\t\"less-plugin-clean-css\": \"^1.5.1\",\n\t\t\"minimist\": \"^1.2.0\",\n\t\t\"mocha\": \"^6.2.1\",\n\t\t\"mocha-headless-chrome\": \"^4.0.0\",\n\t\t\"mocha-teamcity-reporter\": \"^3.0.0\",\n\t\t\"nock\": \"^11.8.2\",\n\t\t\"npm-run-all\": \"^4.1.5\",\n\t\t\"performance-now\": \"^0.2.0\",\n\t\t\"phin\": \"^2.2.3\",\n\t\t\"promise\": \"^7.1.1\",\n\t\t\"read-glob\": \"^3.0.0\",\n\t\t\"resolve\": \"^1.17.0\",\n\t\t\"rollup\": \"^2.52.2\",\n\t\t\"rollup-plugin-terser\": \"^5.1.1\",\n\t\t\"rollup-plugin-typescript2\": \"^0.29.0\",\n\t\t\"semver\": \"^6.3.0\",\n\t\t\"shx\": \"^0.3.2\",\n\t\t\"time-grunt\": \"^1.3.0\",\n\t\t\"ts-node\": \"^9.1.1\",\n\t\t\"typescript\": \"^4.3.4\",\n\t\t\"uikit\": \"2.27.4\"\n\t},\n\t\"keywords\": [\n\t\t\"compile less\",\n\t\t\"css nesting\",\n\t\t\"css variable\",\n\t\t\"css\",\n\t\t\"gradients css\",\n\t\t\"gradients css3\",\n\t\t\"less compiler\",\n\t\t\"less css\",\n\t\t\"less mixins\",\n\t\t\"less\",\n\t\t\"less.js\",\n\t\t\"lesscss\",\n\t\t\"mixins\",\n\t\t\"nested css\",\n\t\t\"parser\",\n\t\t\"preprocessor\",\n\t\t\"bootstrap css\",\n\t\t\"bootstrap less\",\n\t\t\"style\",\n\t\t\"styles\",\n\t\t\"stylesheet\",\n\t\t\"variables in css\",\n\t\t\"css less\"\n\t],\n\t\"rawcurrent\": \"https://raw.github.com/less/less.js/v\",\n\t\"sourcearchive\": \"https://github.com/less/less.js/archive/v\",\n\t\"dependencies\": {\n\t\t\"copy-anything\": \"^2.0.1\",\n\t\t\"parse-node-version\": \"^1.0.1\",\n\t\t\"tslib\": \"^2.3.0\"\n\t},\n\t\"gitHead\": \"1df9072ee9ebdadc791bf35dfb1dbc3ef9f1948f\"\n}\n","// lessc_helper.js\n//\n//      helper functions for lessc\nvar lessc_helper = {\n    // Stylize a string\n    stylize: function (str, style) {\n        var styles = {\n            'reset': [0, 0],\n            'bold': [1, 22],\n            'inverse': [7, 27],\n            'underline': [4, 24],\n            'yellow': [33, 39],\n            'green': [32, 39],\n            'red': [31, 39],\n            'grey': [90, 39]\n        };\n        return \"\\u001B[\" + styles[style][0] + \"m\" + str + \"\\u001B[\" + styles[style][1] + \"m\";\n    },\n    // Print command line options\n    printUsage: function () {\n        console.log('usage: lessc [option option=parameter ...] <source> [destination]');\n        console.log('');\n        console.log('If source is set to `-\\' (dash or hyphen-minus), input is read from stdin.');\n        console.log('');\n        console.log('options:');\n        console.log('  -h, --help                   Prints help (this message) and exit.');\n        console.log('  --include-path=PATHS         Sets include paths. Separated by `:\\'. `;\\' also supported on windows.');\n        console.log('  -M, --depends                Outputs a makefile import dependency list to stdout.');\n        console.log('  --no-color                   Disables colorized output.');\n        console.log('  --ie-compat                  Enables IE8 compatibility checks.');\n        console.log('  --js                         Enables inline JavaScript in less files');\n        console.log('  -l, --lint                   Syntax check only (lint).');\n        console.log('  -s, --silent                 Suppresses output of error messages.');\n        console.log('  --strict-imports             Forces evaluation of imports.');\n        console.log('  --insecure                   Allows imports from insecure https hosts.');\n        console.log('  -v, --version                Prints version number and exit.');\n        console.log('  --verbose                    Be verbose.');\n        console.log('  --source-map[=FILENAME]      Outputs a v3 sourcemap to the filename (or output filename.map).');\n        console.log('  --source-map-rootpath=X      Adds this path onto the sourcemap filename and less file paths.');\n        console.log('  --source-map-basepath=X      Sets sourcemap base path, defaults to current working directory.');\n        console.log('  --source-map-include-source  Puts the less files into the map instead of referencing them.');\n        console.log('  --source-map-inline          Puts the map (and any less files) as a base64 data uri into the output css file.');\n        console.log('  --source-map-url=URL         Sets a custom URL to map file, for sourceMappingURL comment');\n        console.log('                               in generated CSS file.');\n        console.log('  --source-map-no-annotation   Excludes the sourceMappingURL comment from the output css file.');\n        console.log('  -rp, --rootpath=URL          Sets rootpath for url rewriting in relative imports and urls');\n        console.log('                               Works with or without the relative-urls option.');\n        console.log('  -ru=, --rewrite-urls=        Rewrites URLs to make them relative to the base less file.');\n        console.log('    all|local|off              \\'all\\' rewrites all URLs, \\'local\\' just those starting with a \\'.\\'');\n        console.log('');\n        console.log('  -m=, --math=');\n        console.log('     always                    Less will eagerly perform math operations always.');\n        console.log('     parens-division           Math performed except for division (/) operator');\n        console.log('     parens | strict           Math only performed inside parentheses');\n        console.log('     strict-legacy             Parens required in very strict terms (legacy --strict-math)');\n        console.log('');\n        console.log('  -su=on|off                   Allows mixed units, e.g. 1px+1em or 1px*1px which have units');\n        console.log('  --strict-units=on|off        that cannot be represented.');\n        console.log('  --global-var=\\'VAR=VALUE\\'     Defines a variable that can be referenced by the file.');\n        console.log('  --modify-var=\\'VAR=VALUE\\'     Modifies a variable already declared in the file.');\n        console.log('  --url-args=\\'QUERYSTRING\\'     Adds params into url tokens (e.g. 42, cb=42 or \\'a=1&b=2\\')');\n        console.log('  --plugin=PLUGIN=OPTIONS      Loads a plugin. You can also omit the --plugin= if the plugin begins');\n        console.log('                               less-plugin. E.g. the clean css plugin is called less-plugin-clean-css');\n        console.log('                               once installed (npm install less-plugin-clean-css), use either with');\n        console.log('                               --plugin=less-plugin-clean-css or just --clean-css');\n        console.log('                               specify options afterwards e.g. --plugin=less-plugin-clean-css=\"advanced\"');\n        console.log('                               or --clean-css=\"advanced\"');\n        console.log('  --disable-plugin-rule        Disallow @plugin statements');\n        console.log('');\n        console.log('-------------------------- Deprecated ----------------');\n        console.log('  -sm=on|off               Legacy parens-only math. Use --math');\n        console.log('  --strict-math=on|off     ');\n        console.log('');\n        console.log('  --line-numbers=TYPE      Outputs filename and line numbers.');\n        console.log('                           TYPE can be either \\'comments\\', which will output');\n        console.log('                           the debug info within comments, \\'mediaquery\\'');\n        console.log('                           that will output the information within a fake');\n        console.log('                           media query which is compatible with the SASS');\n        console.log('                           format, and \\'all\\' which will do both.');\n        console.log('  -x, --compress           Compresses output by removing some whitespaces.');\n        console.log('                           We recommend you use a dedicated minifer like less-plugin-clean-css');\n        console.log('');\n        console.log('Report bugs to: http://github.com/less/less.js/issues');\n        console.log('Home page: <http://lesscss.org/>');\n    }\n};\n// Exports helper functions\n// eslint-disable-next-line no-prototype-builtins\nfor (var h in lessc_helper) {\n    if (lessc_helper.hasOwnProperty(h)) {\n        exports[h] = lessc_helper[h];\n    }\n}\n//# sourceMappingURL=lessc-helper.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar path_1 = tslib_1.__importDefault(require(\"path\"));\nvar abstract_plugin_loader_js_1 = tslib_1.__importDefault(require(\"../less/environment/abstract-plugin-loader.js\"));\n/**\n * Node Plugin Loader\n */\nvar PluginLoader = function (less) {\n    this.less = less;\n    this.require = function (prefix) {\n        prefix = path_1.default.dirname(prefix);\n        return function (id) {\n            var str = id.substr(0, 2);\n            if (str === '..' || str === './') {\n                return require(path_1.default.join(prefix, id));\n            }\n            else {\n                return require(id);\n            }\n        };\n    };\n};\nPluginLoader.prototype = Object.assign(new abstract_plugin_loader_js_1.default(), {\n    loadPlugin: function (filename, basePath, context, environment, fileManager) {\n        var prefix = filename.slice(0, 1);\n        var explicit = prefix === '.' || prefix === '/' || filename.slice(-3).toLowerCase() === '.js';\n        if (!explicit) {\n            context.prefixes = ['less-plugin-', ''];\n        }\n        if (context.syncImport) {\n            return fileManager.loadFileSync(filename, basePath, context, environment);\n        }\n        return new Promise(function (fulfill, reject) {\n            fileManager.loadFile(filename, basePath, context, environment).then(function (data) {\n                try {\n                    fulfill(data);\n                }\n                catch (e) {\n                    console.log(e);\n                    reject(e);\n                }\n            }).catch(function (err) {\n                reject(err);\n            });\n        });\n    },\n    loadPluginSync: function (filename, basePath, context, environment, fileManager) {\n        context.syncImport = true;\n        return this.loadPlugin(filename, basePath, context, environment, fileManager);\n    }\n});\nexports.default = PluginLoader;\n//# sourceMappingURL=plugin-loader.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Export a new default each time\nfunction default_1() {\n    return {\n        /* Inline Javascript - @plugin still allowed */\n        javascriptEnabled: false,\n        /* Outputs a makefile import dependency list to stdout. */\n        depends: false,\n        /* (DEPRECATED) Compress using less built-in compression.\n         * This does an okay job but does not utilise all the tricks of\n         * dedicated css compression. */\n        compress: false,\n        /* Runs the less parser and just reports errors without any output. */\n        lint: false,\n        /* Sets available include paths.\n         * If the file in an @import rule does not exist at that exact location,\n         * less will look for it at the location(s) passed to this option.\n         * You might use this for instance to specify a path to a library which\n         * you want to be referenced simply and relatively in the less files. */\n        paths: [],\n        /* color output in the terminal */\n        color: true,\n        /* The strictImports controls whether the compiler will allow an @import inside of either\n         * @media blocks or (a later addition) other selector blocks.\n         * See: https://github.com/less/less.js/issues/656 */\n        strictImports: false,\n        /* Allow Imports from Insecure HTTPS Hosts */\n        insecure: false,\n        /* Allows you to add a path to every generated import and url in your css.\n         * This does not affect less import statements that are processed, just ones\n         * that are left in the output css. */\n        rootpath: '',\n        /* By default URLs are kept as-is, so if you import a file in a sub-directory\n         * that references an image, exactly the same URL will be output in the css.\n         * This option allows you to re-write URL's in imported files so that the\n         * URL is always relative to the base imported file */\n        rewriteUrls: false,\n        /* How to process math\n         *   0 always           - eagerly try to solve all operations\n         *   1 parens-division  - require parens for division \"/\"\n         *   2 parens | strict  - require parens for all operations\n         *   3 strict-legacy    - legacy strict behavior (super-strict)\n         */\n        math: 1,\n        /* Without this option, less attempts to guess at the output unit when it does maths. */\n        strictUnits: false,\n        /* Effectively the declaration is put at the top of your base Less file,\n         * meaning it can be used but it also can be overridden if this variable\n         * is defined in the file. */\n        globalVars: null,\n        /* As opposed to the global variable option, this puts the declaration at the\n         * end of your base file, meaning it will override anything defined in your Less file. */\n        modifyVars: null,\n        /* This option allows you to specify a argument to go on to every URL.  */\n        urlArgs: ''\n    };\n}\nexports.default = default_1;\n//# sourceMappingURL=default-options.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar dimension_1 = tslib_1.__importDefault(require(\"../less/tree/dimension\"));\nvar expression_1 = tslib_1.__importDefault(require(\"../less/tree/expression\"));\nvar function_registry_1 = tslib_1.__importDefault(require(\"./../less/functions/function-registry\"));\nexports.default = (function (environment) {\n    function imageSize(functionContext, filePathNode) {\n        var filePath = filePathNode.value;\n        var currentFileInfo = functionContext.currentFileInfo;\n        var currentDirectory = currentFileInfo.rewriteUrls ?\n            currentFileInfo.currentDirectory : currentFileInfo.entryPath;\n        var fragmentStart = filePath.indexOf('#');\n        if (fragmentStart !== -1) {\n            filePath = filePath.slice(0, fragmentStart);\n        }\n        var fileManager = environment.getFileManager(filePath, currentDirectory, functionContext.context, environment, true);\n        if (!fileManager) {\n            throw {\n                type: 'File',\n                message: \"Can not set up FileManager for \" + filePathNode\n            };\n        }\n        var fileSync = fileManager.loadFileSync(filePath, currentDirectory, functionContext.context, environment);\n        if (fileSync.error) {\n            throw fileSync.error;\n        }\n        var sizeOf = require('image-size');\n        return sizeOf(fileSync.filename);\n    }\n    var imageFunctions = {\n        'image-size': function (filePathNode) {\n            var size = imageSize(this, filePathNode);\n            return new expression_1.default([\n                new dimension_1.default(size.width, 'px'),\n                new dimension_1.default(size.height, 'px')\n            ]);\n        },\n        'image-width': function (filePathNode) {\n            var size = imageSize(this, filePathNode);\n            return new dimension_1.default(size.width, 'px');\n        },\n        'image-height': function (filePathNode) {\n            var size = imageSize(this, filePathNode);\n            return new dimension_1.default(size.height, 'px');\n        }\n    };\n    function_registry_1.default.addMultiple(imageFunctions);\n});\n//# sourceMappingURL=image-size.js.map"]}